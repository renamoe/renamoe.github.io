<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>总结 CDQ分治</title>
    <url>/2020/01/17/2020-01-17-%E6%80%BB%E7%BB%93-CDQ%E5%88%86%E6%B2%BB/</url>
    <content><![CDATA[<p>咕了几个月的玩意。。。</p>
<p>先贴几个板子，总结后面补</p>
<a id="more"></a>
<hr />
<p>P1908 逆序对</p>
<p><a href="https://www.luogu.com.cn/problem/P3374">P2274 树状数组1</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    ll id, val, type;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Node &amp;x) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id == x.id ? type &lt; x.type : id &lt; x.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    CDQ(l, mid), CDQ(mid+<span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">int</span> x = l, y = mid+<span class="number">1</span>, k = l;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= mid &amp;&amp; y &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[x] &lt; a[y]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[x].type == <span class="number">1</span>)</span><br><span class="line">                sum += a[x].val;</span><br><span class="line">            t[k++] = a[x++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[y].type == <span class="number">2</span>)</span><br><span class="line">                ans[a[y].val] -= sum;</span><br><span class="line">            <span class="keyword">if</span> (a[y].type == <span class="number">3</span>)</span><br><span class="line">                ans[a[y].val] += sum;</span><br><span class="line">            t[k++] = a[y++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= mid)</span><br><span class="line">        t[k++] = a[x++];</span><br><span class="line">    <span class="keyword">while</span> (y &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[y].type == <span class="number">2</span>)</span><br><span class="line">            ans[a[y].val] -= sum;</span><br><span class="line">        <span class="keyword">if</span> (a[y].type == <span class="number">3</span>)</span><br><span class="line">            ans[a[y].val] += sum;</span><br><span class="line">        t[k++] = a[y++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">        a[i] = t[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, t; i &lt;= n; i++)</span><br><span class="line">    t = read(), a[++cnta] = (Node)&#123;i, t, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    ll c = read(), x = read(), y = read();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">1</span>)</span><br><span class="line">        a[++cnta] = (Node)&#123;x, y, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        a[++cnta] = (Node)&#123;x<span class="number">-1</span>, ++cntq, <span class="number">2</span>&#125;;</span><br><span class="line">        a[++cnta] = (Node)&#123;y, cntq, <span class="number">3</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.luogu.com.cn/problem/P3810">P3810 陌上花开</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c, cnt, ans;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> ==(<span class="keyword">const</span> Node &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a == t.a &amp;&amp; b == t.b &amp;&amp; c == t.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, bn, maxk;</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line">Node a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp1d</span><span class="params">(Node x, Node y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x.a == y.a)</span><br><span class="line">        <span class="keyword">return</span> x.b == y.b ? x.c &lt; y.c : x.b &lt; y.b;</span><br><span class="line">    <span class="keyword">return</span> x.a &lt; y.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp2d</span><span class="params">(Node x, Node y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.b == y.b ? x.c &lt; y.c : x.b &lt; y.b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bit_tree</span> &#123;</span>...&#125; tr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    CDQ(l, mid), CDQ(mid+<span class="number">1</span>, r);</span><br><span class="line">    sort(a+l, a+mid+<span class="number">1</span>, cmp2d);</span><br><span class="line">    sort(a+mid+<span class="number">1</span>, a+r+<span class="number">1</span>, cmp2d);</span><br><span class="line">    <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>, k = l;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; a[i].b &lt;= a[j].b)</span><br><span class="line">            tr.add(a[i].c, a[i].cnt), i++;</span><br><span class="line">        a[j].ans += tr.query(a[j].c), j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = l; j &lt; i; ++j)</span><br><span class="line">        tr.add(a[j].c, -a[j].cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(bn), read(maxk);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= bn; ++i)</span><br><span class="line">        read(b[i].a), read(b[i].b), read(b[i].c);</span><br><span class="line">    sort(b+<span class="number">1</span>, b+bn+<span class="number">1</span>, cmp1d);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= bn; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[i] == b[i<span class="number">-1</span>])</span><br><span class="line">            a[n].cnt++;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            a[++n] = b[i], a[n].cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    CDQ(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cnt[a[i].ans + a[i].cnt - <span class="number">1</span>] += a[i].cnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bn; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title>总结 点分治</title>
    <url>/2020/01/17/2020-01-17-%E6%80%BB%E7%BB%93-%E7%82%B9%E5%88%86%E6%B2%BB/</url>
    <content><![CDATA[<p>用于某些统计树上路径的题</p>
<p>每次找树的重心为根（<span class="math inline">\(O(n)\)</span>）</p>
<a id="more"></a>
<p>处理每个点到根的距离等信息（<span class="math inline">\(O(n)\)</span>）</p>
<p>统计答案（<span class="math inline">\(O(n)\)</span>或<span class="math inline">\(O(nlogn)\)</span>等）</p>
<p>划分根的各个子树，分治下去（总共分治<span class="math inline">\(logn\)</span>层）</p>
<hr />
<h2 id="模板部分">模板部分</h2>
<p>getroot() 找树的重心</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span>, maxs[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt) </span><br><span class="line">        <span class="keyword">if</span> (!vis[e[i].to] &amp;&amp; e[i].to != fa) &#123;</span><br><span class="line">            v = e[i].to;</span><br><span class="line">            getroot(v, u, size);</span><br><span class="line">            sz[u] += sz[v];</span><br><span class="line">            maxs[u] = max(maxs[u], sz[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    maxs[u] = max(maxs[u], size - sz[u]);</span><br><span class="line">    <span class="keyword">if</span> (!root || maxs[u] &lt; maxs[root])</span><br><span class="line">        root = u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getdis() 处理各点的距离</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 带染色</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getdis</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> dis, <span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">    t[++tot] = u;</span><br><span class="line">    d[u] = dis, col[u] = color;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != fa &amp;&amp; !vis[e[i].to])</span><br><span class="line">            v = e[i].to, getdis(v, u, d[u] + e[i].val, color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>统计答案时会重复，同一子树中的两个点是不能成点对的</p>
<p>有两种方式，将各个子树染色，或是通过容斥原理减去子树的一部分答案</p>
<p>solve() 分治</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    ans += calc(u, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt) </span><br><span class="line">        <span class="keyword">if</span> (!vis[e[i].to]) &#123;</span><br><span class="line">            v = e[i].to, root = <span class="number">0</span>;</span><br><span class="line">            ans -= calc(v, e[i].val);<span class="comment">// 染色的话不加这句话</span></span><br><span class="line">            getroot(v, <span class="number">0</span>, sz[v]);</span><br><span class="line">            solve(root);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="统计答案">统计答案</h2>
<p>calc() 每道题是不同的</p>
<p>以<a href="https://www.luogu.com.cn/problem/P3806">模板题</a>为例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一棵有n个点的树，询问树上距离为k的点对是否存在</span><br></pre></td></tr></table></figure>
<p>将每个点的深度处理出来后，按深度排序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tot = <span class="number">0</span>;</span><br><span class="line">t[++tot] = u;</span><br><span class="line">d[u] = dis, col[u] = u;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt)</span><br><span class="line">    <span class="keyword">if</span> (!vis[e[i].to])</span><br><span class="line">        v = e[i].to, getdis(v, u, d[u]+e[i].val, v);</span><br><span class="line">sort(t+<span class="number">1</span>, t+tot+<span class="number">1</span>, cmp);</span><br></pre></td></tr></table></figure>
<p>此时又有两种方法：</p>
<ul>
<li>双指针扫</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r = tot;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d[t[l]] + d[t[r]] &gt; k)</span><br><span class="line">        r--;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (d[t[l]] + d[t[r]] &lt; k)</span><br><span class="line">        l++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (col[t[l]] == col[t[r]])</span><br><span class="line">        d[t[r]] == d[t[r<span class="number">-1</span>]] ? r-- : l++;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ans = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>二分查找</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r;</span><br><span class="line"><span class="keyword">while</span> (l &lt; tot &amp;&amp; d[t[l]] + d[t[tot]] &lt; k)</span><br><span class="line">    l++;</span><br><span class="line"><span class="keyword">while</span> (l &lt; tot) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d[t[l]] &gt; k - d[t[l]])</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    d[<span class="number">0</span>] = k - d[t[l]];</span><br><span class="line">    r = lower_bound(t+<span class="number">1</span>, t+tot+<span class="number">1</span>, <span class="number">0</span>, cmp) - t;</span><br><span class="line">    <span class="keyword">while</span> (r &lt;= tot &amp;&amp; d[t[l]] + d[t[r]] == k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (col[t[l]] != col[t[r]])</span><br><span class="line">            ans = <span class="literal">true</span>;</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    l++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度上限在于排序（<span class="math inline">\(O(nlogn)\)</span>）</p>
<p>如果可以的话，可以桶排，降到（<span class="math inline">\(O(n)\)</span>）</p>
<hr />
<h2 id="一些题目">一些题目</h2>
<p><a href="https://www.luogu.com.cn/problem/P4178">P4178</a>树上长度小于等于k的路径</p>
<p><a href="https://www.luogu.com.cn/problem/P4149">P4149</a>长度为k的路径最小边数</p>
<p>我菜，好多还没做过。。。</p>
]]></content>
      <categories>
        <category>总结</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 AC自动机</title>
    <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-AC%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<p>匹配多个模式串</p>
<p>本质上是trie tree + kmp</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AC_automaton</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">int</span> tr[N][<span class="number">26</span>], fail[N], end[N], tot[M];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(tr, <span class="number">0</span>, <span class="keyword">sizeof</span> tr);</span><br><span class="line">        <span class="built_in">memset</span>(fail, <span class="number">0</span>, <span class="keyword">sizeof</span> fail);</span><br><span class="line">        <span class="built_in">memset</span>(end, <span class="number">0</span>, <span class="keyword">sizeof</span> end);</span><br><span class="line">        <span class="built_in">memset</span>(tot, <span class="number">0</span>, <span class="keyword">sizeof</span> tot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!tr[p][s[i]-<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">                tr[p][s[i]-<span class="string">&#x27;a&#x27;</span>] = ++cnt;</span><br><span class="line">            p = tr[p][s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        end[p] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">            <span class="keyword">if</span> (tr[<span class="number">0</span>][i])</span><br><span class="line">                q.push(tr[<span class="number">0</span>][i]);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tr[x][i])</span><br><span class="line">                    fail[tr[x][i]] = tr[fail[x]][i], q.push(tr[x][i]);</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    tr[x][i] = tr[fail[x]][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            p = tr[p][s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = p; j; j = fail[j])</span><br><span class="line">                tot[end[j]]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>先这样，有时间再补充</p>
]]></content>
      <categories>
        <category>总结</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 Dijkstra / SPFA / Floyd</title>
    <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-Dijkstra--SPFA--Floyd/</url>
    <content><![CDATA[<p>3 种最短路算法。</p>
<a id="more"></a>
<h2 id="dijkstra堆优化">Dijkstra（堆优化）</h2>
<ul>
<li><p>取没有访问过的堆顶</p></li>
<li><p>标记为访问过</p></li>
<li><p>松弛各边</p></li>
<li><p>将未访问过的邻点塞进堆里</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> d, p;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Node &amp;x) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x.d &lt; d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;Node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        d[i] = INF;</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    q.push((Node)&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        Node x = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span> (v[x.p])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        v[x.p] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x.p]; i; i = e[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (d[y] &gt; d[x.p] + e[i].w) &#123;</span><br><span class="line">                d[y] = d[x.p] + e[i].w;</span><br><span class="line">                <span class="keyword">if</span> (!v[y])</span><br><span class="line">                    q.push((Node)&#123;d[y], y&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="spfa">SPFA</h2>
<ul>
<li>取队头</li>
<li>标记为出队</li>
<li>松弛各边</li>
<li>将队外的邻点怼进队里，标记为入队</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        d[i] = INF;</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    q.push(s);</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].next) &#123;</span><br><span class="line">            v = e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (d[v] &gt; d[u] + e[i].val) &#123;</span><br><span class="line">                d[v] = d[u] + e[i].val;</span><br><span class="line">                <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                    vis[v] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="floyd">Floyd</h2>
<p><span class="math inline">\(k,i,j\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 FFT/NTT</title>
    <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-FFTNTT/</url>
    <content><![CDATA[<p><span class="math inline">\(O(nlogn)\)</span> 多项式乘法。</p>
<a id="more"></a>
<h2 id="rader排序">Rader排序</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (lim = <span class="number">1</span>; lim &lt;= n; lim &lt;&lt;= <span class="number">1</span>, len++);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">calc_rev</span><span class="params">(<span class="keyword">int</span> lim, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lim; ++i)</span><br><span class="line">        rev[i] = (rev[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (len - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="fft">FFT</h2>
<h3 id="封装复数">封装复数</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Complex(<span class="keyword">double</span> xx = <span class="number">0</span>, <span class="keyword">double</span> yy = <span class="number">0</span>) &#123;</span><br><span class="line">        x = xx, y = yy;</span><br><span class="line">    &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> +(<span class="keyword">const</span> Complex &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Complex(x + t.x, y + t.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> -(<span class="keyword">const</span> Complex &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Complex(x - t.x, y - t.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> *(<span class="keyword">const</span> Complex &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Complex(x * t.x - y * t.y, y * t.x + x * t.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="fft-1">FFT()</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex *f, <span class="keyword">int</span> lim, <span class="keyword">int</span> opt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; rev[i])</span><br><span class="line">            swap(f[i], f[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function">Complex <span class="title">wn</span><span class="params">(<span class="built_in">cos</span>(Pi / mid), opt * <span class="built_in">sin</span>(Pi / mid))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i += mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="function">Complex <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; ++j, w = w * wn) &#123;</span><br><span class="line">                Complex tx = f[i+j], ty = w * f[i+mid+j];</span><br><span class="line">                f[i+j] = tx + ty, f[i+mid+j] = tx - ty;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">-1</span>) &#123;</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">            f[i].x /= n, f[i].y /= n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三次变两次优化">三次变两次优化</h3>
<p>把 f2 放到 f1 的虚部上，DFT一遍，平方，再把虚部取出来除以2即可</p>
<h2 id="ntt">NTT</h2>
<p>用 int 时注意模好</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> G = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> invG = <span class="number">332748118</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> lim, <span class="keyword">int</span> opt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; rev[i])</span><br><span class="line">            swap(f[i], f[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> wn = power(opt == <span class="number">1</span> ? G : invG, (MOD - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i += (mid &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; ++j, w = (<span class="number">1l</span>l * w * wn) % MOD) &#123;</span><br><span class="line">                LL tx = f[i+j], ty = (<span class="number">1l</span>l * w * f[i+mid+j]) % MOD;</span><br><span class="line">                f[i+j] = (<span class="number">0l</span>l + tx + ty) % MOD;</span><br><span class="line">                f[i+mid+j] = (<span class="number">0l</span>l + tx - ty + MOD) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> invlim = power(lim, MOD - <span class="number">2</span>);</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">            f[i] = <span class="number">1l</span>l * f[i] * invlim % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
        <category>Math</category>
      </categories>
      <tags>
        <tag>FFT/NTT</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 Link-Cut Tree</title>
    <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-Link-Cut-Tree/</url>
    <content><![CDATA[<p>发现还是不要包装每个节点的好，好看还常数小</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Link_Cut_Tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fa[N], ch[N][<span class="number">2</span>], sum[N], val[N], rev[N];</span><br><span class="line">    <span class="keyword">int</span> stk[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">which</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>] == x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">not_root</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ch[fa[x]][<span class="number">0</span>] == x || ch[fa[x]][<span class="number">1</span>] == x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        sum[x] = sum[ch[x][<span class="number">0</span>]] ^ sum[ch[x][<span class="number">1</span>]] ^ val[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        swap(ch[x][<span class="number">0</span>], ch[x][<span class="number">1</span>]), rev[x] ^= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rev[x]) &#123;</span><br><span class="line">            rev[x] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (ch[x][<span class="number">0</span>])</span><br><span class="line">                reverse(ch[x][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span> (ch[x][<span class="number">1</span>])</span><br><span class="line">                reverse(ch[x][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f = fa[x], gf = fa[f], w = which(x), y = ch[x][w^<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (not_root(f))</span><br><span class="line">            ch[gf][which(f)] = x;</span><br><span class="line">        ch[x][w^<span class="number">1</span>] = f, ch[f][w] = y;</span><br><span class="line">        <span class="keyword">if</span> (y)</span><br><span class="line">            fa[y] = f;</span><br><span class="line">        fa[f] = x, fa[x] = gf;</span><br><span class="line">        push_up(f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>, f = x;</span><br><span class="line">        stk[++top] = x;</span><br><span class="line">        <span class="keyword">while</span> (not_root(f))</span><br><span class="line">            stk[++top] = f = fa[f];</span><br><span class="line">        <span class="keyword">while</span> (top)</span><br><span class="line">            push_down(stk[top--]);</span><br><span class="line">        <span class="keyword">while</span> (not_root(x)) &#123;</span><br><span class="line">            f = fa[x];</span><br><span class="line">            <span class="keyword">if</span> (not_root(f))</span><br><span class="line">                which(x) == which(f) ? rotate(f) : rotate(x);</span><br><span class="line">            rotate(x);</span><br><span class="line">        &#125;</span><br><span class="line">        push_up(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; x; y = x, x = fa[x])</span><br><span class="line">            splay(x), ch[x][<span class="number">1</span>] = y, push_up(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">make_root</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        access(x), splay(x), reverse(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        access(x), splay(x);</span><br><span class="line">        <span class="keyword">while</span> (ch[x][<span class="number">0</span>])</span><br><span class="line">            push_down(x), x = ch[x][<span class="number">0</span>];</span><br><span class="line">        splay(x);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        make_root(x), access(y), splay(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        make_root(x);</span><br><span class="line">        <span class="keyword">if</span> (find_root(y) != x)</span><br><span class="line">            fa[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        make_root(x);</span><br><span class="line">        <span class="keyword">if</span> (find_root(y) == x &amp;&amp; fa[y] == x &amp;&amp; !ch[y][<span class="number">0</span>])</span><br><span class="line">            fa[y] = ch[x][<span class="number">1</span>] = <span class="number">0</span>, push_up(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; lct;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
        <category>图论</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 Splay</title>
    <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-Splay/</url>
    <content><![CDATA[<p>splay 也叫伸展树、分裂树。</p>
<a id="more"></a>
<h2 id="here">HERE!</h2>
<blockquote>
<p>update 2020.11.23</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Splay</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> tot, root;</span><br><span class="line">    <span class="keyword">int</span> fa[N], ch[N][<span class="number">2</span>], size[N], cnt[N], val[N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        size[x] = size[ch[x][<span class="number">0</span>]] + size[ch[x][<span class="number">1</span>]] + cnt[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">which</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x == ch[fa[x]][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        fa[x] = ch[x][<span class="number">0</span>] = ch[x][<span class="number">1</span>] = size[x] = val[x] = cnt[x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">new_node</span><span class="params">(<span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> f = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        tot++;</span><br><span class="line">        val[tot] = v, fa[tot] = f;</span><br><span class="line">        size[tot] = cnt[tot] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f = fa[x], gf = fa[f], w = which(x), y = ch[x][w^<span class="number">1</span>];</span><br><span class="line">        ch[gf][which(f)] = x, ch[x][w^<span class="number">1</span>] = f, ch[f][w] = y;</span><br><span class="line">        fa[x] = gf, fa[f] = x, fa[y] = f;</span><br><span class="line">        clear(<span class="number">0</span>), push_up(f), push_up(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> goal = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (fa[x] != goal) &#123;</span><br><span class="line">            <span class="keyword">int</span> f = fa[x];</span><br><span class="line">            <span class="keyword">if</span> (fa[f] != goal)</span><br><span class="line">                which(f) == which(x) ? rotate(f) : rotate(x);</span><br><span class="line">            rotate(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!goal) root = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> root = new_node(k), <span class="keyword">void</span>();</span><br><span class="line">        <span class="keyword">int</span> x = find(k);</span><br><span class="line">        <span class="keyword">if</span> (val[x] == k) cnt[x]++, push_up(x);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ch[x][k &gt; val[x]] = new_node(k, x);</span><br><span class="line">            x = ch[x][k &gt; val[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        splay(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = find(k);</span><br><span class="line">        splay(x);</span><br><span class="line">        <span class="keyword">if</span> (cnt[x] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            cnt[x]--, push_up(x);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ch[x][<span class="number">0</span>] || !ch[x][<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = ch[x][<span class="number">0</span>] | ch[x][<span class="number">1</span>];</span><br><span class="line">            clear(x), fa[y] = <span class="number">0</span>, root = y;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = pre(val[x]), r = ch[x][<span class="number">1</span>];</span><br><span class="line">        splay(l, x);</span><br><span class="line">        clear(x), ch[l][<span class="number">1</span>] = r, fa[r] = l;</span><br><span class="line">        fa[l] = <span class="number">0</span>, root = l, push_up(l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = root, f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &amp;&amp; val[x] != k)</span><br><span class="line">            f = x, x = ch[x][k &gt; val[x]];</span><br><span class="line">        <span class="keyword">return</span> x ? x : f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = find(k), rk = rank_id(x);</span><br><span class="line">        <span class="keyword">return</span> rk + (k &gt; val[x]) * cnt[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rank_id</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        splay(x);</span><br><span class="line">        <span class="keyword">return</span> size[ch[x][<span class="number">0</span>]] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = root;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k &lt;= size[ch[x][<span class="number">0</span>]]) x = ch[x][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; size[ch[x][<span class="number">0</span>]] + cnt[x]) &#123;</span><br><span class="line">                k -= size[ch[x][<span class="number">0</span>]] + cnt[x];</span><br><span class="line">                x = ch[x][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> kth(rank(k) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">nxt</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> kth(rank(k + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; tr;</span><br></pre></td></tr></table></figure>
<hr />
<p>以下是远古代码：</p>
<h2 id="members-初始化">members &amp; 初始化</h2>
<p>每个节点：</p>
<ul>
<li><p><code>val</code> 值</p></li>
<li><p><code>size</code> 子树大小</p>
<!-- more --></li>
<li><p><code>fa</code> 父亲</p></li>
<li><p><code>ch[2]</code> 左/右儿子</p></li>
<li><p><code>cnt</code> 元素个数</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val, size, fa, ch[<span class="number">2</span>], cnt;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> tot, root;<span class="comment">// 元素总数、根</span></span><br><span class="line">Node tr[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">Splay() &#123;</span><br><span class="line">    tot = root = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 为了后面便于操作，插入一个最大值、最小值</span></span><br><span class="line">    insert(INF), insert(-INF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一些常用函数：</p>
<p><strong>push_up()</strong> 更新子树大小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    tr[x].size = tr[tr[x].ch[<span class="number">0</span>]].size + tr[tr[x].ch[<span class="number">1</span>]].size + tr[x].cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>which()</strong> 判断是其父亲的左/右儿子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">which</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == tr[tr[x].fa].ch[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>BST核心</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">p = tr[p].ch[val &gt; tr[p].val];</span><br></pre></td></tr></table></figure>
<h2 id="insert-插入">insert() 插入</h2>
<p>从root开始走</p>
<p>如果有相同值的点，<code>cnt++</code></p>
<p>否则建新点</p>
<p>splay到根</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = root, fa = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; tr[p].val != val)</span><br><span class="line">        fa = p, p = tr[p].ch[val &gt; tr[p].val];</span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">        tr[p].cnt++;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p = ++tot;</span><br><span class="line">        tr[p].val = val;</span><br><span class="line">        tr[p].fa = fa;</span><br><span class="line">        tr[p].ch[<span class="number">0</span>] = tr[p].ch[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        tr[p].size = tr[p].cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (fa)</span><br><span class="line">            tr[fa].ch[val &gt; tr[fa].val] = p;</span><br><span class="line">    &#125;</span><br><span class="line">    splay(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="find-查找值的位置">find() 查找值的位置</h2>
<p>没有节点直接返回</p>
<p>从根开始走就行，返回的是最接近val的节点</p>
<p>splay到根</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> p = root;</span><br><span class="line">    <span class="keyword">while</span> (tr[p].ch[val &gt; tr[p].val] &amp;&amp; val != tr[p].val)</span><br><span class="line">        p = tr[p].ch[val &gt; tr[p].val];</span><br><span class="line">    splay(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="next-查找前驱后继">next() 查找前驱、后继</h2>
<p>find一下这个值，这个值已经splay到根了</p>
<p>如果根满足，直接返回</p>
<p>否则往大/小走一步，在反方向走到底</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// opt 0前驱，1后继</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> opt)</span> </span>&#123;</span><br><span class="line">    find(val);</span><br><span class="line">    <span class="keyword">int</span> p = root;</span><br><span class="line">    <span class="keyword">if</span> ((!opt &amp;&amp; tr[p].val &lt; val) || (opt &amp;&amp; tr[p].val &gt; val))</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    p = tr[p].ch[opt];</span><br><span class="line">    <span class="keyword">while</span> (tr[p].ch[opt^<span class="number">1</span>])</span><br><span class="line">        p = tr[p].ch[opt^<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="delete-删除值">delete() 删除值</h2>
<p>找到该值的前驱、后继</p>
<p>splay前驱到根，后继到根的右儿子</p>
<p>后继的左儿子就是该节点</p>
<p>要么<code>cnt--</code>，要么后继的左儿子改为0</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last = next(val, <span class="number">0</span>), nxt = next(val, <span class="number">1</span>);</span><br><span class="line">    splay(last, <span class="number">0</span>), splay(nxt, last);</span><br><span class="line">    <span class="keyword">int</span> x = tr[nxt].ch[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (tr[x].cnt &gt; <span class="number">1</span>)</span><br><span class="line">        tr[x].cnt--, splay(x, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tr[nxt].ch[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="rotate-旋转">rotate() 旋转</h2>
<p>先求出x的父亲、爷爷，以及x的方向</p>
<blockquote>
<p>爷爷把我当儿子，我把爷爷当爹</p>
</blockquote>
<blockquote>
<p>父亲把我另一个儿子当儿子，他也把我父亲当爹</p>
</blockquote>
<blockquote>
<p>我的父亲当我另一个儿子，父亲把我当爹</p>
</blockquote>
<p>更新fa和x的size</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = tr[x].fa, gfa = tr[fa].fa, w = which(x);</span><br><span class="line">    tr[gfa].ch[which(fa)] = x, tr[x].fa = gfa;</span><br><span class="line">    tr[fa].ch[w] = tr[x].ch[w^<span class="number">1</span>], tr[tr[x].ch[w^<span class="number">1</span>]].fa = fa;</span><br><span class="line">    tr[x].ch[w^<span class="number">1</span>] = fa, tr[fa].fa = x;</span><br><span class="line">    push_up(fa), push_up(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="splay-核心操作">splay() 核心操作</h2>
<p>如果x的fa不是终点，循环：</p>
<pre><code>如果爷爷也不是终点：

    如果x和fa三点共线（方向一致），旋转fa，否则旋转x

再次旋转x</code></pre>
<p>如果旋转到根，更新root</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> goal = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa;</span><br><span class="line">    <span class="keyword">while</span> (tr[x].fa != goal) &#123;</span><br><span class="line">        fa = tr[x].fa;</span><br><span class="line">        <span class="keyword">if</span> (tr[fa].fa != goal)</span><br><span class="line">            which(x) == which(fa) ? rotate(fa) : rotate(x);</span><br><span class="line">        rotate(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!goal)</span><br><span class="line">        root = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="k_th-排名为k的值">k_th() 排名为k的值</h2>
<p>如果从根开始</p>
<p>如果左儿子大小<span class="math inline">\(\ge x\)</span>，走左儿子</p>
<p>如果左儿子大小加上当前点大小<span class="math inline">\(&lt;x\)</span>，x减去它，走右儿子</p>
<p>剩下的就返回该点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">k_th</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    x++;<span class="comment">// 树中有个最小值</span></span><br><span class="line">    <span class="keyword">int</span> p = root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> ls = tr[p].ch[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (tr[ls].size &gt;= x)</span><br><span class="line">            p = ls;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tr[ls].size + tr[p].cnt &lt; x)</span><br><span class="line">            x -= tr[ls].size + tr[p].cnt, p = tr[p].ch[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> tr[p].val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="rank-查找x的排名">rank() 查找x的排名</h2>
<p>find该值</p>
<p>此时根的左儿子的大小就是排名（减去最小值再加上该点）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    find(val);</span><br><span class="line">    <span class="keyword">return</span> tr[tr[root].ch[<span class="number">0</span>]].size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<p>时刻注意树中有最大值和最小值</p>
<h2 id="luogu-p3369-code">luogu P3369 code</h2>
<blockquote>
<p>update on 2020某一天</p>
<p>这个写法很丑很慢，Splay 里面的节点就不要包装了吧</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BANANA &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; T k = <span class="number">1</span>; <span class="keyword">char</span> in = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(in)) &#123; <span class="keyword">if</span> (in == <span class="string">&#x27;-&#x27;</span>) k = <span class="number">-1</span>; in = getchar(); &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(in)) x = x * <span class="number">10</span> + in - <span class="string">&#x27;0&#x27;</span>, in = getchar();</span><br><span class="line">    x *= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Splay</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val, size, fa, ch[<span class="number">2</span>], cnt;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> tot, root;</span><br><span class="line">    Node tr[N];</span><br><span class="line"></span><br><span class="line">    Splay() &#123;</span><br><span class="line">        tot = root = <span class="number">0</span>;</span><br><span class="line">        insert(INF), insert(-INF);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        tr[x].size = tr[tr[x].ch[<span class="number">0</span>]].size + tr[tr[x].ch[<span class="number">1</span>]].size + tr[x].cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">which</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x == tr[tr[x].fa].ch[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = root, fa = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; tr[p].val != val)</span><br><span class="line">            fa = p, p = tr[p].ch[val &gt; tr[p].val];</span><br><span class="line">        <span class="keyword">if</span> (p)</span><br><span class="line">            tr[p].cnt++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p = ++tot;</span><br><span class="line">            tr[p].val = val;</span><br><span class="line">            tr[p].fa = fa;</span><br><span class="line">            tr[p].ch[<span class="number">0</span>] = tr[p].ch[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            tr[p].size = tr[p].cnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (fa)</span><br><span class="line">                tr[fa].ch[val &gt; tr[fa].val] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        splay(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> last = next(val, <span class="number">0</span>), nxt = next(val, <span class="number">1</span>);</span><br><span class="line">        splay(last, <span class="number">0</span>), splay(nxt, last);</span><br><span class="line">        <span class="keyword">int</span> x = tr[nxt].ch[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (tr[x].cnt &gt; <span class="number">1</span>)</span><br><span class="line">            tr[x].cnt--, splay(x, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tr[nxt].ch[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fa = tr[x].fa, gfa = tr[fa].fa, w = which(x);</span><br><span class="line">        tr[gfa].ch[which(fa)] = x, tr[x].fa = gfa;</span><br><span class="line">        tr[fa].ch[w] = tr[x].ch[w^<span class="number">1</span>], tr[tr[x].ch[w^<span class="number">1</span>]].fa = fa;</span><br><span class="line">        tr[x].ch[w^<span class="number">1</span>] = fa, tr[fa].fa = x;</span><br><span class="line">        push_up(fa), push_up(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> goal = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fa;</span><br><span class="line">        <span class="keyword">while</span> (tr[x].fa != goal) &#123;</span><br><span class="line">            fa = tr[x].fa;</span><br><span class="line">            <span class="keyword">if</span> (tr[fa].fa != goal)</span><br><span class="line">                which(x) == which(fa) ? rotate(fa) : rotate(x);</span><br><span class="line">            rotate(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!goal)</span><br><span class="line">            root = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> p = root;</span><br><span class="line">        <span class="keyword">while</span> (tr[p].ch[val &gt; tr[p].val] &amp;&amp; val != tr[p].val)</span><br><span class="line">            p = tr[p].ch[val &gt; tr[p].val];</span><br><span class="line">        splay(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> opt)</span> </span>&#123;</span><br><span class="line">        find(val);</span><br><span class="line">        <span class="keyword">int</span> p = root;</span><br><span class="line">        <span class="keyword">if</span> ((!opt &amp;&amp; tr[p].val &lt; val) || (opt &amp;&amp; tr[p].val &gt; val))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        p = tr[p].ch[opt];</span><br><span class="line">        <span class="keyword">while</span> (tr[p].ch[opt^<span class="number">1</span>])</span><br><span class="line">            p = tr[p].ch[opt^<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">k_th</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">        <span class="keyword">int</span> p = root;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> ls = tr[p].ch[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (tr[ls].size &gt;= x)</span><br><span class="line">                p = ls;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tr[ls].size + tr[p].cnt &lt; x)</span><br><span class="line">                x -= tr[ls].size + tr[p].cnt, p = tr[p].ch[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> tr[p].val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        find(val);</span><br><span class="line">        <span class="keyword">return</span> tr[tr[root].ch[<span class="number">0</span>]].size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Splay tree;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">int</span> opt, x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        read(opt), read(x);</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                tree.insert(x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                tree.del(x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tree.rank(x));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tree.k_th(x));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tree.tr[tree.next(x, <span class="number">0</span>)].val);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tree.tr[tree.next(x, <span class="number">1</span>)].val);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BANANA::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 Tarjan</title>
    <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-Tarjan/</url>
    <content><![CDATA[<p>Tarjan是个好东西</p>
<p>求强连通分量，可以用来缩点等等</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[N], dfn[N], low[N], col[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++tot;</span><br><span class="line">    <span class="built_in">stack</span>[++top] = u;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">        v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[v])</span><br><span class="line">            Tarjan(v), low[u] = min(low[u], low[v]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vis[v])</span><br><span class="line">            low[u] = min(low[u], low[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfn[u] == low[u]) &#123;</span><br><span class="line">        scc++;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            v = <span class="built_in">stack</span>[top--];</span><br><span class="line">            vis[v] = <span class="literal">false</span>;</span><br><span class="line">            col[v] = scc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (v != u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="缩点"><a href="https://www.luogu.org/record/20159280">缩点</a></h3>
<p>搞出强连通分量后，重新建图，该干啥干啥</p>
<p><a href="https://www.luogu.org/problem/P2515">P2515</a></p>
<p><a href="https://www.luogu.org/problem/T103252?contestId=22368">T103252</a></p>
<p><a href="https://www.luogu.com.cn/problem/P2746">P2746</a></p>
<h2 id="割点">割点</h2>
<p>和求强连通分量不太一样</p>
<p><code>low[x]</code>表示 <span class="math inline">\(dfs\)</span> 下去最早遇到的割点</p>
<p>当 <span class="math inline">\(v\)</span> 已经访问过时，用 <span class="math inline">\(dfn[v]\)</span> 更新 <span class="math inline">\(low[u]\)</span> （为什么？画两个连环就知道了）</p>
<p>当 <span class="math inline">\(u\)</span> 为根时只要统计子树个数即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++tot;</span><br><span class="line">    <span class="keyword">int</span> v, ch = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">        v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">            Tarjan(v, rt), low[u] = min(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span> (u != rt &amp;&amp; low[v] &gt;= dfn[u])<span class="comment">// 环在u的子树里，u为割点</span></span><br><span class="line">                cut[u] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (u == rt)</span><br><span class="line">                ch++;</span><br><span class="line">        &#125;</span><br><span class="line">        low[u] = min(low[u], dfn[v]);<span class="comment">// 注意这里	</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u == rt &amp;&amp; ch &gt;= <span class="number">2</span>)</span><br><span class="line">        cut[u] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缩它</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">if</span> (!dfn[i])</span><br><span class="line">        Tarjan(i, i);<span class="comment">// i = rt</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 WBLT</title>
    <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-WBLT/</url>
    <content><![CDATA[<p>本质上是平衡线段树</p>
<p>叶子节点维护原数列，非叶子节点维护子树最大值</p>
<p>比splay好写多了</p>
<a id="more"></a>
<p>我数组版+各种封装的巨大常数+单旋，luogu上跑347ms，开O2后161ms，还算可以</p>
<p>没时间总结了，贴个板子走人</p>
<p>强烈安利 Blog：<a href="https://www.luogu.com.cn/blog/qwaszx/leafy-tree-hu-wblt-xue-xi-bi-ji?tdsourcetag=s_pctim_aiomsg">qwaszx 的博客</a></p>
<h2 id="维护平衡">维护平衡</h2>
<p>WBLT 可以通过旋转或者拍扁重建（类似替罪羊树）的方式维护平衡</p>
<p>我<del>只会</del>喜欢旋转，而且为了方便我就只写单旋</p>
<p>单旋复杂度不对但是不好卡（慢是慢一点）</p>
<p>有时间再更双旋吧</p>
<p>每次 insert/delete 后回溯更新信息时 maintain 一下</p>
<h2 id="code">code</h2>
<blockquote>
<p>update 2020.2.19 贴个封装少的</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WBLT</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> cnt, root;</span><br><span class="line">    <span class="keyword">int</span> val[M], sz[M], ls[M], rs[M];</span><br><span class="line">    </span><br><span class="line">    WBLT() &#123;</span><br><span class="line">    	new_node(root, <span class="number">1e9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_leaf</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !(ls[x] || rs[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (is_leaf(x)) <span class="keyword">return</span>;</span><br><span class="line">        val[x] = max(val[ls[x]], val[rs[x]]);</span><br><span class="line">        sz[x] = sz[ls[x]] + sz[rs[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">new_node</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        x = ++cnt;</span><br><span class="line">        val[x] = k, sz[x] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">bool</span> opt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!opt) &#123;</span><br><span class="line">            <span class="keyword">int</span> rson = rs[x];</span><br><span class="line">            rs[x] = ls[x], ls[x] = ls[rs[x]];</span><br><span class="line">            ls[rs[x]] = rs[rs[x]], rs[rs[x]] = rson;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> lson = ls[x];</span><br><span class="line">            ls[x] = rs[x], rs[x] = rs[ls[x]];</span><br><span class="line">            rs[ls[x]] = ls[ls[x]], ls[ls[x]] = lson;</span><br><span class="line">        &#125;</span><br><span class="line">        push_up(ls[x]), push_up(rs[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (is_leaf(x)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (sz[ls[x]] &gt;= sz[rs[x]] * <span class="number">4</span>) rotate(x, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sz[rs[x]] &gt;= sz[ls[x]] * <span class="number">4</span>) rotate(x, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (is_leaf(x)) &#123;</span><br><span class="line">            new_node(ls[x], min(val[x], k));</span><br><span class="line">            new_node(rs[x], max(val[x], k));</span><br><span class="line">            push_up(x);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= val[ls[x]]) insert(ls[x], k);</span><br><span class="line">        <span class="keyword">else</span> insert(rs[x], k);</span><br><span class="line">        push_up(x), maintain(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (is_leaf(x)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!fa) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">int</span> son = ls[fa] == x ? rs[fa] : ls[fa];</span><br><span class="line">            val[fa] = val[son], sz[fa] = sz[son];</span><br><span class="line">            ls[fa] = ls[son], rs[fa] = rs[son];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= val[ls[x]]) erase(ls[x], x, k);</span><br><span class="line">        <span class="keyword">else</span> erase(rs[x], x, k);</span><br><span class="line">        push_up(x), maintain(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rank</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (is_leaf(x))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + (k &gt; val[x]);</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= val[ls[x]]) <span class="keyword">return</span> rank(ls[x], k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> sz[ls[x]] + rank(rs[x], k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">k_th</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (is_leaf(x)) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= sz[ls[x]]) <span class="keyword">return</span> k_th(ls[x], k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> k_th(rs[x], k - sz[ls[x]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> k, <span class="keyword">bool</span> opt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rk = rank(rt, k), rk2 = rank(rt, k+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!opt &amp;&amp; rk == <span class="number">1</span>) <span class="keyword">return</span> -INF;</span><br><span class="line">        <span class="keyword">if</span> (opt &amp;&amp; rk2 &gt; sz[rt]) <span class="keyword">return</span> INF;</span><br><span class="line">        <span class="keyword">return</span> val[k_th(rt, opt ? rk2 : rk - <span class="number">1</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="luogu-p3369-code">Luogu P3369 code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BANANA &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;<span class="comment">/*Orz*/</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WBLT</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val, size, ls, rs;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> root, cnt;</span><br><span class="line">    Node tr[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_leaf</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !(tr[x].ls || tr[x].rs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (is_leaf(x))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        tr[x].val = max(tr[tr[x].ls].val, tr[tr[x].rs].val);</span><br><span class="line">        tr[x].size = tr[tr[x].ls].size + tr[tr[x].rs].size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">new_node</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        x = ++cnt;</span><br><span class="line">        tr[x].val = val, tr[x].size = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">bool</span> opt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!opt) &#123;</span><br><span class="line">            <span class="keyword">int</span> rs = tr[x].rs;</span><br><span class="line">            tr[x].rs = tr[x].ls;</span><br><span class="line">            tr[x].ls = tr[tr[x].rs].ls;</span><br><span class="line">            tr[tr[x].rs].ls = tr[tr[x].rs].rs;</span><br><span class="line">            tr[tr[x].rs].rs = rs;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> ls = tr[x].ls;</span><br><span class="line">            tr[x].ls = tr[x].rs;</span><br><span class="line">            tr[x].rs = tr[tr[x].ls].rs;</span><br><span class="line">            tr[tr[x].ls].rs = tr[tr[x].ls].ls;</span><br><span class="line">            tr[tr[x].ls].ls = ls;</span><br><span class="line">        &#125;</span><br><span class="line">        push_up(tr[x].ls), push_up(tr[x].rs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (is_leaf(x))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (tr[tr[x].ls].size &gt;= tr[tr[x].rs].size * <span class="number">4</span>)</span><br><span class="line">            rotate(x, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (tr[tr[x].rs].size &gt;= tr[tr[x].ls].size * <span class="number">4</span>)</span><br><span class="line">            rotate(x, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (is_leaf(x)) &#123;</span><br><span class="line">            new_node(tr[x].ls, min(tr[x].val, val));</span><br><span class="line">            new_node(tr[x].rs, max(tr[x].val, val));</span><br><span class="line">            push_up(x);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (val &lt;= tr[tr[x].ls].val)</span><br><span class="line">            insert(tr[x].ls, val);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            insert(tr[x].rs, val);</span><br><span class="line">        push_up(x), maintain(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (is_leaf(x)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tr[x].val == val) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == tr[fa].ls)</span><br><span class="line">                    tr[fa] = tr[tr[fa].rs];</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    tr[fa] = tr[tr[fa].ls];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (val &lt;= tr[tr[x].ls].val)</span><br><span class="line">            del(tr[x].ls, x, val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            del(tr[x].rs, x, val);</span><br><span class="line">        push_up(x), maintain(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rank</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (is_leaf(x)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + (val &gt; tr[x].val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (val &lt;= tr[tr[x].ls].val)</span><br><span class="line">            <span class="keyword">return</span> rank(tr[x].ls, val);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> tr[tr[x].ls].size + rank(tr[x].rs, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">k_th</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (is_leaf(x))</span><br><span class="line">            <span class="keyword">return</span> tr[x].val;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= tr[tr[x].ls].size)</span><br><span class="line">            <span class="keyword">return</span> k_th(tr[x].ls, k);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> k_th(tr[x].rs, k - tr[tr[x].ls].size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">WBLT t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    t.new_node(t.root, <span class="number">1e9</span>);</span><br><span class="line">    <span class="keyword">int</span> opt, x;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        read(opt), read(x);</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                t.insert(t.root, x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                t.del(t.root, <span class="number">0</span>, x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t.rank(t.root, x));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t.k_th(t.root, x));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t.k_th(t.root, t.rank(t.root, x) - <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t.k_th(t.root, t.rank(t.root, x+<span class="number">1</span>)));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BANANA::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 kmp</title>
    <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-kmp/</url>
    <content><![CDATA[<p>利用 nxt 数组使字符串匹配降到 <span class="math inline">\(O(n)\)</span>。</p>
<a id="more"></a>
<h2 id="next">next</h2>
<p>i从2开始，j从0开始</p>
<p>i和j+1匹配不上，j跳nxt</p>
<p>匹配就<code>j++</code></p>
<p><code>nxt[i] = j</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= blen; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; b[j+<span class="number">1</span>] != b[i])</span><br><span class="line">        j = nxt[j];</span><br><span class="line">    <span class="keyword">if</span> (b[j+<span class="number">1</span>] == b[i])</span><br><span class="line">        ++j;</span><br><span class="line">    nxt[i] = j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匹配">匹配</h2>
<p>i从a的1-len，j从0开始</p>
<p><code>a[i]</code>和<code>b[j+1]</code>匹配不上就j跳nxt</p>
<p>否则<code>j++</code></p>
<p>j到blen则匹配完一次，跳nxt</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= alen; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; b[j+<span class="number">1</span>] != a[i])</span><br><span class="line">        j = nxt[j];</span><br><span class="line">    <span class="keyword">if</span> (b[j+<span class="number">1</span>] == a[i])</span><br><span class="line">        ++j;</span><br><span class="line">    <span class="keyword">if</span> (j == blen) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i - blen + <span class="number">1</span>);</span><br><span class="line">        ans++;</span><br><span class="line">        j = nxt[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<p>以上为远古文章。</p>
<h2 id="扩展-kmp">扩展 kmp</h2>
<p><a href="https://www.luogu.com.cn/problem/P5410">板子题</a></p>
<blockquote>
<p>给出长为 <span class="math inline">\(n\)</span> 的字符串 <span class="math inline">\(s\)</span>。</p>
<p><span class="math inline">\(\mathcal O(n)\)</span> 处理 <span class="math inline">\(z\)</span> 函数：<span class="math inline">\(z_i=|\operatorname{LCP}(s,s[i:])|\)</span>。</p>
</blockquote>
<p>记录 <span class="math inline">\(r\)</span> 最大的一对 <span class="math inline">\(l,r\)</span> 满足 <span class="math inline">\(r=l+z_l-1\)</span>。</p>
<p>设从前到后处理到 <span class="math inline">\(i\)</span>，当 <span class="math inline">\(i\le r\)</span> 时，初始化 <span class="math inline">\(z_i=\min\{z_{i-l+1},-i+1\}\)</span>，否则为 <span class="math inline">\(0\)</span>。</p>
<p>然后暴力匹配 <span class="math inline">\(s[i+z_i]\)</span> 和 <span class="math inline">\(z[z_i+1]\)</span>。</p>
<p>每个字符最多被暴力匹配 <span class="math inline">\(1\)</span> 次，复杂度 <span class="math inline">\(\mathcal O(n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">z[<span class="number">1</span>] = n;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= r) z[i] = min(z[i - l + <span class="number">1</span>], r - i + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (i + z[i] &lt;= n &amp;&amp; s[z[i] + <span class="number">1</span>] == s[i + z[i]]) ++z[i];</span><br><span class="line">    <span class="keyword">if</span> (i + z[i] - <span class="number">1</span> &gt; r) l = i, r = i + z[i] - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>kmp匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 倍增LCA</title>
    <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-%E5%80%8D%E5%A2%9ELCA/</url>
    <content><![CDATA[<p>倍增法求树上公共祖先</p>
<a id="more"></a>
<h2 id="预处理">预处理</h2>
<p>先<span class="math inline">\(dfs\)</span>一遍预处理：</p>
<p><span class="math inline">\(deep[x]\)</span>：x的深度</p>
<p><span class="math inline">\(fa[x][i]\)</span>：x的第<span class="math inline">\(2^i\)</span>个祖先（倍增数组）</p>
<p>记住<code>fa[x][i] = fa[fa[x][i-1]][i-1]</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">    deep[x] = deep[last] + <span class="number">1</span>;</span><br><span class="line">    fa[x][<span class="number">0</span>] = last;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; <span class="number">1</span> &lt;&lt; i &lt;= deep[x]; ++i)</span><br><span class="line">        fa[x][i] = fa[fa[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != last)</span><br><span class="line">            dfs(e[i].to, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>预处理<span class="math inline">\(log[]\)</span>数组，递推一下就好：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    lg[i] = lg[i<span class="number">-1</span>] + (<span class="number">1</span> &lt;&lt; lg[i<span class="number">-1</span>] == i);</span><br></pre></td></tr></table></figure>
<h2 id="求lca">求<span class="math inline">\(LCA\)</span></h2>
<p>让深度大的往上跳，直到两点同一深度</p>
<p>然后两个点同时往上跳，直到父亲相同</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deep[a] &lt; deep[b])</span><br><span class="line">        swap(a, b);</span><br><span class="line">    <span class="keyword">while</span> (deep[a] &gt; deep[b])</span><br><span class="line">        a = fa[a][lg[deep[a]-deep[b]]<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span> (a == b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lg[deep[a]]; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> (fa[a][i] != fa[b][i])</span><br><span class="line">            a = fa[a][i], b = fa[b][i];</span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<blockquote>
<p>upd 2020.8.11</p>
<p>更方便的写法</p>
</blockquote>
<p>不要处理 log 数组了，看数据范围决定 log 的最大值就行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deep[a] &lt; deep[b])</span><br><span class="line">        swap(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> (deep[fa[a][i]] &gt;= deep[b])</span><br><span class="line">            a = fa[a][i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> (fa[a][i] != fa[b][i])</span><br><span class="line">            a = fa[a][i], b = fa[b][i];</span><br><span class="line">    <span class="keyword">return</span> a == b ? a : fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 左偏树</title>
    <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-%E5%B7%A6%E5%81%8F%E6%A0%91/</url>
    <content><![CDATA[<p>左偏树本质是堆，在满足父亲比两个儿子的<span class="math inline">\(val\)</span>都大（小）的时候保证</p>
<p><span class="math display">\[dist[ls] &gt;= dist[rs]\]</span></p>
<p><span class="math display">\[dist[x] = dist[rs] + 1\]</span></p>
<a id="more"></a>
<p>于是就支持<span class="math inline">\(merge\)</span>快速合并</p>
<p><span class="math inline">\(pop\)</span>就乱搞，合并两子树就行</p>
<p>可以用并查集维护所在堆</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ch[N][<span class="number">2</span>], dist[N], fa[N], val[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y)</span><br><span class="line">        <span class="keyword">return</span> x | y;</span><br><span class="line">    <span class="keyword">if</span> (val[x] &gt; val[y])</span><br><span class="line">        swap(x, y);</span><br><span class="line">    ch[x][<span class="number">1</span>] = merge(ch[x][<span class="number">1</span>], y);</span><br><span class="line">    <span class="keyword">if</span> (dist[ch[x][<span class="number">0</span>]] &lt; dist[ch[x][<span class="number">1</span>]])</span><br><span class="line">        swap(ch[x][<span class="number">0</span>], ch[x][<span class="number">1</span>]);</span><br><span class="line">    dist[x] = dist[ch[x][<span class="number">1</span>]] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    val[x] = <span class="number">-1</span>, fa[ch[x][<span class="number">0</span>]] = fa[ch[x][<span class="number">1</span>]] = fa[x] = merge(ch[x][<span class="number">0</span>], ch[x][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    fa[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// merge</span></span><br><span class="line"><span class="keyword">int</span> fx = find(x), fy = find(y);</span><br><span class="line">fa[fx] = fa[fy] = merge(fx, fy);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左偏树</tag>
      </tags>
  </entry>
  <entry>
    <title>总结 并查集</title>
    <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<p>并查集用于处理一些不交集的 <strong>合并</strong> 及 <strong>查询</strong> 问题。</p>
<a id="more"></a>
<h2 id="简易版">简易版</h2>
<p>注意提前把father赋为自己！！！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    fa[i] = i;</span><br></pre></td></tr></table></figure>
<p>含路径压缩的查找函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = find(fa[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>合并函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x = find(x), y = find(y);</span><br><span class="line">    <span class="keyword">if</span> (x != y) fa[x] = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="路径压缩-按秩合并">路径压缩× 按秩合并√</h2>
<p>某些题无法使用路径压缩，那就维护点数或者深度，按秩合并。</p>
<p>每次查询复杂度 <span class="math inline">\(O(logn)\)</span>，不会证。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x = find(x), y = find(y);</span><br><span class="line">    <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (size[x] &gt; size[y]) swap(x, y);</span><br><span class="line">        fa[x] = y, size[y] += size[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="带权并查集">带权并查集</h2>
<p>当两个元素之间的关系可以量化，并且关系可以合并时，可以使用带权并查集来维护元素之间的关系。</p>
<p>每个节点维护某种权值，在查找时合并根到其路径上的权值。</p>
<p>例题：<a href="https://www.luogu.com.cn/problem/P2024">P2024 [NOI2001]食物链</a></p>
<p>权值实际上是建立在边上的，我们可以用 0,1,2 分别代表同类、天敌和猎物。</p>
<p>查找时在模3意义下累加节点祖先的权值，可以推出节点和根和关系。</p>
<p>权值相减可以得到两个节点的关系。</p>
<h2 id="扩展域并查集">扩展域并查集</h2>
<p>将每个点拆成多个点来维护多组关系，种类并查集似乎属于扩展域并查集。</p>
<p>例题：<a href="https://www.luogu.com.cn/problem/P1525">P1525 关押罪犯</a></p>
<p>将每个点拆成罪犯的朋友和罪犯的敌人，分别形成集合，就可以判断矛盾关系了。</p>
<p>食物链也可以用扩展域并查集做，需要维护三个种类。</p>
]]></content>
      <categories>
        <category>总结</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 欧拉线性筛</title>
    <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-%E6%AC%A7%E6%8B%89%E7%BA%BF%E6%80%A7%E7%AD%9B/</url>
    <content><![CDATA[<p>欧拉线性筛可以 <span class="math inline">\(O(n)\)</span> 筛出质数和积性函数。</p>
<a id="more"></a>
<h2 id="筛质数">筛质数</h2>
<p>未访问的是质数</p>
<p>之后从质数表开始</p>
<p>把<span class="math inline">\(i*pri[j]\)</span>标为访问过</p>
<p>如果<span class="math inline">\(i\)</span>是<span class="math inline">\(pri[j]\)</span>的倍数就跳出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pri;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[i])</span><br><span class="line">        pri.push_back(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pri.size() &amp;&amp; pri[j] * i &lt;= n; ++j) &#123;</span><br><span class="line">        vis[pri[j]*i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="筛varphix">筛<span class="math inline">\(\varphi(x)\)</span></h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tag[i])</span><br><span class="line">        pri[++tot] = i, phi[i] = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, k; j &lt;= tot &amp;&amp; (k = pri[j] * i) &lt;= n; ++j) &#123;</span><br><span class="line">        tag[k] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (i % pri[j])</span><br><span class="line">            phi[k] = phi[i] * phi[pri[j]];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            phi[k] = phi[i] * pri[j];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="筛dx">筛<span class="math inline">\(d(x)\)</span></h2>
<p><del>粘过来的</del>线性筛 <span class="math inline">\(d(x)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vis[i] = d[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) </span><br><span class="line">        pri.push_back(i), d[i] = <span class="number">2</span>, a[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pri.size() &amp;&amp; i * pri[j] &lt;= n; ++j) &#123;</span><br><span class="line">        vis[i*pri[j]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i % pri[j]) </span><br><span class="line">            d[i*pri[j]] = d[i] * d[pri[j]], a[i*pri[j]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            d[i*pri[j]] = d[i] / (a[i] + <span class="number">1</span>) * (a[i] + <span class="number">2</span>);</span><br><span class="line">            a[i*pri[j]] = a[i]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
        <category>Math</category>
      </categories>
      <tags>
        <tag>欧拉线性筛</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 网络流</title>
    <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-%E7%BD%91%E7%BB%9C%E6%B5%81/</url>
    <content><![CDATA[<p>dinic 跑最大流和 EK 跑费用流的模板</p>
<a id="more"></a>
<h2 id="网络最大流-dinic">网络最大流 Dinic</h2>
<p>记得加当前弧优化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, cnt = <span class="number">1</span>, s, t;</span><br><span class="line"><span class="keyword">int</span> head[N], deep[N], cur[N];</span><br><span class="line">Edge e[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">bool</span> inq[N];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cur[i] = head[i];</span><br><span class="line">    <span class="built_in">memset</span>(deep, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> deep);</span><br><span class="line">    q.push(s), inq[s] = <span class="literal">true</span>;</span><br><span class="line">    deep[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        inq[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (deep[v] &gt; deep[u] + <span class="number">1</span> &amp;&amp; e[i].flow) &#123;</span><br><span class="line">                deep[v] = deep[u] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (!inq[v])</span><br><span class="line">                    q.push(v), inq[v] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deep[t] != INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> flow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == t || !flow)</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="keyword">int</span> rlow, v, re = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">        v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (deep[v] == deep[u] + <span class="number">1</span> &amp;&amp; e[i].val &amp;&amp; (rlow = dfs(v, min(flow, e[i].val)))) &#123;</span><br><span class="line">            e[i].val -= rlow, e[i^<span class="number">1</span>].val += rlow;</span><br><span class="line">            flow -= rlow, re += rlow;</span><br><span class="line">            <span class="keyword">if</span> (!flow) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!re) deep[u] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxflow = <span class="number">0</span>, lowflow;</span><br><span class="line">    <span class="keyword">while</span> (bfs())</span><br><span class="line">        maxflow += dfs(s, INF);</span><br><span class="line">    <span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="费用流-ek">费用流 EK</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, cnt, s, t, maxflow, mincost;</span><br><span class="line"><span class="keyword">int</span> head[N], prev[N], pree[N], dis[N], flow[N];</span><br><span class="line">Edge e[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> inq[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    e[++cnt] = (Edge)&#123;head[u], v, w, f&#125;, head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(inq, <span class="number">0</span>, <span class="keyword">sizeof</span> inq);</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="built_in">memset</span>(flow, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> flow);</span><br><span class="line">    q.push(s), inq[s] = <span class="literal">true</span>;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(), v;</span><br><span class="line">        q.pop();</span><br><span class="line">        inq[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">            v = e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (e[i].flow &gt; <span class="number">0</span> &amp;&amp; dis[v] &gt; dis[u] + e[i].cost) &#123;</span><br><span class="line">                dis[v] = dis[u] + e[i].cost;</span><br><span class="line">                prev[v] = u, pree[v] = i;</span><br><span class="line">                flow[v] = min(flow[u], e[i].flow);</span><br><span class="line">                <span class="keyword">if</span> (!inq[v])</span><br><span class="line">                    q.push(v), inq[v] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow[t] != INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">EK</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (SPFA()) &#123;</span><br><span class="line">        maxflow += flow[t];</span><br><span class="line">        mincost += flow[t] * dis[t];</span><br><span class="line">        <span class="keyword">int</span> x = t;</span><br><span class="line">        <span class="keyword">while</span> (x != s) &#123;</span><br><span class="line">            e[pree[x]].flow -= flow[t];</span><br><span class="line">            e[pree[x]^<span class="number">1</span>].flow += flow[t];</span><br><span class="line">            x = prev[x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加边注意</span></span><br><span class="line">add(u, v, w, f), add(v, u, <span class="number">0</span>, -f);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>网络最大流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 高斯消元</title>
    <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/</url>
    <content><![CDATA[<p>我选择的是简单好写的高斯-约旦消法</p>
<a id="more"></a>
<blockquote>
<p>1.选择一个尚未被选过的未知数作为主元，选择一个包含这个主元的方程。</p>
<p>2.将这个方程主元的系数化为1。</p>
<p>3.通过加减消元，消掉其它方程中的这个未知数。</p>
<p>4.重复以上步骤，直到把所有式子变成形如: a*1+b*0+c*0……=d</p>
</blockquote>
<p>code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Gauss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 找到该列的最大值</span></span><br><span class="line">        <span class="keyword">int</span> mx = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(a[j][i]) &gt; <span class="built_in">abs</span>(a[mx][i]))</span><br><span class="line">                mx = j;</span><br><span class="line">        <span class="keyword">if</span> (a[mx][i] == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">// 返回无解</span></span><br><span class="line">        <span class="comment">// 交换行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n + <span class="number">1</span>; ++j)</span><br><span class="line">            swap(a[i][j], a[mx][j]);</span><br><span class="line">        <span class="comment">// 加减消元</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)<span class="comment">// 注意是1~n</span></span><br><span class="line">            <span class="keyword">if</span> (j != i) &#123;</span><br><span class="line">                <span class="keyword">double</span> d = a[j][i] / a[i][i];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt;= n + <span class="number">1</span>; ++k)</span><br><span class="line">                    a[j][k] -= a[i][k] * d;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出解</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, a[i][n+<span class="number">1</span>] / a[i][i]);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
        <category>Math</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>蒟蒻的zz码风</title>
    <url>/2020/01/17/2020-01-17-%E8%92%9F%E8%92%BB%E7%9A%84zz%E7%A0%81%E9%A3%8E/</url>
    <content><![CDATA[<p>自认为码风就像代码的脸，无论是调试还是写题解都极其重要</p>
<p>下面是我的码风，莫喷</p>
<a id="more"></a>
<h2 id="空格-tab">空格 &amp; tab</h2>
<p><strong>松散胜于紧凑</strong></p>
<ul>
<li>tab宽度4</li>
<li>运算符前后加空格</li>
<li><code>,</code> 后加空格</li>
<li>嫌挤的地方加空格</li>
<li>大括号不换行（少说这个，引起战争）</li>
</ul>
<p>大概一个 a+b 写成这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码块分布">代码块分布</h2>
<p>意思相近的语句、函数写到一块</p>
<p>大块数据结构包装起来</p>
<p>各个代码块间加空行（我乱加空行的怪癖改不掉）</p>
<p>顺序嘛：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快读</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TT&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(TT &amp;x)</span> </span>&#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏定义/结构体定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ... ...</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量定义</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量定义</span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数/包装用的结构体</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Splay</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>当然我喜欢总体套一个 namespace ，看<a href="https://banana.blog.luogu.org/tong-guo-namespace-fang-zhi-ming-ming-chong-tu">这里</a></p>
<h2 id="压行">压行</h2>
<p>曾经我是痛恨压行的，如今自己成为了曾经讨厌的人。。。</p>
<p><strong>代码还是简洁的好</strong></p>
<p>不过自认为压行并不是凑到一块那么简单</p>
<p>我曾见过这样的压行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n+k+<span class="number">1</span>;++i)cur[i]=head[i];</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(deep,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(deep));<span class="built_in">memset</span>(inq,<span class="number">0</span>,<span class="keyword">sizeof</span>(inq));</span><br><span class="line">    q.push(s);inq[s]=<span class="literal">true</span>;deep[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front(),v;q.pop();inq[u]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=e[i].nxt)&#123;v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(deep[v]&gt;deep[u]+<span class="number">1</span>&amp;&amp;e[i].flow)&#123;</span><br><span class="line">                deep[v]=deep[u]+<span class="number">1</span>;<span class="keyword">if</span>(!inq[v])&#123;q.push(v);inq[v]=<span class="literal">true</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deep[t]!=INF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>不是我想针对谁，这样压行太拙劣了</del></p>
<p>压行要有原则和规范</p>
<ul>
<li><p>一行内尽量不出现多个<code>;</code></p></li>
<li><p><code>&#123;</code> 后不要写东西， <code>&#125;</code>另起一行（大括号一般使用时）</p></li>
<li><p>不好理解或过于复杂的代码不压行</p></li>
<li><p><strong>熟练运用 C++ 语言特性来缩减语句</strong></p>
<ul>
<li><code>for/while</code> 等里面只有一句时不加大括号</li>
<li>用<code>,</code>连接较短语句，作为一句（有时候还能少个大括号呢）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= n; ++i)</span><br><span class="line">   	read(u), read(v), add(u, v);</span><br></pre></td></tr></table></figure>
<ul>
<li>多用三目运算符代替简单的 <code>if/else</code> 判断</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">get(fa) == get(x) ? rotate(fa) : rotate(x);</span><br><span class="line">(tag ? a1 : a2)[i] = x;<span class="comment">// 雾</span></span><br></pre></td></tr></table></figure>
<ul>
<li>多使用结构体的整体赋值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">e[++cnt] = (Edge)&#123;head[u], v&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>运用<code>&amp;&amp;</code> <code>||</code>的短路特性</li>
<li>部分<code>()</code> <code>[]</code>中嵌套一些简单赋值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt)</span><br><span class="line">    <span class="keyword">if</span> ((v = e[i].to) != fa)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></li>
</ul>
<p><del>显然我的压行优越得多</del></p>
<hr />
<p>总之敲代码要心情愉悦~</p>
<p>最后附上我美轮美奂的 vscode</p>
<blockquote>
<p>update 2020.1.18</p>
<p>有人说“美轮美奂”不应该在这用，好吧我语文不好，<del>只好说把我的VSCODE比喻为华丽的建筑</del></p>
</blockquote>
<p><img src="https://s2.ax1x.com/2019/12/15/QfFSPJ.jpg" /></p>
<p>欢迎交流互鉴</p>
<hr />
<p><del>平写题解都没见你bb这么多</del></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>题解 P1373 【小a和uim之大逃离】</title>
    <url>/2020/01/17/2020-01-17-%E9%A2%98%E8%A7%A3-P1373-%E3%80%90%E5%B0%8Fa%E5%92%8Cuim%E4%B9%8B%E5%A4%A7%E9%80%83%E7%A6%BB%E3%80%91/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P1373">题目</a></p>
<p>奇怪的递推（DP），居然没有自己做出来QAQ</p>
<a id="more"></a>
<hr />
<h2 id="初始思路">初始思路</h2>
<p>用<code>f[i][j][x][y]</code>表示取到 点<span class="math inline">\(i,j\)</span>时，小a有<span class="math inline">\(x\)</span>魔液，uim有<span class="math inline">\(y\)</span>魔液，的方案数</p>
<p>显然MLE，且复杂度不优秀，<span class="math inline">\(O(nmk^2)\)</span></p>
<h2 id="优化表示方式">优化表示方式</h2>
<p>答案要求两人差为零的方案数，所以只考虑两者魔液之差</p>
<p>用<code>f[i][j][x][p]</code>表示表示取到 点<span class="math inline">\(i,j\)</span>时，两人之差为<span class="math inline">\(x\)</span>，由<span class="math inline">\(p\)</span>（小a或uim）取最后一堆的方案数</p>
<h2 id="转移方程">转移方程</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 小a</span><br><span class="line">f[i][j][x][0] +&#x3D; f[i-1][j][x-a[i][j]][1]&#x2F;&#x2F; 上边</span><br><span class="line">f[i][j][x][0] +&#x3D; f[i][j-1][x-a[i][j]][1]&#x2F;&#x2F; 左边</span><br><span class="line">&#x2F;&#x2F; uim</span><br><span class="line">f[i][j][x][1] +&#x3D; f[i-1][j][x+a[i][j]][0]</span><br><span class="line">f[i][j][x][1] +&#x3D; f[i][j-1][x+a[i][j]][0]</span><br></pre></td></tr></table></figure>
<h2 id="细节">细节</h2>
<p>注意模的是<code>k+1</code>，所以我一开始<code>k++</code></p>
<p>因为只能由小a取第一堆，初始值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f[i][j][a[i][j]][0] &#x3D; 1</span><br></pre></td></tr></table></figure>
<p>只能由uim取最后一堆，答案为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ans +&#x3D; f[i][j][0][1]</span><br></pre></td></tr></table></figure>
<p>空间开到<code>f[805][805][20][2]</code>左右，不然容易MLE</p>
<h2 id="完整代码">完整代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BANANA &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; T k = <span class="number">1</span>; <span class="keyword">char</span> in = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(in)) &#123; <span class="keyword">if</span> (in == <span class="string">&#x27;-&#x27;</span>) k = <span class="number">-1</span>; in = getchar(); &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(in)) x = x * <span class="number">10</span> + in - <span class="string">&#x27;0&#x27;</span>, in = getchar();</span><br><span class="line">    x *= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">805</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="keyword">int</span> a[N][N], f[N][N][<span class="number">20</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mod</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x + k) % k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(m), read(k);</span><br><span class="line">    k++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            read(a[i][j]), a[i][j] %= k;</span><br><span class="line">            f[i][j][a[i][j]][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; k; ++x) &#123;</span><br><span class="line">                f[i][j][x][<span class="number">0</span>] = (f[i][j][x][<span class="number">0</span>] + f[i<span class="number">-1</span>][j][mod(x-a[i][j])][<span class="number">1</span>] + f[i][j<span class="number">-1</span>][mod(x-a[i][j])][<span class="number">1</span>]) % MOD;</span><br><span class="line">                f[i][j][x][<span class="number">1</span>] = (f[i][j][x][<span class="number">1</span>] + f[i<span class="number">-1</span>][j][mod(x+a[i][j])][<span class="number">0</span>] + f[i][j<span class="number">-1</span>][mod(x+a[i][j])][<span class="number">0</span>]) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            (ans += f[i][j][<span class="number">0</span>][<span class="number">1</span>]) %= MOD;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BANANA::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>递推DP</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P1967 【货车运输】</title>
    <url>/2020/01/17/2020-01-17-%E9%A2%98%E8%A7%A3-P1967-%E3%80%90%E8%B4%A7%E8%BD%A6%E8%BF%90%E8%BE%93%E3%80%91/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P1967">题面</a></p>
<a id="more"></a>
<h2 id="思路">思路</h2>
<p>因为一些容量小的边不会被经过，考虑先建出<strong>最大生成树</strong></p>
<p>题目转化成在树上求两点间路径最小权值</p>
<p>利用<span class="math inline">\(LCA\)</span>求最短路径</p>
<p>另外搞一个倍增数组<span class="math inline">\(minn[x][i]\)</span>，表示x到第<span class="math inline">\(2^i\)</span>个祖先之间路径最小权值</p>
<p>转移：<code>minn[x][i] = min(minn[x][i-1], minn[fa[x][i-1]][i-1]);</code></p>
<hr />
<h2 id="code">code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BANANA &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; T k = <span class="number">1</span>; <span class="keyword">char</span> in = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(in)) &#123; <span class="keyword">if</span> (in == <span class="string">&#x27;-&#x27;</span>) k = <span class="number">-1</span>; in = getchar(); &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(in)) x = x * <span class="number">10</span> + in - <span class="string">&#x27;0&#x27;</span>, in = getchar();</span><br><span class="line">    x *= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">5e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge_</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Edge_ &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> w &gt; t.w;<span class="comment">// 从大到小排</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> nxt, to, w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q, cnt;</span><br><span class="line"><span class="keyword">int</span> head[N], col[N], fa[N][<span class="number">30</span>], <span class="built_in">log</span>[N], deep[N], minn[N][<span class="number">30</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line">Edge_ e_[M];</span><br><span class="line">Edge e[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[++cnt] = (Edge)&#123;head[u], v, w&#125;, head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = a;</span><br><span class="line">    a = b, b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集找father</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> col[x] == x ? x : col[x] = find(col[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大生成树</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        col[i] = i;</span><br><span class="line">    sort(e_+<span class="number">1</span>, e_+m+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="keyword">if</span> (find(e_[i].x) != find(e_[i].y)) &#123;</span><br><span class="line">            col[find(e_[i].x)] = e_[i].y;</span><br><span class="line">            add(e_[i].x, e_[i].y, e_[i].w), add(e_[i].y, e_[i].x, e_[i].w);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LCA预处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    vis[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">log</span>[deep[x]]; ++i)</span><br><span class="line">        fa[x][i] = fa[fa[x][i<span class="number">-1</span>]][i<span class="number">-1</span>], minn[x][i] = min(minn[fa[x][i<span class="number">-1</span>]][i<span class="number">-1</span>], minn[x][i<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x], y; i; i = e[i].nxt) &#123;</span><br><span class="line">        y = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (!vis[y]) &#123;</span><br><span class="line">            deep[y] = deep[x] + <span class="number">1</span>, fa[y][<span class="number">0</span>] = x, minn[y][<span class="number">0</span>] = e[i].w;</span><br><span class="line">            dfs(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (find(x) != find(y))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = INF;</span><br><span class="line">    <span class="keyword">if</span> (deep[x] &lt; deep[y])</span><br><span class="line">        swap(x, y);</span><br><span class="line">    <span class="keyword">while</span> (deep[x] &gt; deep[y]) &#123;</span><br><span class="line">        ans = min(ans, minn[x][<span class="built_in">log</span>[deep[x]-deep[y]]<span class="number">-1</span>]);</span><br><span class="line">        x = fa[x][<span class="built_in">log</span>[deep[x]-deep[y]]<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == y)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">log</span>[deep[x]]; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> (fa[x][i] != fa[y][i]) &#123;</span><br><span class="line">            ans = min(ans, min(minn[x][i], minn[y][i]));</span><br><span class="line">            x = fa[x][i], y = fa[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    ans = min(ans, min(minn[x][<span class="number">0</span>], minn[y][<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">return</span> ans;<span class="comment">// 返回路径上最小值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        read(e_[i].x), read(e_[i].y), read(e_[i].w);</span><br><span class="line"></span><br><span class="line">    Kruskal();</span><br><span class="line">    <span class="comment">// 递推log数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">log</span>[i] = <span class="built_in">log</span>[i<span class="number">-1</span>] + ((<span class="number">1</span> &lt;&lt; <span class="built_in">log</span>[i<span class="number">-1</span>]) == i);</span><br><span class="line">    <span class="comment">// 注意图不一定联通</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            deep[i] = <span class="number">1</span>;</span><br><span class="line">            fa[i][<span class="number">0</span>] = i;</span><br><span class="line">            minn[i][<span class="number">0</span>] = INF;</span><br><span class="line">            dfs(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    read(q);</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        read(x), read(y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, LCA(x, y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BANANA::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图论</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>LCA</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2279 【[HNOI2003]消防局的设立】</title>
    <url>/2020/01/17/2020-01-17-%E9%A2%98%E8%A7%A3-P2279-%E3%80%90HNOI2003%E6%B6%88%E9%98%B2%E5%B1%80%E7%9A%84%E8%AE%BE%E7%AB%8B%E3%80%91/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P2279">题目</a></p>
<p>第一道连状态都不会表示的<span class="math inline">\(dp\)</span></p>
<p>转移方程推到吐。。。</p>
<a id="more"></a>
<h2 id="状态表示">状态表示</h2>
<p>每一个点<span class="math inline">\(x\)</span>都有五个状态：</p>
<blockquote>
<p><code>f[x][0]</code>：覆盖到x的爷爷和x整棵子树（向上2层），最少个数</p>
</blockquote>
<blockquote>
<p><code>f[x][1]</code>：覆盖到x的父亲和x整棵子树（向上1层），最少个数</p>
</blockquote>
<blockquote>
<p><code>f[x][2]</code>：覆盖x整棵子树（向上0层），最少个数</p>
</blockquote>
<blockquote>
<p><code>f[x][3]</code>：覆盖所有x的儿子及其子树（向上-1层），最少个数</p>
</blockquote>
<blockquote>
<p><code>f[x][4]</code>：覆盖所有x的孙子及其子树（向上-2层），最少个数</p>
</blockquote>
<hr />
<ul>
<li><code>f[x][0]</code>：覆盖到x的爷爷和x整棵子树（向上2层），最少个数</li>
</ul>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/83nui5b4.png" /></p>
<ul>
<li><code>f[x][1]</code>：覆盖到x的父亲和x整棵子树（向上1层），最少个数</li>
</ul>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/6lhd8icf.png" /></p>
<ul>
<li><code>f[x][2]</code>：覆盖x整棵子树（向上0层），最少个数</li>
</ul>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/sxrk7lgi.png" /></p>
<ul>
<li><code>f[x][3]</code>：覆盖所有x的儿子及其子树（向上-1层），最少个数</li>
</ul>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/zdnxa2p1.png" /></p>
<ul>
<li><code>f[x][4]</code>：覆盖所有x的孙子及其子树（向上-2层），最少个数</li>
</ul>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/djsdjzke.png" /></p>
<h2 id="转移方程">转移方程</h2>
<p>y，z是x的儿子</p>
<p><span class="math inline">\(f[x][0] = 1 + \sum{f[y][4]}\)</span> <span class="math inline">\(f[x][1] = min(f[y][0] + \sum{(y!=z)f[z][3]})\)</span> <span class="math inline">\(f[x][2] = min(f[y][1] + \sum{(y!=z)f[z][2]})\)</span> <span class="math inline">\(f[x][3] = \sum{f[y][2]}\)</span> <span class="math inline">\(f[x][4] = \sum{f[y][3]}\)</span></p>
<p>显然<code>f[x][i]</code>一定包含<code>f[x][i+1]</code></p>
<p>易得<code>f[x][0] &gt;= f[x][1] &gt;= f[x][2] &gt;= f[x][3] &gt;= f[x][4]</code></p>
<p>所以转移时保证满足条件的前提下尽量选最低层的状态</p>
<hr />
<ul>
<li><span class="math inline">\(f[x][0] = 1 + \sum{f[y][4]}\)</span></li>
</ul>
<p>要覆盖到爷爷的话必须选x，并贪心地选y的第五种状态</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ogxjicaf.png" /></p>
<ul>
<li><span class="math inline">\(f[x][1] = min(f[y][0] + \sum{(y!=z)f[z][3]})\)</span></li>
</ul>
<p>x的儿子中有一个一定覆盖的爷爷，同时覆盖到兄弟（因为y一定是选了），其他的儿子只需要覆盖的自己的儿子即可</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/86y5d7hh.png" /></p>
<ul>
<li><span class="math inline">\(f[x][2] = min(f[y][1] + \sum{(y!=z)f[z][2]})\)</span></li>
</ul>
<p>同理，有一个儿子覆盖到父亲，但无法覆盖到y的兄弟，所以其他儿子要覆盖到自己</p>
<ul>
<li><span class="math inline">\(f[x][3] = \sum{f[y][2]}\)</span></li>
</ul>
<p>让每个儿子覆盖到自己即可</p>
<ul>
<li><span class="math inline">\(f[x][4] = \sum{f[y][3]}\)</span></li>
</ul>
<p>让每个儿子覆盖到自己的儿子</p>
<hr />
<p>注意：</p>
<p><strong><code>f[x][i]</code>包含<code>f[x][i+1]</code>，若<code>f[x][i]</code>比<code>f[x][i+1]</code>更优，<code>f[x][i+1]</code>应更新</strong></p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; T k = <span class="number">1</span>; <span class="keyword">char</span> in = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(in)) &#123; <span class="keyword">if</span> (in == <span class="string">&#x27;-&#x27;</span>) k = <span class="number">-1</span>; in = getchar(); &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(in)) x = x * <span class="number">10</span> + in - <span class="string">&#x27;0&#x27;</span>, in = getchar();</span><br><span class="line">    x *= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> nxt, to;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, cnt;</span><br><span class="line"><span class="keyword">int</span> head[N], f[N][<span class="number">5</span>];</span><br><span class="line">Edge e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[++cnt] = (Edge)&#123;head[u], v&#125;, head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录f[y][2], f[y][3]的总和，后面容斥即可</span></span><br><span class="line">    <span class="keyword">int</span> sum2 = <span class="number">0</span>, sum3 = <span class="number">0</span>, y, tot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != fa) &#123;</span><br><span class="line">            y = e[i].to;</span><br><span class="line">            dfs(y, x);</span><br><span class="line">            sum2 += f[y][<span class="number">2</span>], sum3 += f[y][<span class="number">3</span>];</span><br><span class="line">            tot++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 没有儿子特判</span></span><br><span class="line">    <span class="keyword">if</span> (!tot) &#123;</span><br><span class="line">        f[x][<span class="number">0</span>] = f[x][<span class="number">1</span>] = f[x][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[x][<span class="number">0</span>] = <span class="number">1</span>, f[x][<span class="number">1</span>] = f[x][<span class="number">2</span>] = N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != fa) &#123;</span><br><span class="line">            y = e[i].to;</span><br><span class="line">            f[x][<span class="number">0</span>] += f[y][<span class="number">4</span>];</span><br><span class="line">            f[x][<span class="number">1</span>] = min(f[x][<span class="number">1</span>], f[y][<span class="number">0</span>] + sum3 - f[y][<span class="number">3</span>]);</span><br><span class="line">            f[x][<span class="number">2</span>] = min(f[x][<span class="number">2</span>], f[y][<span class="number">1</span>] + sum2 - f[y][<span class="number">2</span>]);</span><br><span class="line">            f[x][<span class="number">3</span>] += f[y][<span class="number">2</span>];</span><br><span class="line">            f[x][<span class="number">4</span>] += f[y][<span class="number">3</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 检查最小值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">        f[x][i] = min(f[x][i], f[x][i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, x; i &lt;= n; ++i)</span><br><span class="line">        read(x), add(x, i), add(i, x);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P5662 【纪念品】</title>
    <url>/2020/01/17/2020-01-17-%E9%A2%98%E8%A7%A3-P5662-%E3%80%90%E7%BA%AA%E5%BF%B5%E5%93%81%E3%80%91/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P5662">题面</a></p>
<p>最后一次考pj了，居然炸了</p>
<p>s组day1把我心态考崩了，下午j组写了200分就开始颓废，<del>估计要被学弟们嘲笑了QAQ</del></p>
<a id="more"></a>
<hr />
<p>好了，开始<em>事后诸葛</em></p>
<h2 id="思路">思路</h2>
<p>n个物品，t天价格，数据范围不大，但是直接推转移方程不太可行</p>
<p>想到<strong>背包</strong>（考场上脑子里“背包”两字都没出现）</p>
<hr />
<p>先考虑<span class="math inline">\(n=1\)</span>的情况：</p>
<p>可以把t天的价格中，相邻两天的价格差当作一个物品（<span class="math inline">\(price=a[i],value=a[i+1]-a[i]\)</span>）</p>
<p><code>f[i]</code>表示花费i金币的最大收益（不包括本金）</p>
<p>可以自己手玩一下，同时选物品<span class="math inline">\(i\)</span>和<span class="math inline">\(i+1\)</span>收益就是<span class="math inline">\(a[i+2]-a[i]\)</span>，可以连续起来</p>
<p>每一天可以买卖多个，所以是完全背包</p>
<p>注意每天结束之后更新m，毕竟收益也可以用</p>
<hr />
<p>现在拓展到多个纪念品：</p>
<p>每一天都有n个物品，每个物品的价格还是本身，收益是下一天的减这一天的价格</p>
<p>每一天把n个物品做完全背包，之后更新m</p>
<p>最后得到的m就是答案</p>
<p>坑点是每天背包之前清空f数组</p>
<hr />
<h2 id="code">code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n, m;</span><br><span class="line"><span class="keyword">int</span> a[N][N], f[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(t), read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            read(a[i][j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = a[i][j]; k &lt;= m; ++k)</span><br><span class="line">                f[k] = max(f[k], f[k - a[i][j]] + a[i+<span class="number">1</span>][j] - a[i][j]);</span><br><span class="line">        m = max(m, f[m] + m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<p>话说今年pj比去年水的多，比tg良心</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2467 [SDOI2010]地精部落</title>
    <url>/2020/01/19/2020-01-19-%E9%A2%98%E8%A7%A3-P2467-SDOI2010%E5%9C%B0%E7%B2%BE%E9%83%A8%E8%90%BD/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.luogu.com.cn/problem/P2467">题面</a></p>
<p>求长度 <span class="math inline">\(n\)</span> 的交错序列的方案数。</p>
</blockquote>
<a id="more"></a>
<h2 id="思路">思路</h2>
<p>长度为 <span class="math inline">\(i\)</span> 的序列对于长度为 <span class="math inline">\(i-1\)</span> 的序列来说多了<strong>最大值</strong> <span class="math inline">\(i\)</span> ，所有我们可以枚举这个最大值的位置</p>
<p>为保证是交错序列，那么最大值位置的前驱和后继都必须是“山谷”</p>
<p>从最大值的位置 <span class="math inline">\(j\)</span> 劈开，问题该状态便可以转化成两个子状态：</p>
<p>长度为 <span class="math inline">\(j\)</span> 的结尾下降的序列方案数和长度为 <span class="math inline">\(i-1-j\)</span> 的开头上升的序列方案数</p>
<p>结尾下降和开头上升本质相同</p>
<p>最后方案数要乘上组合 <span class="math inline">\(C_{i-1}^j\)</span> （从 1 至 <span class="math inline">\(i-1\)</span> 中选出 <span class="math inline">\(j\)</span> 个数组成最大值前面的序列，离散化后方案数相同）</p>
<h2 id="状态表示-转移方程">状态表示 &amp; 转移方程</h2>
<p>设 <code>f[i]</code>表示长度为 <span class="math inline">\(i\)</span> 的交错序列的方案数</p>
<p>显然，开头上升和开头下降的方案一样多，开头上升的方案数就是总方案数的一半</p>
<p><span class="math display">\[
\large f[i] = \sum_{j=0}^{i-1}\frac{f[j]}{2}\cdot\frac{f[i-1-j]}{2}\cdot C_{i-1}^{j}
\]</span></p>
<h2 id="细节">细节</h2>
<h3 id="边界">边界</h3>
<p><code>f[1] = 1</code>，除以2不就。。。</p>
<p>其实长度为1的序列可以看成两种情况（“山谷”或“山峰”）</p>
<p>至于<code>f[0]</code>，当序列最大值置于最左侧（<span class="math inline">\(j=0\)</span>）时方案数不能乘0啊</p>
<p>所以<code>f[0] = f[1] = 2</code></p>
<h3 id="取模">取模</h3>
<p>问题来了，<span class="math inline">\(p\)</span> 不为质数，不能求2的逆元，且 <span class="math inline">\(a=b\ (mod\ p)\)</span> 不等价于 <span class="math inline">\(\frac{a}{2}=\frac{b}{2}\ (mod\ p)\)</span></p>
<p>怎样除以 2 ？</p>
<p>因为 <span class="math inline">\(x\ mod\ p=(x\ mod\ 2p)\ mod\ p\)</span> （ <span class="math inline">\(x\)</span> 为 <span class="math inline">\(mod\ 2p\)</span> 意义下的偶数）</p>
<p>所以 <span class="math inline">\(\frac{x}{2}\ mod\ p=(\frac{x\ mod\ 2p}{2})\ mod\ p\)</span></p>
<p>过程中模 <span class="math inline">\(2p\)</span> 的意义下随便除以2，最后再模 <span class="math inline">\(p\)</span> 输出即可</p>
<h3 id="空间">空间</h3>
<p><del>似乎、听说、大概</del>递推组合数的数组空间开不下，滚呗</p>
<h2 id="code">code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">read(n), read(p);</span><br><span class="line">c[<span class="number">0</span>][<span class="number">0</span>] = c[<span class="number">1</span>][<span class="number">0</span>] = c[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">ll p2 = p * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">        c[i&amp;<span class="number">1</span>][j] = (c[i&amp;<span class="number">1</span>^<span class="number">1</span>][j] + c[i&amp;<span class="number">1</span>^<span class="number">1</span>][j<span class="number">-1</span>]) % p2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i - <span class="number">1</span>; ++j)</span><br><span class="line">        f[i] = (<span class="number">1l</span>l * c[i&amp;<span class="number">1</span>^<span class="number">1</span>][j] * f[j] / <span class="number">2</span> % p2 * f[i<span class="number">-1</span>-j] / <span class="number">2</span> + f[i]) % p2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, f[n] % p);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>递推DP</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 K-D Tree</title>
    <url>/2020/01/20/2020-01-20-%E6%9D%BF%E5%AD%90-K-D-Tree/</url>
    <content><![CDATA[<p>用于处理高维空间组织点</p>
<p>大概就是在某个维度下从坐标中位数二分，最后形成一棵二叉树</p>
<a id="more"></a>
<p>插入删除会导致树不平衡，需要类似替罪羊树的拍扁重建</p>
<p>这里先放个 2-D 的吧，针对<a href="https://www.luogu.com.cn/problem/P4169">模板题P4169</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Alph = <span class="number">0.75</span>;<span class="comment">// 平衡因子</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维下的坐标及树节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pos</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> minx[<span class="number">2</span>], maxx[<span class="number">2</span>], ls, rs, sz;<span class="comment">// minx，maxx存坐标范围</span></span><br><span class="line">    Pos p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, ans, root, cnt, nd;<span class="comment">// nd为此时维度</span></span><br><span class="line">Pos a[N];</span><br><span class="line">Node tr[N];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; trash;<span class="comment">// 垃圾回收</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照某个维度排序用cmp</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(Pos A, Pos B) &#123;</span><br><span class="line">    <span class="keyword">return</span> A.x[nd] &lt; B.x[nd];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建节点</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">new_node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">if</span> (trash.empty())</span><br><span class="line">        x = ++cnt;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x = trash.front(), trash.pop();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新信息</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ls = tr[x].ls, rs = tr[x].rs;</span><br><span class="line">    <span class="comment">// 范围</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        tr[x].minx[i] = tr[x].maxx[i] = tr[x].p.x[i];</span><br><span class="line">        <span class="keyword">if</span> (ls)</span><br><span class="line">            tr[x].minx[i] = min(tr[x].minx[i], tr[ls].minx[i]), tr[x].maxx[i] = max(tr[x].maxx[i], tr[ls].maxx[i]);</span><br><span class="line">        <span class="keyword">if</span> (rs)</span><br><span class="line">            tr[x].minx[i] = min(tr[x].minx[i], tr[rs].minx[i]), tr[x].maxx[i] = max(tr[x].maxx[i], tr[rs].maxx[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    tr[x].sz = tr[ls].sz + tr[rs].sz + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建树（包括重建）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> x = new_node(), mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    nd = d, nth_element(a+l, a+mid, a+r+<span class="number">1</span>), tr[x].p = a[mid];<span class="comment">// 找中位数</span></span><br><span class="line">    tr[x].ls = build(l, mid<span class="number">-1</span>, d^<span class="number">1</span>), tr[x].rs = build(mid+<span class="number">1</span>, r, d^<span class="number">1</span>);</span><br><span class="line">    push_up(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拍扁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pia</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[x].ls)</span><br><span class="line">        pia(tr[x].ls, num);</span><br><span class="line">    a[num+tr[tr[x].ls].sz+<span class="number">1</span>] = tr[x].p, trash.push(x);<span class="comment">// 把点放入a数组便于建树</span></span><br><span class="line">    <span class="keyword">if</span> (tr[x].rs)</span><br><span class="line">        pia(tr[x].rs, num + tr[tr[x].ls].sz + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查平衡</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Alph * tr[x].sz &lt; tr[tr[x].ls].sz || Alph * tr[x].sz &lt; tr[tr[x].rs].sz)</span><br><span class="line">        pia(x, <span class="number">0</span>), x = build(<span class="number">1</span>, tr[x].sz, d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Pos tp, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) &#123;</span><br><span class="line">        x = new_node(), tr[x].p = tp, tr[x].ls = tr[x].rs = <span class="number">0</span>, push_up(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tp.x[d] &lt;= tr[x].p.x[d])</span><br><span class="line">        insert(tp, tr[x].ls, d^<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        insert(tp, tr[x].rs, d^<span class="number">1</span>);</span><br><span class="line">    push_up(x), check(x, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺便放一下 K-D Tree 在该题的运用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求曼哈顿距离</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dist</span><span class="params">(Pos A, Pos B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(A.x[<span class="number">0</span>] - B.x[<span class="number">0</span>]) + <span class="built_in">abs</span>(A.x[<span class="number">1</span>] - B.x[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求点到矩形（K-D Tree上一个子树）的曼哈顿距离</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getdis</span><span class="params">(Pos tp, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; ++i)</span><br><span class="line">        sum += max(<span class="number">0</span>, tp.x[i] - tr[x].maxx[i]) + max(<span class="number">0</span>, tr[x].minx[i] - tp.x[i]);<span class="comment">// 不理解就手玩一下</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(Pos tp, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ans = min(ans, dist(tp, tr[x].p));</span><br><span class="line">    <span class="keyword">int</span> dl = INF, dr = INF;</span><br><span class="line">    <span class="keyword">if</span> (tr[x].ls) </span><br><span class="line">        dl = getdis(tp, tr[x].ls);</span><br><span class="line">    <span class="keyword">if</span> (tr[x].rs)</span><br><span class="line">        dr = getdis(tp, tr[x].rs);</span><br><span class="line">    <span class="comment">// 爆搜，先搜最优的</span></span><br><span class="line">    <span class="keyword">if</span> (dl &lt; dr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dl &lt; ans)</span><br><span class="line">            query(tp, tr[x].ls);</span><br><span class="line">        <span class="keyword">if</span> (dr &lt; ans)</span><br><span class="line">            query(tp, tr[x].rs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dr &lt; ans)</span><br><span class="line">            query(tp, tr[x].rs);</span><br><span class="line">        <span class="keyword">if</span> (dl &lt; ans)</span><br><span class="line">            query(tp, tr[x].ls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// query</span></span><br><span class="line">ans = INF, query(tp, root), <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br></pre></td></tr></table></figure>
<p>我tcl，只会模板题</p>
]]></content>
      <categories>
        <category>总结</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>K-DTree</tag>
      </tags>
  </entry>
  <entry>
    <title>总结 多项式四则运算</title>
    <url>/2020/01/24/2020-01-24-%E6%80%BB%E7%BB%93-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>前置知识：FFT/NTT</p>
<p>见<a href="https://renamoe.github.io/2020/01/17/2020-01-17-板子-FFTNTT/">板子 FFT/NTT</a></p>
<a id="more"></a>
<h2 id="多项式加减">多项式加减</h2>
<p>在系数表示法下直接逐位加减</p>
<h2 id="多项式乘法">多项式乘法</h2>
<p>两式先通过 DFT（FFT/NTT）化为点值表示法，逐位相乘，再 IDFT 回来</p>
<p>这里放个封装的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y, <span class="keyword">int</span> lim)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(X, <span class="number">0</span>, <span class="keyword">sizeof</span> X), <span class="built_in">memset</span>(Y, <span class="number">0</span>, <span class="keyword">sizeof</span> Y);<span class="comment">// 复制一份</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (lim &gt;&gt; <span class="number">1</span>); ++i)</span><br><span class="line">        X[i] = x[i], Y[i] = y[i];</span><br><span class="line">    NTT(X, lim, <span class="number">1</span>), NTT(Y, lim, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">        X[i] = <span class="number">1l</span>l * X[i] * Y[i] % MOD;</span><br><span class="line">    NTT(X, lim, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">        x[i] = X[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多项式求逆">多项式求逆</h2>
<p>引用了 <a href="https://www.luogu.com.cn/user/37834">autoint</a> 的 <a href="https://www.luogu.com.cn/blog/autoint/solution-p4238">这篇博客</a> <span class="math display">\[
A\times B\equiv 1\quad (mod\ x^n)\\
A\times B&#39;\equiv 1\quad (mod\ x^{\frac{n}{2}})\\
A\times (B-B&#39;)\equiv 0\quad (mod\ x^{\frac{n}{2}})\\
B-B&#39;\equiv 0\quad (mod\ x^{\frac{n}{2}})\\
(B-B&#39;)^2\equiv 0\quad(mod\ x^n)\\
A\times(B^2-2BB&#39;+B&#39;^2)\equiv 0\quad(mod\ x^n)\\
B-2B&#39;+AB&#39;^2\equiv 0\quad (mod\ x^n)\\
B\equiv 2B&#39;-AB&#39;^2\quad (mod\ x^n)
\]</span> 据此可以倍增（可以把 B 数组滚动）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">inv</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> y[<span class="number">2</span>][N], <span class="keyword">int</span> &amp;cur, <span class="keyword">int</span> lim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> base = <span class="number">1</span>, now = <span class="number">2</span>, len = <span class="number">1</span>;</span><br><span class="line">    cur = <span class="number">0</span>;</span><br><span class="line">    y[cur][<span class="number">0</span>] = power(x[<span class="number">0</span>], MOD - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span> (base &lt;= lim &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">        calc_rev(now, len);</span><br><span class="line">        cur ^= <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(y[cur], <span class="number">0</span>, <span class="keyword">sizeof</span> y[cur]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; base; ++i)</span><br><span class="line">            y[cur][i] = (y[cur^<span class="number">1</span>][i] &lt;&lt; <span class="number">1</span>) % MOD;</span><br><span class="line">        mul(y[cur^<span class="number">1</span>], y[cur^<span class="number">1</span>], now);</span><br><span class="line">        mul(y[cur^<span class="number">1</span>], x, now);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; base; ++i)</span><br><span class="line">            y[cur][i] = plus_mod(y[cur][i], MOD - y[cur^<span class="number">1</span>][i]);</span><br><span class="line">        base &lt;&lt;= <span class="number">1</span>, now &lt;&lt;= <span class="number">1</span>, len++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<p>咕咕咕。。。</p>
]]></content>
      <categories>
        <category>总结</category>
        <category>Math</category>
      </categories>
      <tags>
        <tag>FFT/NTT</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 FWT</title>
    <url>/2020/01/29/2020-01-29-%E6%9D%BF%E5%AD%90-FWT/</url>
    <content><![CDATA[<p>快速沃尔什变换，用于处理 <span class="math inline">\(C_k=\sum_{i\otimes j=k}A_i*B_j\)</span> （<span class="math inline">\(\otimes\)</span> 是集合运算符）几何卷积运算</p>
<p>对于 <span class="math inline">\(A\)</span> 求出 <span class="math inline">\(fwt[A]\)</span> ，使得 <span class="math inline">\(fwt[C]=fwt[A]*fwt[B]\)</span> ，于是就 <span class="math inline">\(O(n)\)</span> 了</p>
<a id="more"></a>
<p>我纯靠感性理解，更不会讲QAQ，这里只贴板子</p>
<p>几篇有帮助的博客：</p>
<ul>
<li><p><a href="https://www.cnblogs.com/ACMLCZH/p/8022502.html">ACMLCZH的blog</a></p></li>
<li><p><a href="https://www.luogu.com.cn/blog/xht37/solution-p4717">xht37的blog</a></p></li>
</ul>
<h2 id="or-或卷积"><span class="math inline">\(or\)</span> 或卷积</h2>
<p><span class="math inline">\(FWT\)</span>： <span class="math display">\[
fwt[a]=(fwt[a_0],\ fwt[a_0]+fwt[a_1])
\]</span> <span class="math inline">\(IFWT\)</span>：</p>
<p><span class="math display">\[
a=(a_0,\ a_0-a_1)
\]</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FWT_or</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> opt = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt;&lt; <span class="number">1</span> &lt;= n; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += mid &lt;&lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; ++j)</span><br><span class="line">                f[i+mid+j] = ((LL)f[i+j] * opt + f[i+mid+j] + MOD) % MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="and-与卷积"><span class="math inline">\(and\)</span> 与卷积</h2>
<p>非常相似呢，<del>只管粘过来一改就好</del></p>
<p><span class="math inline">\(FWT\)</span>： <span class="math display">\[
fwt[a]=(fwt[a_0]+fwt[a_1],\ fwt[a_1])
\]</span> <span class="math inline">\(IFWT\)</span>：</p>
<p><span class="math display">\[
a=(a_0-a_1,\ a_1)
\]</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FWT_and</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> opt = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt;&lt; <span class="number">1</span> &lt;= n; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += mid &lt;&lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; ++j)</span><br><span class="line">                f[i+j] = ((LL)f[i+j] + f[i+mid+j] * opt + MOD) % MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="xor-异或卷积"><span class="math inline">\(xor\)</span> 异或卷积</h2>
<p>最恶心的</p>
<p><span class="math inline">\(FWT\)</span>： <span class="math display">\[
fwt[a]=(fwt[a_0]+fwt[a_1],\ fwt[a_0]-fwt[a_1])
\]</span> <span class="math inline">\(IFWT\)</span>：</p>
<p><span class="math display">\[
a=(\frac{a_0+a_1}{2},\ \frac{a_0-a_1}{2})
\]</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FWT_xor</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> opt = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt;&lt; <span class="number">1</span> &lt;= n; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += mid &lt;&lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> fx = f[i+j], fy = f[i+mid+j];</span><br><span class="line">                f[i+j] = (LL)opt * (fx + fy) % MOD;</span><br><span class="line">                f[i+mid+j] = (LL)opt * (fx - fy + MOD) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（<span class="math inline">\(IFWT\)</span> 时，opt 应为 <span class="math inline">\(2^{-1}\)</span>）</p>
]]></content>
      <categories>
        <category>总结</category>
        <category>Math</category>
      </categories>
      <tags>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title>总结 BSGS</title>
    <url>/2020/02/06/2020-02-06-%E6%80%BB%E7%BB%93-BSGS/</url>
    <content><![CDATA[<p>求解关于 x 的 <span class="math inline">\(a^x\equiv b\pmod p\)</span> 同余方程的算法。</p>
<a id="more"></a>
<h2 id="用途">用途</h2>
<p>用于求这样的问题：</p>
<blockquote>
<p>给出 <span class="math inline">\(a, b, p\)</span> <span class="math display">\[
a^x\equiv b\pmod p
\]</span> 求 <span class="math inline">\(x\)</span> 的最小非负整数解</p>
</blockquote>
<p><a href="https://www.luogu.com.cn/problem/P2485">例题 Luogu P2485</a></p>
<h2 id="思想">思想</h2>
<p>先把 <span class="math inline">\(x\)</span> 拆分成 <span class="math inline">\(i*t-j\)</span> 的形式（<span class="math inline">\(t=\lceil\sqrt{p}\rceil\)</span>） <span class="math display">\[
a^{i*t-j}\equiv b\pmod p\\
a^{i*t}\equiv b*a^j\pmod p
\]</span> 枚举 <span class="math inline">\(j\in [0,t]\)</span> ，将 <span class="math inline">\(b*a^j\)</span> 放进哈希表（我这么懒肯定用 <span class="math inline">\(map\)</span> 水）</p>
<p>再枚举 <span class="math inline">\(i\in [0,t]\)</span> ，从哈希表中查找 <span class="math inline">\(a^{i\ast t}\)</span> ，找到即答案为 <span class="math inline">\(i\ast t-j\)</span></p>
<p>枚举 <span class="math inline">\(i,j\)</span> 都是 <span class="math inline">\(O(\sqrt{p})\)</span> 的</p>
<p><del>是不是很 easy</del></p>
<h2 id="code">code</h2>
<p>这里只好放 P2485 的代码了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;LL, LL&gt; m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">BSGS</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    m.clear();</span><br><span class="line">    b %= p;</span><br><span class="line">    <span class="keyword">if</span> (a % p == <span class="number">0</span>) &#123;<span class="comment">// 恶心的特判</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL t = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(p));</span><br><span class="line">    <span class="keyword">for</span> (LL i = <span class="number">0</span>, bn = b; i &lt;= t; ++i)</span><br><span class="line">        m[bn] = i, bn = bn * a % p;</span><br><span class="line">    a = power(a, t);</span><br><span class="line">    <span class="keyword">for</span> (LL i = <span class="number">0</span>, an = <span class="number">1</span>, j; i &lt;= t; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m.count(an)) &#123;</span><br><span class="line">            j = m[an];</span><br><span class="line">            <span class="keyword">if</span> (i * t - j &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> i * t - j;</span><br><span class="line">        &#125;</span><br><span class="line">        an = an * a % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<p>对于 p 不为质数的情况，我们需要 <a href="https://renamoe.gitee.io/2020/08/15/2020-08-15-总结-exBSGS/">exBSGS 算法</a> 求解。</p>
]]></content>
      <categories>
        <category>总结</category>
        <category>Math</category>
      </categories>
      <tags>
        <tag>BSGS</tag>
      </tags>
  </entry>
  <entry>
    <title>总结 OI中一些数学定理</title>
    <url>/2020/10/06/2020-02-06-%E6%80%BB%E7%BB%93-OI%E4%B8%AD%E4%B8%80%E4%BA%9B%E6%95%B0%E5%AD%A6%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p>这里放一些数学公式定理，防止健忘</p>
<a id="more"></a>
<h2 id="matrix-tree-定理">Matrix Tree 定理</h2>
<p>定义一个图 <span class="math inline">\(G\)</span> 的 <span class="math inline">\(Kirchhoff\)</span> 矩阵 <span class="math inline">\(C=\text{度数矩阵}-\text{邻接矩阵}\)</span> <span class="math display">\[
C_{i,j}=
\begin{cases}
    degree_i&amp; (i=j)\\
    -1&amp; (i\not=j\ and\ (i,j)\in G(E))\\
    0&amp; (i\not=j\ and\ (i,j)\notin G(E))
\end{cases}
\]</span> 将矩阵 <span class="math inline">\(C\)</span> 去掉任意一行和一列，该矩阵的行列式即图 <span class="math inline">\(G\)</span> 的 生成树个数</p>
<h2 id="概率相关">概率相关</h2>
<p><span class="math inline">\(P(A)\)</span> ： <span class="math inline">\(A\)</span> 事件发生的概率</p>
<p><span class="math inline">\(E(X)\)</span>：随机变量 <span class="math inline">\(X\)</span> 的期望值，<span class="math inline">\(E(X)=\sum P(X=i)\times i\)</span></p>
<p><span class="math inline">\(P(A|B)\)</span>：<span class="math inline">\(A\)</span> 在 <span class="math inline">\(B\)</span> 发生的条件下发生的概率，<span class="math inline">\(P(A|B)=\frac{P(AB)}{P(B)}\)</span></p>
<p>全概率公式：<span class="math inline">\(P(B)=\sum_{i=1}^n{P(A_i)P(B|A_i)}\)</span></p>
<p>贝叶斯公式：<span class="math inline">\(P(A_i|B)=\frac{P(B|A_i)P(A_i)}{\sum_{j=1}^n{P(B|A_j)P(A_j)} }\)</span> （不会，不知道有没有用）</p>
<p>期望的性质：</p>
<p><span class="math inline">\(E(X+Y)=E(X)+E(Y)\)</span></p>
<p><span class="math inline">\(E(aX+b)=aE(X)+b\)</span></p>
<p><span class="math inline">\(E(XY)=E(X)+E(Y)\)</span> （ <span class="math inline">\(x,y\)</span> 相互独立）</p>
<h2 id="辛普森积分">辛普森积分</h2>
<p><span class="math display">\[
\frac{b-a}{6}[f(a)+4f(\frac{a+b}{2})+f(b)]
\]</span></p>
<p>自适应辛普森，分成左右分别套辛普森法则，不断拟合：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">simpson</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> (f(l) + <span class="number">4</span> * f(mid) + f(r)) * (r - l) / <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r, <span class="keyword">double</span> last, <span class="keyword">double</span> eps)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">double</span> ln = simpson(l, mid), rn = simpson(mid, r);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(ln + rn - last) &lt;= eps)</span><br><span class="line">    <span class="keyword">return</span> ln + rn + (ln + rn - last);</span><br><span class="line">    <span class="keyword">return</span> solve(l, mid, ln, eps/<span class="number">2</span>) + solve(mid, r, rn, eps/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>## 模性质</p>
<p>模意义下加、减、乘随便做，除要转换成逆元</p>
<p><span class="math inline">\(a\equiv b\pmod p\nRightarrow \frac{a}{2}\equiv \frac{b}{2}\pmod p\)</span></p>
<h2 id="裴蜀定理">裴蜀定理</h2>
<p>对于不定方程：<span class="math inline">\(ax+by=c\)</span></p>
<p>有（整数）解的充要条件为 <span class="math inline">\(\gcd⁡(a,b) | c\)</span></p>
<p>即一定存在 <span class="math inline">\(x,y\)</span> 满足 <span class="math inline">\(ax+by=\gcd(a,b)\)</span></p>
<p>推论：<span class="math inline">\(a,b\)</span> 互素等价于 <span class="math inline">\(ax+by=1\)</span> 有解</p>
<h2 id="欧几里得算法">欧几里得算法</h2>
<h3 id="gcd">gcd</h3>
<p><span class="math display">\[
\gcd(a,b)=\gcd(a-b,b)
\]</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非递归</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">        t = a, a = b, b = t % a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="exgcd">exgcd</h3>
<p><span class="math display">\[
ax+by=\gcd(a,b)\\
bx&#39;+(a\%b)y&#39;=\gcd(b,a\%b)
\]</span></p>
<p>将 <span class="math inline">\(a\ mod\ b\)</span> 替换为 <span class="math inline">\(a-\lfloor\frac{a}{b}\rfloor b\)</span> ，得 <span class="math display">\[
\begin{align}
bx&#39;+(a\%b)y&#39;&amp;=bx&#39;+(a-\lfloor\frac{a}{b}\rfloor b)y&#39;\\
&amp;=ay&#39;+b(x&#39;-\lfloor\frac{a}{b}\rfloor y&#39;)
\end{align}
\]</span> 则 <span class="math inline">\(x,y\)</span> 和 <span class="math inline">\(x&#39;,y&#39;\)</span> 的关系为 <span class="math display">\[
x=y&#39;,y=x&#39;-\lfloor\frac{a}{b}\rfloor y&#39;
\]</span> 当 <span class="math inline">\(b=0\)</span> 时，<span class="math inline">\(x&#39;=1\)</span> ，<span class="math inline">\(y\)</span> 可以为任何值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y, <span class="keyword">int</span> &amp;gcd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">    	x = <span class="number">1</span>, y = <span class="number">0</span>, gcd = a;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    exgcd(b, a%b, y, x, gcd);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求出的 x,y 为某一组解，x 通解为 <span class="math inline">\(x+k\times\frac{b}{\gcd(a,b)}\)</span>。</p>
<h2 id="整数唯一分解定理">整数唯一分解定理</h2>
<p>对于任意整数 <span class="math inline">\(N\ (N\ge2)\)</span> <span class="math display">\[
\large N=\prod_{i=1}^k{p_i^{r_i}}\quad (p_i\text{为质数},r_i\ge0)
\]</span></p>
<p><span class="math inline">\(N\)</span> 的正约数集合：<span class="math inline">\(\large\{\prod_{i=1}^k{p_i^{b_i}}\}\ (0\le b_i\le r_i)\)</span></p>
<p><span class="math inline">\(N\)</span> 的正约数个数：<span class="math inline">\(\large\prod_{i=1}^k{(r_i+1)}\)</span></p>
<p><span class="math inline">\(N\)</span> 的正约数和：<span class="math inline">\(\large\prod_{i=1}^k(\sum_{j=0}^{r_i}p_i^j)\)</span></p>
<h2 id="威尔逊定理">威尔逊定理</h2>
<p><span class="math inline">\(p\)</span> 是质数的充要条件为: <span class="math display">\[
(p-1)!\equiv -1\pmod p
\]</span></p>
<h2 id="费马小定理">费马小定理</h2>
<p><span class="math inline">\(p\)</span> 为质数，且 <span class="math inline">\(\gcd(a,p)=1\)</span> ，则： <span class="math display">\[
a^{p-1}\equiv 1\pmod p
\]</span> 故 <span class="math inline">\(a\)</span> 在模 <span class="math inline">\(p\)</span> 下的乘法逆元为 <span class="math inline">\(a^{p-2}\)</span></p>
<h3 id="线性预处理逆元">线性预处理逆元</h3>
<p>设 <span class="math inline">\(p=i*k+r(0\le r\le i)\)</span></p>
<p><span class="math display">\[
i*k+r\equiv 0\pmod p
\]</span></p>
<p>两边乘 <span class="math inline">\(i^{-1}r^{-1}\)</span></p>
<p><span class="math display">\[
k\times r^{-1}+i^{-1}\equiv 0 \pmod p
\\
i^{-1}\equiv -k\times r^{-1}\pmod p
\]</span></p>
<p>其中 <span class="math inline">\(r=p\%i,k=\lfloor\frac{p}{i}\rfloor\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    inv[i] = (p - p / i) * inv[p%i] % p;</span><br></pre></td></tr></table></figure>
<p>还有一种方法：</p>
<p>设 <span class="math inline">\(s_i=\prod_{j=1}^{i}a_i,invs_i=s_i^{-1}\)</span></p>
<p><span class="math inline">\(O(\log_2(mod))\)</span> 预处理 <span class="math inline">\(invs_n\)</span> ，则 <span class="math inline">\(invs_i=invs_{i+1}\times a_{i+1}\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    s[i] = s[i<span class="number">-1</span>] * a[i] % p;</span><br><span class="line">invs[n] = power(s[n], p<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i; --i)</span><br><span class="line">    invs[i] = invs[i+<span class="number">1</span>] * a[i+<span class="number">1</span>] % p;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    inv[i] = invs[i] * s[i<span class="number">-1</span>] % p;</span><br></pre></td></tr></table></figure>
<h2 id="欧拉函数">欧拉函数</h2>
<p><span class="math display">\[
\varphi(n)=\sum_{i=1}^n[\gcd(n, i)=1]
\]</span></p>
<p>若 <span class="math inline">\(p\)</span> 为素数，则 <span class="math inline">\(\varphi(p)=p-1\)</span></p>
<p>若 <span class="math inline">\(\gcd(a,b)=1\)</span>，则 <span class="math inline">\(\varphi(ab)=\varphi(a)\varphi(b)\)</span></p>
<p>基于素因数分解求 <span class="math inline">\(\varphi(n)\)</span> ，复杂度 <span class="math inline">\(O(\sqrt{n})\)</span> ：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">euler_phi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>); </span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>)</span><br><span class="line">                n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="number">1</span>) </span><br><span class="line">        res = res / n * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="欧拉定理">欧拉定理</h2>
<p><span class="math inline">\(a,p\)</span> 为互质的正整数 <span class="math display">\[
a^{\varphi(p)}\equiv 1\pmod p
\]</span></p>
<h3 id="扩展欧拉定理">扩展欧拉定理</h3>
<p>若 <span class="math inline">\(a,p\)</span> 不一定互质，且 <span class="math inline">\(x\ge \varphi(p)\)</span> <span class="math display">\[
a^x\equiv a^{x\%\varphi(p)+\varphi(p)}\pmod p
\]</span></p>
<h2 id="中国剩余定理">中国剩余定理</h2>
<h3 id="crt">crt</h3>
<p>对于一元线性同余方程组： <span class="math display">\[
\begin{cases}
    x\equiv a_1\pmod{m_1}\\
    x\equiv a_2\pmod{m_2}\\
    ……\\
    x\equiv a_n\pmod{m_n}
\end{cases}
\]</span> 其中 <span class="math inline">\(m_i\)</span> 两两互质</p>
<p>该方程组的通解为： <span class="math display">\[
M=\prod_{i=1}^nm_i\\
M_i=\frac{M}{m_i}\\
t_i=M_i^{-1}\pmod{m_i}\\
x\equiv \sum_{i=1}^n{a_it_iM_i\pmod M}
\]</span></p>
<h3 id="excrt">excrt</h3>
<p><a href="http://renamoe.gitee.io/2020/08/15/2020-08-15-%E6%9D%BF%E5%AD%90-CRT-exCRT/">见总结</a></p>
<h2 id="拉格朗日插值">拉格朗日插值</h2>
<p>对于一个给定 n 个点 <span class="math inline">\((x_i,y_i)\)</span> 的多项式，可以 <span class="math inline">\(O(n^2)\)</span> 算出该多项式在 <span class="math inline">\(x_k\)</span> 的取值 <span class="math display">\[
f(x_k)=\sum_{i=1}^n{y_i\prod_{i\not=j}\frac{x_k-x_j}{x_i-x_j}}
\]</span> 如果已知取值 <span class="math inline">\(x_1\)</span> 到 <span class="math inline">\(x_n\)</span> 是连续的话，可以预处理前缀积优化到 <span class="math inline">\(O(n\log n)\)</span>（逆元再线性处理就是 <span class="math inline">\(O(n)\)</span> ）</p>
<h2 id="莫比乌斯函数">莫比乌斯函数</h2>
<p><span class="math display">\[
\mu(n)=
\begin{cases}
    1&amp; (n=1)\\
    (-1)^k&amp; (n\text{无平方数因数},n=\prod_{i=1}^k{p_i})\\
    0&amp; (n\text{有大于1的平方数因数})
\end{cases}
\]</span></p>
<p><span class="math display">\[
\sum_{d\mid n}\mu(d)=
\begin{cases}
    1&amp; (n=1)\\
    0&amp; (n=0)
\end{cases}\\
\sum_{d\mid n}\frac{\mu(d)}{d}=\frac{\varphi(n)}{n}
\]</span></p>
<h2 id="一些积性函数">一些积性函数</h2>
<ul>
<li><span class="math inline">\(\varphi(n)\)</span>：欧拉函数</li>
<li><span class="math inline">\(\mu(n)\)</span>：莫比乌斯函数</li>
<li><span class="math inline">\(\gcd(n,k)\)</span>：（<span class="math inline">\(k\)</span> 固定时）最小公因数</li>
<li><span class="math inline">\(d(n)\)</span>：<span class="math inline">\(n\)</span> 的约数个数</li>
<li><span class="math inline">\(\sigma(n)\)</span>：<span class="math inline">\(n\)</span> 的约数和</li>
<li><span class="math inline">\(1(n)=1\)</span></li>
<li><span class="math inline">\(id(n)=n\)</span></li>
<li><span class="math inline">\(e(n)=\begin{cases}1&amp;(n=1) \\ 0 &amp;(n\not=1) \end{cases}\)</span></li>
</ul>
<h2 id="狄利克雷卷积">狄利克雷卷积</h2>
<p><span class="math display">\[
h=f\times g\\
h(n)=\sum_{i\mid n}{f(i)*g(\frac{n}{i})}
\]</span></p>
<p>两个数论函数的狄利克雷卷积结果仍是一个数论函数</p>
<p>两个积性函数的狄利克雷卷积仍是一个积性函数</p>
<p>狄利克雷卷积满足交换律、结合律</p>
<h2 id="二项式定理">二项式定理</h2>
<h2 id="lucas定理">Lucas定理</h2>
<hr />
<p>待补充……</p>
]]></content>
      <categories>
        <category>总结</category>
        <category>Math</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>总结 SAM</title>
    <url>/2020/02/13/2020-02-13-%E6%80%BB%E7%BB%93-SAM/</url>
    <content><![CDATA[<p><span class="math inline">\(SAM:\ Suffix\ Automaton\)</span> ，后缀自动机</p>
<p>难理解，但代码好写（当初敲完模板题没总结，现在忘光了QAQ）</p>
<p>总体上是 <strong>后缀 trie + parent tree</strong> ，构成一个可以表示所有子串的 DAG</p>
<a id="more"></a>
<p>福利：<a href="http://yeah.moe/p/a8e74947/">后缀自动机可视化</a></p>
<p>推荐博客：</p>
<ul>
<li><a href="https://www.luogu.com.cn/blog/Kesdiael3/hou-zhui-zi-dong-ji-yang-xie">KesdiaelKen 的博客</a>（我就是看这博客学会的）</li>
<li><a href="https://www.luogu.com.cn/blog/ShadowassIIXVIIIIV/solution-p3804">shadowice1984 的博客</a></li>
<li><a href="https://www.cnblogs.com/xzyxzy/p/9186759.html">xzyxzy 的博客</a></li>
</ul>
<p>这博客主要是我总结自己不好理解的地方，不是很全面</p>
<hr />
<blockquote>
<p>声明：本文中图片大部分为 BANANA 从他人博客<del>盗来的</del>借鉴的，一些语言表达借鉴于 <a href="https://www.luogu.com.cn/blog/Kesdiael3/hou-zhui-zi-dong-ji-yang-xie">KesdiaelKen 的博客</a> ，若有侵权请 <a href="mailto:true-banana@outlook.com">联系BANANA</a> 删除</p>
</blockquote>
<h2 id="思路">思路</h2>
<h3 id="前置">前置</h3>
<p>先了解几个概念：</p>
<p><strong>后缀 trie </strong>：把字符串的每一个后缀插入到 trie 树里</p>
<p>一个普通的后缀 trie ，有很大部分节点是可以压缩的</p>
<p><img src="https://true-banana.github.io/img/001.png" /></p>
<p><strong>endpos 集合</strong> ：一个子串在原串出现的位置（可能出现多次）的右端点集合</p>
<blockquote>
<p>比如一个串“banana”</p>
<p><span class="math inline">\(endpos(b)=\{1\},\ endpos(a)=\{2,4,6\}\)</span></p>
<p><span class="math inline">\(endpos(an)=\{3,5\},\ endpos(ana)=\{4,6\}\)</span></p>
</blockquote>
<p><strong>parent tree</strong> ：一个子串前面添加一个或几个字符，可以将他的 endpos 集合<strong>分割</strong>，endpos 集合之间便有了父子关系</p>
<p><img src="https://true-banana.github.io/img/002.png" /></p>
<p>parent tree 上每一个节点表示的 endpos 集合唯一地表示一个后缀集合</p>
<p><del>不好举例，自己手模吧</del></p>
<h3 id="构造">构造</h3>
<p><em>将后缀 trie 和 parent tree 结合起来便是 SAM 的 DAG</em></p>
<p><strong>那么一条路径表示原串的一个子串，一个节点 x 表示根节点到 x 路径形成的所有串的 endpos 集合</strong></p>
<p>SAM 常见的增量构造：将字符串从前到后一个一个字符插进去（离线构造窝不会）</p>
<p>先确定一些量：</p>
<ul>
<li><p><span class="math inline">\(fa[x]\)</span> ：x 节点表示的集合在 parent tree 上的父亲</p></li>
<li><p><span class="math inline">\(len[x]\)</span> ：x 节点表示的集合中<strong>最长</strong>的串的长度</p>
<p>如果设最短的串长为 <span class="math inline">\(minlen[x]\)</span> ，那么 <span class="math inline">\(len[fa[x]]+1=minlen[x]\)</span> ，即 parent tree 上的分割关系</p></li>
</ul>
<p>我们考虑从后面插入一个字符 c，会有什么变化：</p>
<ul>
<li>多出新串的后缀</li>
<li>新串后缀的 endpos 集合改变</li>
</ul>
<p>那么在 trie 的意义上要把旧串所有后缀的后面加上字符 c</p>
<p>在 SAM 上实现就是先新建节点 np</p>
<p>然后把最后一个节点 p、它在 parent tree 的父亲以及祖先的 c 儿子设为该节点（<strong>相当于压缩地遍历旧串的所有后缀</strong>）</p>
<p>并且 <span class="math inline">\(len[np]=len[p]+1\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> p = last, np = last = ++cnt;</span><br><span class="line">len[np] = len[p] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; !ch[p][c])</span><br><span class="line">    ch[p][c] = np, p = fa[p];</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p>如果这些祖先都没有 c 儿子，到达最高的祖先就是根节点</p>
<p>说明字符 c 是一个新字符，parent tree 上根节点多一个儿子：只有位置 c 的 endpos 集合</p></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!p) fa[np] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><p>那么如果有一个祖先 p 已经有了 c 儿子，设它为 q</p>
<p>说明旧串有子串的结尾是 c 字符，那么就要看这个 q 的 len 了</p>
<ul>
<li><p><span class="math inline">\(len[q]=len[p]+1\)</span></p>
<p>说明 q 在插入时 p 就是最后一个节点了</p>
<p>那么根到 q 点表示的子串都是根到 np 表示的子串的后缀</p>
<p>在 parent tree 上，q 是 np 的父亲</p></li>
<li><p><span class="math inline">\(len[q]&gt;len[p]+1\)</span></p>
<p>在 parent tree 上，q 和 np 是兄弟</p>
<p>那么就新建一个 nq （复制一份 q ）作为它俩的父亲</p>
<p>将之前 p 及其祖先指向 q 的 c 儿子全指向 nq 即可</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> q = ch[p][c];</span><br><span class="line"><span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>)</span><br><span class="line">    fa[np] = q;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> nq = ++cnt;</span><br><span class="line">    <span class="built_in">memcpy</span>(ch[nq], ch[q], <span class="keyword">sizeof</span> ch[q]);</span><br><span class="line">    len[nq] = len[p] + <span class="number">1</span>;</span><br><span class="line">    fa[nq] = fa[q], fa[q] = fa[np] = nq;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; ch[p][c] == q)</span><br><span class="line">        ch[p][c] = nq, p = fa[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="code">code</h2>
<p>完整构造代码，看起来一堆 while 却是<span class="math inline">\(O(n)\)</span></p>
<p>注意点数是 2n 规模</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Suffix_Automaton</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> cnt, last;</span><br><span class="line">    <span class="keyword">int</span> fa[N&lt;&lt;<span class="number">1</span>], ch[N&lt;&lt;<span class="number">1</span>][<span class="number">30</span>], len[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">Suffix_Automaton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        last = cnt = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = last, np = last = ++cnt;</span><br><span class="line">        len[np] = len[p] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; !ch[p][c])</span><br><span class="line">            ch[p][c] = np, p = fa[p];</span><br><span class="line">        <span class="keyword">if</span> (!p) fa[np] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> q = ch[p][c];</span><br><span class="line">            <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>)</span><br><span class="line">                fa[np] = q;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> nq = ++cnt;</span><br><span class="line">                <span class="built_in">memcpy</span>(ch[nq], ch[q], <span class="keyword">sizeof</span> ch[q]);</span><br><span class="line">                len[nq] = len[p] + <span class="number">1</span>;</span><br><span class="line">                fa[nq] = fa[q], fa[q] = fa[np] = nq;</span><br><span class="line">                <span class="keyword">while</span> (p &amp;&amp; ch[p][c] == q)</span><br><span class="line">                    ch[p][c] = nq, p = fa[p];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; SAM;</span><br></pre></td></tr></table></figure>
<h2 id="应用">应用</h2>
<ul>
<li><p>判断子串</p>
<p>直接在 SAM 上跑，跑完没到 NULL 即为子串</p></li>
<li><p>求不同子串个数</p>
<p>设 <span class="math inline">\(f[i]\)</span> 为从 i 点出发的子串， <span class="math inline">\(f[i]=\sum_{(i,j)\in Edge}{f[j]+1}\)</span></p>
<p>好像还可以直接求 <span class="math inline">\(\sum{(len[i]-len[fa[i]])}\)</span> ，因为 SAM上无重复子串</p></li>
<li><p>待更~</p></li>
</ul>
<h2 id="题目">题目</h2>
<p>BANANA 由于过菜，还不会写几道题~</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3804">P3804 【模板】后缀自动机 (SAM)</a></li>
</ul>
<blockquote>
<p>求出 <em>S</em> 的所有出现次数不为 1 的子串的出现次数乘上该子串长度的最大值</p>
</blockquote>
<p>一个子串的出现次数即在 parent tree 上该子树的 size</p>
<p>暴力建出 parent tree，或者拓扑一下 DAG ，统计</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P4070">P4070 [SDOI2016]生成魔咒</a></li>
</ul>
<blockquote>
<p>每次向后插入一个字符，并求每次操作后不同子串个数</p>
</blockquote>
<p>显然 SAM 应用在求不同子串个数 <span class="math inline">\(\sum{(len[i]-len[fa[i]])}\)</span></p>
<p>每次只增加一个 len 影响总个数的节点，<code>ans += len[x] - len[fa[x]]</code>，于是每次 <span class="math inline">\(O(1)\)</span> 统计答案</p>
<p>大坑：“字符”范围 1e9 ，每个节点要用 map 存儿子</p>
<ul>
<li>待更~</li>
</ul>
]]></content>
      <categories>
        <category>总结</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 SA</title>
    <url>/2020/02/13/2020-02-13-%E6%9D%BF%E5%AD%90-SA/</url>
    <content><![CDATA[<p>先贴个板子，总结有时间在再说</p>
<a id="more"></a>
<h2 id="基数排序">基数排序</h2>
<p><span class="math inline">\(O(n)\)</span> 的排序是不是很诱人，桶排改进而已</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">qsort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        tax[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        ++tax[rnk[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        tax[i] += tax[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i)</span><br><span class="line">        sa[tax[rnk[tp[i]]]--] = tp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后缀排序">后缀排序</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_SA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        rnk[i] = s[i], tp[i] = i;</span><br><span class="line">    m = <span class="number">127</span>, qsort();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">1</span>, p = <span class="number">0</span>; w &lt;= n &amp;&amp; p &lt; n; m = p, w &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - w + <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            tp[++p] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (sa[i] &gt; w)</span><br><span class="line">                tp[++p] = sa[i] - w;</span><br><span class="line">        qsort();</span><br><span class="line">        swap(rnk, tp);</span><br><span class="line">        rnk[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">            rnk[sa[i]] = (tp[sa[i]] == tp[sa[i<span class="number">-1</span>]] &amp;&amp; tp[sa[i]+w] == tp[sa[i<span class="number">-1</span>]+w]) ? p : ++p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="求-height-数组">求 height 数组</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_height</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, k = <span class="number">0</span>, j; i &lt;= n; ++i) &#123;</span><br><span class="line">        k = max(<span class="number">0</span>, k - <span class="number">1</span>), j = sa[rnk[i]<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">while</span> (s[i+k] == s[j+k])</span><br><span class="line">            k++;</span><br><span class="line">        ht[rnk[i]] = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>SA</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P1966 火柴排队</title>
    <url>/2020/02/14/2020-02-14-%E9%A2%98%E8%A7%A3-P1966-%E7%81%AB%E6%9F%B4%E6%8E%92%E9%98%9F/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1966">题面</a></p>
<blockquote>
<p>两个数列 <span class="math inline">\(a,b\)</span>，求最少相邻两数交换多少次使得 <span class="math inline">\(\sum_{i=1}^n{(a_i-b_i)^2}\)</span> 最小</p>
</blockquote>
<a id="more"></a>
<h2 id="思路">思路</h2>
<p>先来简单地变换一下式子（见到这种狗式子一定要拆）： <span class="math display">\[
\sum{(a_i-b_i)^2}=\sum(a_i^2+b_i^2-2a_ib_i)
\]</span> <span class="math inline">\(\sum(a_i^2+b_i^2)\)</span> 是不变的，所以要最大化 <span class="math inline">\(\sum{a_ib_i}\)</span></p>
<p>所以要让 <span class="math inline">\(a,b\)</span> 中排名第 k 的两个数在同一位置上</p>
<p>为啥？<del>一点也不严谨的口胡</del>证明：</p>
<blockquote>
<p>假设有四个数 <span class="math inline">\(x_1,x_2,y_1,y_2\)</span>，且 <span class="math inline">\(x_1&lt;x_2,y_1&lt;y_2\)</span></p>
<p>那么 <span class="math inline">\(x_1y_1+x_2y_2&gt;x_1y_2+x_2y_1\)</span>，<del>这很显然吧</del></p>
<p>也就是说 <span class="math inline">\(a,b\)</span> 中最大两数乘积、次大两数乘积……的和是最大的</p>
</blockquote>
<p>然后怎么做？</p>
<p>让排名为 k 的 <span class="math inline">\(a_i,b_j\)</span> 两数在同一位置上，就是让 <span class="math inline">\(b_j\)</span> 到位置 <span class="math inline">\(i\)</span> 上</p>
<p>令 <span class="math inline">\(b_j=i\)</span>，再将 <span class="math inline">\(b\)</span> 数组排序，<span class="math inline">\(b_j\)</span> 自然到位置 <span class="math inline">\(i\)</span> 上了</p>
<p>是相邻两数交换来排序的话，最少次数就是此时 <span class="math inline">\(b\)</span> 的逆序对数（挺好证吧）</p>
<p>直接上树状数组或者归并</p>
<h2 id="code">code</h2>
<p>出题人还算良心，同一数列中两两各不相同，少了许多细节</p>
<p><a href="https://www.luogu.com.cn/record/30589508">评测记录</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;<span class="comment">/* fast read */</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">99999997</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ans;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N], tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 离散化</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">lsh</span><span class="params">(<span class="keyword">int</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) tmp[i] = t[i];</span><br><span class="line">    sort(tmp+<span class="number">1</span>, tmp+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> tot = unique(tmp+<span class="number">1</span>, tmp+n+<span class="number">1</span>) - tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        t[i] = lower_bound(tmp+<span class="number">1</span>, tmp+tot+<span class="number">1</span>, t[i]) - tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树状数组，用于求逆序对</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bit_Tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> tr[N];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x &lt;= n) </span><br><span class="line">            tr[x] += k, x += lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> re = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x) </span><br><span class="line">            re += tr[x], x -= lowbit(x);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; tr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(b[i]);</span><br><span class="line">    <span class="comment">// 离散化，同时也是得到每个数的排名</span></span><br><span class="line">    lsh(a), lsh(b);</span><br><span class="line">    <span class="comment">// 让 b 数列每个元素得到 a 中同一排名元素的坐标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        tmp[a[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        b[i] = tmp[b[i]];</span><br><span class="line">    <span class="comment">// 统计答案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 每次加入一个数增加逆序对数：原个数 - 小于它的元素个数</span></span><br><span class="line">        ans = (ans + i - <span class="number">1</span> - tr.query(b[i])) % MOD;</span><br><span class="line">        tr.add(b[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2831 愤怒的小鸟</title>
    <url>/2020/02/14/2020-02-14-%E9%A2%98%E8%A7%A3-P2831-%E6%84%A4%E6%80%92%E7%9A%84%E5%B0%8F%E9%B8%9F/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2831">题面</a></p>
<blockquote>
<p>在坐标系第一象限有一些点，用一些经过原点、开口向下的抛物线 <span class="math inline">\(y=ax^2+bx\)</span> 覆盖所有点，最少需要多少条</p>
</blockquote>
<a id="more"></a>
<h2 id="思路">思路</h2>
<p>注意到 <span class="math inline">\(n\le 18\)</span>，基本上是状压 DP</p>
<h3 id="初始做法">初始做法</h3>
<p>考虑压缩点的覆盖状态，设 <span class="math inline">\(f[S]\)</span> 表示集合 <span class="math inline">\(S\)</span> 被覆盖需要最少的抛物线数</p>
<p>每两个点确定一条抛物线（经过原点），预处理每条抛物线 <span class="math inline">\(line_{i,j}\)</span> 能覆盖的点集合</p>
<p>不难得出转移方程： <span class="math display">\[
f[S\cup line_{i,j}]=f[S]+1\\
f[S\cup i]=f[S]+1
\]</span> 那么 <span class="math inline">\(O(2^n)\)</span> 枚举集合状态，再每个状态 <span class="math inline">\(O(n^2)\)</span> 枚举抛物线转移，复杂度 <span class="math inline">\(O(Tn^2 2^n)\)</span></p>
<p>估算一下，计算量在 4e8 级别，不一定过</p>
<h3 id="优化">优化</h3>
<p>在每个状态 <span class="math inline">\(S\)</span>，转移后至少覆盖一个点</p>
<p>从 i 出发枚举抛物线转移和从 j 出发枚举的顺序先后没有关系</p>
<p>先覆盖 i，和覆盖 j 后再覆盖 i，是一样的（如果 j 出发的抛物线能覆盖 i，从 i 出发也一定能覆盖 j）</p>
<p>于是每个状态我只从一个点出发枚举抛物线，复杂度降到 <span class="math inline">\(O(Tn2^n)\)</span>，稳过</p>
<p>要预处理每个状态最小的未覆盖的点是哪个</p>
<h3 id="提示">提示</h3>
<p>从两个点的坐标 <span class="math inline">\((x_1,y_1),(x_2,y_2)\)</span> 算出抛物线参数 <span class="math inline">\(a,b\)</span>，要推一下公式：</p>
<p>解 <span class="math inline">\(a\)</span>： <span class="math display">\[
\begin{cases}
    y_1=ax_1^2+bx_1\\
    y_2=ax_2^2+bx_2
\end{cases}\\
\begin{cases}
    \frac{y_1}{x_1}=ax_1+b\\
    \frac{y_2}{x_2}=ax_2+b
\end{cases}\\
a(x_1-x_2)=\frac{y_1}{x_1}-\frac{y_2}{x_2}\\
a=\frac{x_2y_1-x_1y_2}{x_1x_2(x_1-x_2)}
\]</span> 解 <span class="math inline">\(b\)</span>： <span class="math display">\[
\begin{cases}
    y_1=ax_1^2+bx_1\\
    y_2=ax_2^2+bx_2
\end{cases}\\
\begin{cases}
    \frac{y_1}{x_1^2}=a+\frac{b}{x_1}\\
    \frac{y_2}{x_2^2}=a+\frac{b}{x_2}
\end{cases}\\
b(\frac{1}{x_1}-\frac{1}{x_2})=\frac{y_1}{x_1^2}-\frac{y_2}{x_2^2}\\
b=\frac{x_1^2y_2-x_2^2y_1}{x_1x_2(x_1-x_2)}
\]</span></p>
<h2 id="code">code</h2>
<p><a href="https://www.luogu.com.cn/record/30577051">提交记录</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;<span class="comment">/* fast read */</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = (<span class="number">1</span> &lt;&lt; <span class="number">18</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装了抛物线，便于比较</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> a, b;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> ==(Line &amp;t) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fabs</span>(a - t.a) &lt;= eps &amp;&amp; <span class="built_in">fabs</span>(b - t.b) &lt;= eps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, m, maxn;</span><br><span class="line"><span class="keyword">int</span> low[MAXN], line[N][N], f[MAXN];</span><br><span class="line"><span class="keyword">double</span> x[N], y[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由推导的公式算抛物线</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Line <span class="title">get_line</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Line)&#123;</span><br><span class="line">        (x[b] * y[a] - x[a] * y[b]) / (x[a] * x[b] * (x[a] - x[b])),</span><br><span class="line">        (x[a] * x[a] * y[b] - x[b] * x[b] * y[a]) / (x[a] * x[b] * (x[a] - x[b]))</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 预处理最小未覆盖的点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= MAXN; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)</span><br><span class="line">            <span class="keyword">if</span> ((i &amp; (<span class="number">1</span> &lt;&lt; j)) == <span class="number">0</span>) &#123;</span><br><span class="line">                low[i] = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    read(T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        read(n), read(m);</span><br><span class="line">        maxn = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>, &amp;x[i], &amp;y[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                line[i][j] = <span class="number">0</span>;<span class="comment">// 多测清空</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">fabs</span>(x[i] - x[j]) &gt;= eps) &#123;<span class="comment">// 横坐标相同则无解</span></span><br><span class="line">                    Line t = get_line(i, j);</span><br><span class="line">                    <span class="keyword">if</span> (t.a &gt; -eps) <span class="keyword">continue</span>;<span class="comment">// 解出来开口向上不算</span></span><br><span class="line">                    line[i][j] |= (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>)) | (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>));</span><br><span class="line">                    <span class="comment">// 寻找在同一抛物线上的点</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line">                        <span class="keyword">if</span> (k != i &amp;&amp; k != j &amp;&amp; get_line(i, k) == t)</span><br><span class="line">                            line[i][j] |= <span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxn; ++i) f[i] = INF;<span class="comment">// 清空qwq</span></span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = low[i], j = <span class="number">1</span> &lt;&lt; (x - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (x &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">            f[i|j] = min(f[i|j], f[i] + <span class="number">1</span>); <span class="comment">// 只覆盖一个点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">1</span>; y &lt;= n; ++y)</span><br><span class="line">                f[i|line[x][y]] = min(f[i|line[x][y]], f[i] + <span class="number">1</span>); <span class="comment">// 通过抛物线转移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[maxn]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2014 [CTSC1997]选课</title>
    <url>/2020/04/04/2020-04-04-%E9%A2%98%E8%A7%A3-P2014-CTSC1997%E9%80%89%E8%AF%BE/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2014">题目</a></p>
<blockquote>
<p>给一棵 n 个点的树，每个点有权值，选择一个点必须同时选择其父节点</p>
<p>求选 m 个点的最大权值和</p>
</blockquote>
<a id="more"></a>
<h2 id="思路">思路</h2>
<p><strong>树上背包问题</strong></p>
<p>选择 m 个点使其总价值最大，典型的背包问题</p>
<p>先设 <span class="math inline">\(f_{i,j}\)</span>，表示以 i 为根的子树中选择 j 个能够得到最大价值</p>
<p>再考虑树形dp的模型，要求一棵树的答案能够由其子树得到</p>
<p>把节点 u 看作背包枚举空间 j，把每个儿子 v 看做物品，枚举选择个数（重量）k，物品价值为 <span class="math inline">\(f_{v,k}\)</span></p>
<p>转移方程： <span class="math display">\[
\large f_{u,j}=f_{u,j-k}+f_{v,k}
\]</span> 注意是01背包，j 要倒序枚举</p>
<ul>
<li><p>如何保证选择一个点的同时选择其父节点？</p></li>
<li><p>赋初值 <span class="math inline">\(f_{u,1}=val_u\)</span>，手动模拟一下dp过程就懂了</p></li>
</ul>
<h2 id="code">code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">309</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> nxt, to;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, cnt_e;</span><br><span class="line"><span class="keyword">int</span> head[N], val[N], f[N][N];</span><br><span class="line">Edge e[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[++cnt_e] = (Edge)&#123;head[u], v&#125;, head[u] = cnt_e;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    f[u][<span class="number">1</span>] = val[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt) &#123;</span><br><span class="line">        v = e[i].to;</span><br><span class="line">        dp(v);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m + <span class="number">1</span>; j; --j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; j; ++k)</span><br><span class="line">                f[u][j] = max(f[u][j], f[u][j-k] + f[v][k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u; i &lt;= n; ++i)</span><br><span class="line">        read(u), add_edge(u, i), read(val[i]);</span><br><span class="line">    dp(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[<span class="number">0</span>][m+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P5664 Emiya 家今天的饭</title>
    <url>/2020/04/04/2020-04-04-%E9%A2%98%E8%A7%A3-P5664-Emiya-%E5%AE%B6%E4%BB%8A%E5%A4%A9%E7%9A%84%E9%A5%AD/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P5664">题目</a></p>
<blockquote>
<p>n 种烹饪方法，有 m 种食材，第 i 个方法的第 j 种食材有 <span class="math inline">\(a_{i,j}\)</span> 个</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>要求：</p>
<ul>
<li>至少要做一道菜</li>
<li>一种方法最多做一道菜</li>
<li>做 k 道菜，每种食材使用次数不超过 <span class="math inline">\(\lfloor\frac{k}{2}\rfloor\)</span> 次</li>
</ul>
<p>求总方案数 <span class="math inline">\(\pmod{998244353}\)</span></p>
</blockquote>
<h2 id="思路">思路</h2>
<p>明显的计数DP</p>
<p>第三个限制很讨厌，先不管它</p>
<p>我们可以用总方案数减去不合法的方案</p>
<p>因为题目背景让我叙述不方便，<strong>建议把“方法”和“食材”想象成行和列</strong></p>
<h3 id="总方案数">总方案数</h3>
<p>无视第三个条件时，只要考虑每个方法选或不选</p>
<p>设 <span class="math inline">\(s_i\)</span> 表示第 i 种方法的食材个数和，即 <span class="math inline">\(\sum_{k=1}^m{a_{i,k}}\)</span></p>
<p>设 <span class="math inline">\(g_{i,j}\)</span> 表示前 i 种方法选了 j 种的方案数 <span class="math display">\[
\large g_{i,j}=g_{i-1,j}+g_{i-1,j-1}\times s_i
\]</span> 此时总方案数为</p>
<p><span class="math display">\[
\sum_{i=1}^n{g_{n,i}}
\]</span></p>
<p>复杂度 <span class="math inline">\(O(n^2)\)</span></p>
<h3 id="不合格方案数">不合格方案数</h3>
<p>某种食材选择的个数超过的总菜数的一半即为不合格</p>
<p>因为<strong>最多只有一种食材</strong>的个数会超过一半</p>
<p>只要对于每一种食材 i，考虑第 i 种食材的个数与其它食材的个数关系</p>
<p>设 <span class="math inline">\(f_{j,x,y}\)</span> 表示前 j 种方法，食材 i 选了 x 个，其它选了 y 个 <span class="math display">\[
\large f_{j,x,y}=f_{j-1,x,y}+f_{j-1,x-1,y}\times a_{j,i}+f_{j-1,x,y-1}\times(s_j-a_{j,i})
\]</span> 每种食材dp一遍，复杂度 <span class="math inline">\(O(mn^3)\)</span>，需要<strong>降维</strong></p>
<p>又碰上这种套路：<strong>我们不需要知道 x，y 的具体数值，只需要知道他们的关系</strong></p>
<p>设 <span class="math inline">\(f_{j,k}\)</span> 表示前 j 种方法，食材 i 选的个数比其它的多 k 个 <span class="math display">\[
\large f_{j,k}=f_{j-1,k}+f_{j-1,k-1}\times a_{j,i}+f_{j-1,k+1}\times(s_j-a_{j,i})
\]</span> 这样复杂度就是 <span class="math inline">\(O(mn^2)\)</span> 了</p>
<p>总共不合法方案数为 <span class="math display">\[
\sum_{i=1}^n{f_{n,i}}
\]</span></p>
<h3 id="细节">细节</h3>
<p>DP <span class="math inline">\(f_{j,k}\)</span> 时，k 的范围为 -j ~ j，可能为<strong>负数</strong>，需要数组下标整体偏移 n，数组也要开 2n 倍</p>
<p>转移时 <code>g[i][j] = (g[i-1][j] + sum[i][0] * g[i-1][j-1]) % MOD;</code> 这么写爆 long long</p>
<p>要<strong>每个</strong>乘法前强制转 long long，或者直接全开 long long</p>
<h2 id="code">code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">109</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2009</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">LL ans;</span><br><span class="line">LL a[N][M], sum[N][M], f[N][N&lt;&lt;<span class="number">1</span>], g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            read(a[i][j]), sum[i][<span class="number">0</span>] = (sum[i][<span class="number">0</span>] + a[i][j]) % MOD;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            sum[i][j] = (sum[i][<span class="number">0</span>] - a[i][j] + MOD) % MOD;</span><br><span class="line">    </span><br><span class="line">    g[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        g[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            g[i][j] = (g[i<span class="number">-1</span>][j] + sum[i][<span class="number">0</span>] * g[i<span class="number">-1</span>][j<span class="number">-1</span>]) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">        f[<span class="number">0</span>][n] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = n - j; k &lt;= n + j; ++k)</span><br><span class="line">                f[j][k] = (f[j<span class="number">-1</span>][k] + a[j][i] * f[j<span class="number">-1</span>][k<span class="number">-1</span>] + sum[j][i] * f[j<span class="number">-1</span>][k+<span class="number">1</span>]) % MOD;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            ans = (ans + MOD - f[n][n+j]) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        ans = (ans + g[n][i]) % MOD;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>递推DP</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>总结 虚树</title>
    <url>/2020/04/06/2020-04-06-%E6%80%BB%E7%BB%93-%E8%99%9A%E6%A0%91/</url>
    <content><![CDATA[<p>某些树形dp的数据范围过大，有多次询问，每次询问选定关键点（关键点总和在 1e5~1e6 的范围）</p>
<p>例题：<a href="https://www.luogu.com.cn/problem/P2495">P2495 [SDOI2011]消耗战</a></p>
<a id="more"></a>
<p>此时会有很多点不需要参与dp，只要另外建出一棵包含有用点的虚树来</p>
<p><img src="https://s1.ax1x.com/2020/04/06/Gs98AI.png" /></p>
<p>有一种增量构造的方法，难写难记（几个月前写的还没调出来），所以我干脆只学本文这种方法</p>
<p>推荐 <a href="https://www.luogu.com.cn/blog/ShadowassIIXVIIIIV/solution-p2495">shadowice1984 的博客</a></p>
<h2 id="思路">思路</h2>
<p>我们只要掌握了一棵树的dfs序，就可以模拟整个dfs过程</p>
<p>对于关键点序列 a，dfs 一遍，求出每个点的 dfs 序（入栈和出栈的）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">    pu[u] = ++dfu;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span> ((v = e[i].to) != last) &#123;</span><br><span class="line">            dfs(v, u);</span><br><span class="line">    po[u] = ++dfu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将关键点按dfs序排序，相邻两个点取 LCA，加入 a 序列，再把树根 1 加入</p>
<p>注意开个 bool 数组<strong>去重</strong></p>
<p>最后把整个序列 a 复制一份，全部<strong>取负</strong>，加入序列</p>
<p>此时序列 a 中全是虚树节点，正数代表入栈点，负数代表出栈点</p>
<p>将 a 序列按照 dfs 序排序，cmp 中要区分出入栈：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; <span class="number">0</span> ? pu[x] : po[-x]) &lt; (y &gt; <span class="number">0</span> ? pu[y] : po[-y]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在整个虚树的 dfs 序已经知道了，如果是简单的树形dp甚至不需要建树，直接模拟 dfs 遍历：</p>
<p>开一个栈，遍历 a 序列，如果是正数即入栈，进行 dfs 递归前的操作</p>
<p>负数说明出栈，进行 dfs 递归完各个子树后的操作</p>
<p>如果要建树，“dfs”时对于每个父子关系建边就行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= tot; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] &gt; <span class="number">0</span>) stk[++top] = a[i];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        v = stk[top--], u = stk[top];</span><br><span class="line">        Add_edge(u, v), Add_edge(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意多次询问的一定要清空（在 a 序列上的点），不能用 <span class="math inline">\(O(n)\)</span> 的 memset</p>
<h2 id="code">code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> tot, top, cnt_e;</span><br><span class="line"><span class="keyword">int</span> a[N&lt;&lt;<span class="number">1</span>], stk[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">    pu[u] = ++dfu;</span><br><span class="line">    <span class="comment">// 预处理LCA用的deep,fa...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span> ((v = e[i].to) != last) &#123;</span><br><span class="line">            dfs(v, u);</span><br><span class="line">    po[u] = ++dfu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; <span class="number">0</span> ? pu[x] : po[-x]) &lt; (y &gt; <span class="number">0</span> ? pu[y] : po[-y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build_tree</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    tot = top = cnt_e = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">        a[++tot] = <span class="built_in">array</span>[i], vis[a[tot]] = <span class="literal">true</span>;</span><br><span class="line">    sort(a+<span class="number">1</span>, a+tot+<span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, lca; i &lt; k; ++i) &#123;</span><br><span class="line">        lca = LCA(a[i], a[i+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (!vis[lca]) a[++tot] = lca, vis[lca] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!vis[<span class="number">1</span>]) a[++tot] = <span class="number">1</span>;</span><br><span class="line">    k = tot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">        a[++tot] = -a[i];</span><br><span class="line">    sort(a+<span class="number">1</span>, a+tot+<span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= tot; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; <span class="number">0</span>) stk[++top] = a[i];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            v = stk[top--], u = stk[top];</span><br><span class="line">            Add_edge(u, v), Add_edge(v, u);</span><br><span class="line">            vis[v] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="luogu-p2495-code">Luogu P2495 code</h2>
<p>顺便放上去</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TT&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(TT x, <span class="keyword">char</span> end = <span class="string">&#x27;\n&#x27;</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">25e4</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> nxt, to, val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, cnt_e, dfu;</span><br><span class="line"><span class="keyword">int</span> head[N], pu[N], po[N], fa[N][<span class="number">20</span>], deep[N], mn[N], a[N&lt;&lt;<span class="number">1</span>], stk[N];</span><br><span class="line">LL f[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line">Edge e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[++cnt_e] = (Edge)&#123;head[u], v, w&#125;, head[u] = cnt_e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">    pu[u] = ++dfu;</span><br><span class="line">    deep[u] = deep[last] + <span class="number">1</span>;</span><br><span class="line">    fa[u][<span class="number">0</span>] = last;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; <span class="number">1</span> &lt;&lt; i &lt;= deep[u]; ++i)</span><br><span class="line">        fa[u][i] = fa[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span> ((v = e[i].to) != last) &#123;</span><br><span class="line">            mn[v] = min(mn[u], e[i].val);</span><br><span class="line">            dfs(v, u);</span><br><span class="line">        &#125;</span><br><span class="line">    po[u] = ++dfu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deep[x] &lt; deep[y]) swap(x, y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> (deep[fa[x][i]] &gt;= deep[y])</span><br><span class="line">            x = fa[x][i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> (fa[x][i] != fa[y][i])</span><br><span class="line">            x = fa[x][i], y = fa[y][i];</span><br><span class="line">    <span class="keyword">return</span> x == y ? x : fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; <span class="number">0</span> ? pu[x] : po[-x]) &lt; (y &gt; <span class="number">0</span> ? pu[y] : po[-y]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, w; i &lt; n; ++i)</span><br><span class="line">        read(u), read(v), read(w), add_edge(u, v, w), add_edge(v, u, w);</span><br><span class="line">    mn[<span class="number">1</span>] = <span class="number">0x7fffffff</span>;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    read(m);</span><br><span class="line">    <span class="keyword">int</span> k, tot, top;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        tot = top = <span class="number">0</span>;</span><br><span class="line">        read(k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">            read(a[++tot]), vis[a[tot]] = <span class="literal">true</span>, f[a[tot]] = mn[a[tot]];</span><br><span class="line">        sort(a+<span class="number">1</span>, a+k+<span class="number">1</span>, cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, lca; i &lt; k; ++i)&#123;</span><br><span class="line">            lca = LCA(a[i], a[i+<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (!vis[lca]) a[++tot] = lca, vis[lca] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!vis[<span class="number">1</span>]) a[++tot] = <span class="number">1</span>;</span><br><span class="line">        k = tot;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">            a[++tot] = -a[i];</span><br><span class="line">        sort(a+<span class="number">1</span>, a+tot+<span class="number">1</span>, cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u; i &lt;= tot; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; <span class="number">0</span>) stk[++top] = a[i];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                u = stk[top--];</span><br><span class="line">                <span class="keyword">if</span> (u != <span class="number">1</span>)</span><br><span class="line">                    f[stk[top]] += min(f[u], (LL)mn[u]);</span><br><span class="line">                <span class="keyword">else</span> print(f[u]);</span><br><span class="line">                f[u] = vis[u] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>LCA</tag>
        <tag>虚树</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 快速乘</title>
    <url>/2020/08/02/2020-08-02-%E6%9D%BF%E5%AD%90-%E5%BF%AB%E9%80%9F%E4%B9%98/</url>
    <content><![CDATA[<p>对于<code>long long</code>范围下模意义的乘法，我们需要快速乘防止溢出</p>
<a id="more"></a>
<h2 id="ologn-快速乘"><span class="math inline">\(O(logn)\)</span> 快速乘</h2>
<p>类比快速幂</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">mul</span><span class="params">(LL a, LL b, LL p)</span> </span>&#123;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = (ans + a) % p;</span><br><span class="line">        a = (a + a) % p, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="o1-快速乘-1"><span class="math inline">\(O(1)\)</span> 快速乘 #1</h2>
<p>利用<code>long double</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">mul</span><span class="params">(LL a, LL b, LL p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a * b - (LL)((<span class="keyword">long</span> <span class="keyword">double</span>)a / p * b) * p + p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="o1-快速乘-2"><span class="math inline">\(O(1)\)</span> 快速乘 #2</h2>
<p>利用位运算</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">mul</span><span class="params">(LL a, LL b, LL p)</span> </span>&#123;</span><br><span class="line">    LL lf = a * (b &gt;&gt; <span class="number">25L</span>L) % p * (<span class="number">1L</span>L &lt;&lt; <span class="number">25</span>) % p;</span><br><span class="line">    LL rg = a * (b &amp; ((<span class="number">1L</span>L &lt;&lt; <span class="number">25</span>) - <span class="number">1</span>)) % p;</span><br><span class="line">    <span class="keyword">return</span> (lf + rg) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
        <category>Math</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P3527 [POI2011]MET-Meteors</title>
    <url>/2020/08/04/2020-08-04-%E9%A2%98%E8%A7%A3-P3527-POI2011MET-Meteors/</url>
    <content><![CDATA[<blockquote>
<p>有 n 个成员国。环形轨道被分为 m 份（第 m份和第 1 份相邻），第 i 份上有第 <span class="math inline">\(a_i\)</span> 个国家的太空站。有 k 场陨石雨，[l, r]的轨道区间加上 a。</p>
<p>第 i 个成员国希望能够收集 <span class="math inline">\(p_i\)</span> 单位的陨石样本。判断对于每个国家，它需要在第几次陨石雨之后，才能收集足够的陨石。</p>
<p><span class="math inline">\(n,m,k\le 3\times 10^5\)</span></p>
</blockquote>
<a id="more"></a>
<h2 id="思路">思路</h2>
<p>这类题可以想到用整体二分来解决。</p>
<h3 id="onlog2n-做法"><span class="math inline">\(O(nlog^2n)\)</span> 做法</h3>
<p>将 k 场陨石雨作为修改，n 个国家作为查询。</p>
<p>二分答案时间 mid，mid 之前的修改放左边，之后的修改放右边；mid 之前收集足够的国家放左边，否则放右边。</p>
<p>将陨石雨以差分形式修改，利用树状数组 <span class="math inline">\(O(logn)\)</span> 查询每段轨道在某一时间的陨石数，这样每个国家暴力查总陨石数，即可划分国家。</p>
<p>这样分治下去复杂度 <span class="math inline">\(O(nlog^2n)\)</span>，能过这道题</p>
<h3 id="onlogn-做法"><span class="math inline">\(O(nlogn)\)</span> 做法</h3>
<p>感谢 <a href="https://www.luogu.com.cn/blog/jiangly/p3527-poi2011met-meteors-ti-xie">jly 神仙的题解</a> 启发，这个思路太棒了。</p>
<p>同样是二分答案时间 mid，陨石雨作为询问（修改），但是要把 m 个轨道放进去和修改一块二分。</p>
<p>mid 之前的询问放左边，之后的放右边；mid 之前轨道所在国家收集足够的放左边，否则放右边。</p>
<p>二分之前将所有询问按位置排序，分治时可以通过 two-pointers 扫描轨道和询问，从而计算每个轨道的陨石数，每个点的查询 <span class="math inline">\(O(1)\)</span>，分治每层 <span class="math inline">\(O(n)\)</span>，成功降了一个 log。</p>
<h2 id="code">code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> RenaMoe &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TT&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(TT x, <span class="keyword">char</span> end = <span class="string">&#x27;\n&#x27;</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ask</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> pos, id;</span><br><span class="line">    LL a;</span><br><span class="line">    Ask() &#123;&#125;</span><br><span class="line">    Ask(<span class="keyword">int</span> _p, <span class="keyword">int</span> _i, LL _a) &#123;</span><br><span class="line">        pos = _p, id = _i, a = _a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Ask &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pos &lt; t.pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, cnt;</span><br><span class="line"><span class="keyword">int</span> o[N], p[N], s[N], s1[N], s2[N], ans[N];</span><br><span class="line">LL sum[N];</span><br><span class="line">Ask q[N&lt;&lt;<span class="number">1</span>], q1[N&lt;&lt;<span class="number">1</span>], q2[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// l,r答案时间；sl,sr轨道区间；ql,qr询问区间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> sl, <span class="keyword">int</span> sr, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sl &gt; sr || ql &gt; qr) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = sl; i &lt;= sr; ++i) sum[o[s[i]]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        LL qsum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = sl, j = ql; i &lt;= sr; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt;= qr &amp;&amp; q[j].pos &lt;= s[i])</span><br><span class="line">                qsum += q[j].a, j++;</span><br><span class="line">            <span class="keyword">if</span> (sum[o[s[i]]] &lt; p[o[s[i]]])</span><br><span class="line">                sum[o[s[i]]] += qsum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = sl; i &lt;= sr; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum[o[s[i]]] &gt;= p[o[s[i]]])</span><br><span class="line">                ans[o[s[i]]] = l;</span><br><span class="line">            <span class="keyword">else</span> ans[o[s[i]]] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, cq1 = <span class="number">0</span>, cq2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = ql; i &lt;= qr; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[i].id &lt;= mid) q1[++cq1] = q[i];</span><br><span class="line">        <span class="keyword">else</span> q2[++cq2] = q[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cq1; ++i) q[ql+i<span class="number">-1</span>] = q1[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cq2; ++i) q[ql+cq1+i<span class="number">-1</span>] = q2[i];</span><br><span class="line"></span><br><span class="line">    LL qsum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = sl, j = ql; i &lt;= sr; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; ql+cq1 &amp;&amp; q[j].pos &lt;= s[i])</span><br><span class="line">            qsum += q[j].a, j++;</span><br><span class="line">        <span class="keyword">if</span> (sum[o[s[i]]] &lt; p[o[s[i]]])</span><br><span class="line">            sum[o[s[i]]] += qsum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cs1 = <span class="number">0</span>, cs2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = sl; i &lt;= sr; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum[o[s[i]]] &gt;= p[o[s[i]]])</span><br><span class="line">            s1[++cs1] = s[i];</span><br><span class="line">        <span class="keyword">else</span> s2[++cs2] = s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cs1; ++i) s[sl+i<span class="number">-1</span>] = s1[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cs2; ++i) s[sl+cs1+i<span class="number">-1</span>] = s2[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = sl+cs1; i &lt;= sr; ++i)</span><br><span class="line">        p[o[s[i]]] -= sum[o[s[i]]], sum[o[s[i]]] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    solve(l, mid, sl, sl+cs1<span class="number">-1</span>, ql, ql+cq1<span class="number">-1</span>);</span><br><span class="line">    solve(mid+<span class="number">1</span>, r, sl+cs1, sr, ql+cq1, qr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) read(o[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(p[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) s[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ans[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> k, l, r;</span><br><span class="line">    LL a;</span><br><span class="line">    read(k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        read(l), read(r), read(a);</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= r) &#123;</span><br><span class="line">            q[++cnt] = Ask(l, i, a);</span><br><span class="line">            <span class="keyword">if</span> (r &lt; m) q[++cnt] = Ask(r+<span class="number">1</span>, i, -a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            q[++cnt] = Ask(<span class="number">1</span>, i, a);</span><br><span class="line">            <span class="keyword">if</span> (l &gt; r + <span class="number">1</span>) &#123;</span><br><span class="line">                q[++cnt] = Ask(r+<span class="number">1</span>, i, -a);</span><br><span class="line">                q[++cnt] = Ask(l, i, a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q+<span class="number">1</span>, q+cnt+<span class="number">1</span>);</span><br><span class="line">    solve(<span class="number">1</span>, k, <span class="number">1</span>, m, <span class="number">1</span>, cnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans[i] == <span class="number">-1</span>) <span class="built_in">puts</span>(<span class="string">&quot;NIE&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> print(ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RenaMoe::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<p>真的跑的飞快 &gt;_&lt;</p>
<p><img src="https://s1.ax1x.com/2020/08/05/ariBRK.png" /></p>
<p>jly 题解讲的不是很详细，我太菜了根本看不懂，这道题我做了一晚上+一早上qwq</p>
<p>空间要开 3 倍以上啊啊啊，只开了 2 倍的我 wa 了几个小时！</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>思想</category>
      </categories>
      <tags>
        <tag>CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P4027 [NOI2007]货币兑换</title>
    <url>/2020/08/05/2020-08-05-%E9%A2%98%E8%A7%A3-P4027-NOI2007%E8%B4%A7%E5%B8%81%E5%85%91%E6%8D%A2/</url>
    <content><![CDATA[<blockquote>
<p>有 A,B 两种金券，它们每天的价值都不同，在第 i 天时分别为 <span class="math inline">\(A_i,B_i\)</span>，你可以用手中的金券换取相应价值的钱，或用钱兑换相同价值的金券，但兑换到的两种金券的数量之比是一个定值，这个定值在第 i 天为 <span class="math inline">\(R_i\)</span>。</p>
<p>现给出 n 天中两种金券的价值，R，以及你初始时拥有的资金 S，求 n 天后你最多能有多少钱。</p>
</blockquote>
<a id="more"></a>
<p>我来做经典的CDQ维护凸包了qwq。</p>
<h2 id="思路">思路</h2>
<h3 id="dp">DP</h3>
<p>如果第 i 天卖出相对于第 j 天买入有利可图，那么肯定全部卖出。</p>
<p>考虑 DP，我们可以推出转移方程： <span class="math display">\[
f_i=\frac{f_jR_j}{A_jR_j+B_j}\times A_i + \frac{f_j}{A_jR_j+B_j}\times B_i
\]</span> 我们设 A,B 券分别买入的数量为 <span class="math inline">\(x_i=\frac{f_iR_i}{A_iR_i+B_i},y_i=\frac{f_i}{A_iR_i+B_i}\)</span> 。</p>
<p>得到：</p>
<p><span class="math display">\[
f_i=A_ix_j + B_iy_j\\
y_j=-\frac{A_i}{B_i}x_j+\frac{f_i}{B_j}
\]</span></p>
<p>啊这是个斜率优化欸，维护上凸包使得直线的 <span class="math inline">\(b=\frac{f_i}{B_j}\)</span> 最大。</p>
<p><del>我上来就单调队列线性时间内干过去。。。啊怎么不太对</del>。</p>
<p>发现斜率 <span class="math inline">\(-\frac{A_i}{B_i}\)</span> 不是单调的，需要手写平衡树维护凸包什么的。</p>
<p>这辈子不可能写这种东西的，虽然 cmd2001 学长有博客讲用 <a href="https://www.cnblogs.com/Cmd2001/p/8492492.html">STL set 维护动态凸包</a>。</p>
<p>于是我们来学习 CDQ 维护斜率优化凸包。</p>
<h3 id="cdq-维护斜率优化的凸包">CDQ 维护斜率优化的凸包</h3>
<p>CDQ 分治的话，要每次计算左半边对右半边的贡献。</p>
<p>可以让左区间按 <span class="math inline">\(x_i\)</span> 排序，保持右区间按斜率 <span class="math inline">\(k_i=\frac{A_i}{B_i}\)</span> 单调递增有序。</p>
<p>左区间就可以通过栈维护一个斜率单调递减的凸包来更新右区间的答案。</p>
<p>每一层分治就这么 <span class="math inline">\(O(n)\)</span> 解决，总复杂度 <span class="math inline">\(O(nlogn)\)</span>。</p>
<h2 id="code">code</h2>
<p><a href="https://www.luogu.com.cn/record/36384478">提交记录</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> RenaMoe &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(TT &amp;x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-7</span>;<span class="comment">// 注意精度误差</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> INF = <span class="number">1e8</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ask</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> k, x, y, a, b, r;<span class="comment">// 分别表示：斜率,x,y,A,B,R</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, s;</span><br><span class="line"><span class="keyword">int</span> stk[N];</span><br><span class="line">Ask q[N], tmp[N];</span><br><span class="line"><span class="keyword">double</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Ask &amp;x, <span class="keyword">const</span> Ask &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.k &lt; y.k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求斜率</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">get_slope</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(q[i].x - q[j].x) &lt;= Eps) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> (q[i].y - q[j].y) / (q[i].x - q[j].x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="comment">// 此时1~l-1的答案都已经处理完，更新f[l]</span></span><br><span class="line">        f[l] = max(f[l], f[l<span class="number">-1</span>]);</span><br><span class="line">        q[l].y = f[l] / (q[l].a * q[l].r + q[l].b), q[l].x = q[l].y * q[l].r;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按id划分左右区间</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, q1 = l, q2 = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[i].id &lt;= mid) tmp[q1++] = q[i];</span><br><span class="line">        <span class="keyword">else</span> tmp[q2++] = q[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) q[i] = tmp[i];</span><br><span class="line">    <span class="comment">// 先处理左区间</span></span><br><span class="line">    solve(l, mid);</span><br><span class="line">    <span class="comment">// 维护左区间斜率单调递减的凸包</span></span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= mid; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &gt;= <span class="number">2</span> &amp;&amp; get_slope(stk[top<span class="number">-1</span>], stk[top]) &lt; get_slope(stk[top], i) + Eps) top--;</span><br><span class="line">        stk[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用左区间的凸包更新右区间答案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid+<span class="number">1</span>; i &lt;= r; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &gt;= <span class="number">2</span> &amp;&amp; get_slope(stk[top<span class="number">-1</span>], stk[top]) &lt;= q[i].k + Eps) top--;</span><br><span class="line">        <span class="keyword">int</span> j = stk[top];</span><br><span class="line">        f[q[i].id] = max(f[q[i].id], q[i].a * q[j].x + q[i].b * q[j].y);<span class="comment">// 注意是q[i].id，不是i</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理右区间</span></span><br><span class="line">    solve(mid+<span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">// 按x单调递增归并排序，以作为上一层的左区间</span></span><br><span class="line">    q1 = l, q2 = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q1 &lt;= mid &amp;&amp; (q2 &gt; r || q[q1].x &lt; q[q2].x + Eps)) tmp[i] = q[q1++];</span><br><span class="line">        <span class="keyword">else</span> tmp[i] = q[q2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) q[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf%lf&quot;</span>, &amp;q[i].a, &amp;q[i].b, &amp;q[i].r);</span><br><span class="line">        q[i].k = -(q[i].a / q[i].b), q[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q+<span class="number">1</span>, q+n+<span class="number">1</span>, cmp);<span class="comment">// 先按斜率单调递增排序</span></span><br><span class="line">    f[<span class="number">0</span>] = s;</span><br><span class="line">    solve(<span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>, f[n]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RenaMoe::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>CDQ分治</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P6007 [USACO20JAN]Springboards G</title>
    <url>/2020/08/09/2020-08-09-%E9%A2%98%E8%A7%A3-P6007-USACO20JANSpringboards-G/</url>
    <content><![CDATA[<blockquote>
<p>N*N 的矩阵，从 (0,0) 走到 (N,N)，每次只能往右和往上走（求曼哈顿距离），有 P 个跳板可以从 <span class="math inline">\((x_1,y_1)\)</span> 无代价转移到 <span class="math inline">\((x_2,y_2)\)</span>，求需要行走的最少距离</p>
<p><span class="math inline">\(N\le10^9,P\le 10^5\)</span></p>
</blockquote>
<a id="more"></a>
<h2 id="思路">思路</h2>
<h3 id="问题转化">问题转化</h3>
<p><span class="math inline">\(O(N^2)\)</span> 和 <span class="math inline">\(O(P^2)\)</span> 的最短路都显然不行，我们可以观察一些性质并考虑 dp。</p>
<p>每次答案距离只能从左下方转移而来，即 <span class="math inline">\(f(x_1,y_1)\rightarrow f(x_2,y_2)\)</span> 满足 <span class="math inline">\(x1\le x_2,y1\le y_2\)</span>。</p>
<p>直接 dp 需要考虑不从跳板走的距离，正难则反，我们设 <span class="math inline">\(f(x,y)\)</span> 表示走到 <span class="math inline">\((x,y)\)</span> 能够省下的最大距离。</p>
<p>我们需要维护 <span class="math inline">\(x1\le x_2,y1\le y_2\)</span> 的最大 <span class="math inline">\(f(x_1,y_1)\)</span>，至此我们将问题转化成二维偏序。</p>
<h3 id="cdq">CDQ</h3>
<p>现在的问题是，每个跳板有两个端点：起点 <span class="math inline">\((x_1,y_1)\)</span> 和终点 <span class="math inline">\((x_2,y_2)\)</span>，并且只能从前一个终点转移到其右上方的一个起点。</p>
<p>我们可以把一个跳板拆成两个点，起点作为查询，终点作为修改。</p>
<p>接下来就是 CDQ 的套路：处理左区间，更新左区间对右区间的贡献，处理右区间，一定要保证分治的先后顺序正确。</p>
<p>复杂度 <span class="math inline">\(O(nlog^2n)\)</span>。</p>
<h3 id="细节">细节</h3>
<p>写完交上去一直 WA 一个点，还下不了数据急躁半天。</p>
<p>后来想到，可能会有某个跳板的终点的另一个跳板的起点重合，排序不当会处理不了。</p>
<p>可以输入时提前处理掉，或者排序时保证位置重合的修改在询问之前就行（具体见代码的 cmp 函数）。</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TT&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(TT &amp;x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x1, y1, x2, y2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, opt, id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, cnt;</span><br><span class="line"><span class="keyword">int</span> f[N], ans[N], len[N];</span><br><span class="line">Node a[N];</span><br><span class="line">Point p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc_dis</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x2 - x1 + y2 - y1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp_x</span><span class="params">(<span class="keyword">const</span> Point &amp;i, <span class="keyword">const</span> Point &amp;j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i.x == j.x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i.y == j.y) <span class="keyword">return</span> i.opt &gt; j.opt;<span class="comment">// 位置重合，让修改在前</span></span><br><span class="line">        <span class="keyword">return</span> i.y &lt; j.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i.x &lt; j.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp_y</span><span class="params">(<span class="keyword">const</span> Point &amp;i, <span class="keyword">const</span> Point &amp;j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i.y == j.y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i.x == j.x) <span class="keyword">return</span> i.opt &gt; j.opt;</span><br><span class="line">        <span class="keyword">return</span> i.x &lt; j.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i.y &lt; j.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    CDQ(l, mid), sort(p+mid+<span class="number">1</span>, p+r+<span class="number">1</span>, cmp_y);</span><br><span class="line">    <span class="keyword">int</span> maxn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid+<span class="number">1</span>, j = l, k = <span class="number">-1</span>; i &lt;= r; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i].opt) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> id = p[i].id;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= mid &amp;&amp; p[j].y &lt;= p[i].y) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[j].opt)</span><br><span class="line">                maxn = max(maxn, ans[p[j].id]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[p[i].id] = max(ans[p[i].id], maxn + len[p[i].id]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(p+mid+<span class="number">1</span>, p+r+<span class="number">1</span>, cmp_x);</span><br><span class="line">    CDQ(mid+<span class="number">1</span>, r);</span><br><span class="line">    sort(p+l, p+r+<span class="number">1</span>, cmp_y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        read(a[i].x1), read(a[i].y1), read(a[i].x2), read(a[i].y2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        p[++cnt] = (Point)&#123;a[i].x1, a[i].y1, <span class="number">0</span>, i&#125;, p[++cnt] = (Point)&#123;a[i].x2, a[i].y2, <span class="number">1</span>, i&#125;;</span><br><span class="line">    p[++cnt] = (Point)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, p[++cnt] = (Point)&#123;n, n, <span class="number">0</span>, m+<span class="number">1</span>&#125;;</span><br><span class="line">    sort(p+<span class="number">1</span>, p+cnt+<span class="number">1</span>, cmp_x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        len[i] = calc_dis(a[i].x1, a[i].y1, a[i].x2, a[i].y2);</span><br><span class="line">    CDQ(<span class="number">1</span>, cnt);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n + n - ans[m+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title>总结 exBSGS</title>
    <url>/2020/08/15/2020-08-15-%E6%80%BB%E7%BB%93-exBSGS/</url>
    <content><![CDATA[<p>求解 <span class="math inline">\(a^x\equiv b\pmod p\)</span> 其中 p 不为质数情况的算法。</p>
<a id="more"></a>
<p>需要提前掌握 <a href="https://renamoe.gitee.io/2020/02/06/2020-02-06-%E6%80%BB%E7%BB%93-BSGS/">BSGS</a>。</p>
<p>模板题：<a href="https://www.luogu.com.cn/problem/P4195">Luogu P4195</a>。</p>
<h2 id="思路">思路</h2>
<p>p 不为质数时，我们需要让 <span class="math inline">\(\gcd(a, p)=1\)</span> 才能进行朴素 BSGS。</p>
<p>对于 <span class="math display">\[
a^x\equiv b\pmod p
\]</span> 设 <span class="math inline">\(d=\gcd(a,p)\)</span>， <span class="math display">\[
a^{x-1}\times a\equiv b \pmod p\\
a^{x-1}\times \frac{a}{d}\equiv \frac{b}{d} \pmod{\frac{p}{d}}\\
a^{x-1}\equiv \frac{\frac{b}{d}}{\frac{a}{d}}\pmod{\frac{p}{d}}
\]</span> 若 <span class="math inline">\(\gcd(a^{x-1},\frac{p}{d})\neq 1\)</span>，循环下去，直到 a,p 互质，进行朴素 BSGS 即可。</p>
<p>需要注意，若在过程中出现 <span class="math inline">\(d\not\mid b\)</span> 即无解。</p>
<p>另外，如果循环第 k 次时 <span class="math display">\[
a^{x-1}\equiv \frac{\frac{b}{d}}{\frac{a}{d}}\equiv 1\pmod{\frac{p}{d}}
\]</span> 此时 <span class="math inline">\(x-1=0\)</span>，最后答案为 k。</p>
<h2 id="实现">实现</h2>
<p>直接做的话，要求 <span class="math inline">\(\frac{a}{d}\)</span> 在模 <span class="math inline">\(\frac{p}{d}\)</span> 意义下的逆元，<span class="math inline">\(\frac{p}{d}\)</span> 不为质数，需要 exgcd 求逆元。</p>
<p>不写 exgcd 实现的话，设 <span class="math inline">\(c=\frac{a}{d}\)</span>，转化到 BSGS 中现在要求解 <span class="math inline">\(a^x\equiv \frac{b}{c}\pmod p\)</span>，将 c 乘到左边后做。</p>
<p>所以只要把 <span class="math inline">\(\frac{a}{d}\)</span> 传入 BSGS 就行。</p>
<h3 id="exbsgs-code">exBSGS code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">exBSGS</span><span class="params">(LL a, LL b, LL p)</span> </span>&#123;</span><br><span class="line">    a %= p, b %= p;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">1</span> || p == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 特判</span></span><br><span class="line">    LL d, cnt = <span class="number">0</span>, ad = <span class="number">1</span>; <span class="comment">// 分别是gcd(a,p)，循环次数，a/d</span></span><br><span class="line">    <span class="keyword">while</span> ((d = gcd(a, p)) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b % d) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        cnt++, b /= d, p /= d, ad = ad * a / d % p;</span><br><span class="line">        <span class="keyword">if</span> (ad == b) <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans = BSGS(a, b, p, ad);</span><br><span class="line">    <span class="keyword">return</span> ans == <span class="number">-1</span> ? <span class="number">-1</span> : ans + cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="luogu-p4195-code">luogu P4195 code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> RenaMoe &#123;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;LL, LL&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">power</span><span class="params">(LL a, LL b, LL p)</span> </span>&#123;</span><br><span class="line">    LL ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = ans * a % p;</span><br><span class="line">        a = a * a % p, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">BSGS</span><span class="params">(LL a, LL b, LL p, LL ad)</span> </span>&#123;</span><br><span class="line">    mp.clear();</span><br><span class="line">    b %= p;</span><br><span class="line">    <span class="keyword">if</span> (a % p == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL t = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(p)), an = b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= t; ++i)</span><br><span class="line">        mp[an] = i, an = an * a % p;</span><br><span class="line">    a = power(a, t, p), an = ad;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j; i &lt;= t; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mp.count(an)) &#123;</span><br><span class="line">            j = mp[an];</span><br><span class="line">            <span class="keyword">if</span> (i * t - j &gt;= <span class="number">0</span>) <span class="keyword">return</span> i * t - j;</span><br><span class="line">        &#125;</span><br><span class="line">        an = an * a % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL x, LL y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y ? gcd(y, x % y) : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">exBSGS</span><span class="params">(LL a, LL b, LL p)</span> </span>&#123;</span><br><span class="line">    a %= p, b %= p;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">1</span> || p == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    LL d, cnt = <span class="number">0</span>, ad = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((d = gcd(a, p)) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b % d) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        cnt++, b /= d, p /= d, ad = ad * a / d % p;</span><br><span class="line">        <span class="keyword">if</span> (ad == b) <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans = BSGS(a, b, p, ad);</span><br><span class="line">    <span class="keyword">return</span> ans == <span class="number">-1</span> ? <span class="number">-1</span> : ans + cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LL a, p, b;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        read(a), read(p), read(b);</span><br><span class="line">        <span class="keyword">if</span> (!a &amp;&amp; !b &amp;&amp; !p) <span class="keyword">break</span>;</span><br><span class="line">        LL ans = exBSGS(a, b, p);</span><br><span class="line">        <span class="keyword">if</span> (ans == <span class="number">-1</span>) <span class="built_in">puts</span>(<span class="string">&quot;No Solution&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RenaMoe::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Math</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>BSGS</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 CRT &amp; exCRT</title>
    <url>/2020/08/15/2020-08-15-%E6%9D%BF%E5%AD%90-CRT-exCRT/</url>
    <content><![CDATA[<p>大概写写中国剩余定理的公式和扩展中国剩余定理板子。</p>
<a id="more"></a>
<h2 id="中国剩余定理-crt">中国剩余定理 CRT</h2>
<p>对于一元线性同余方程组： <span class="math display">\[
\begin{cases}
    x\equiv a_1\pmod{m_1}\\
    x\equiv a_2\pmod{m_2}\\
    ……\\
    x\equiv a_n\pmod{m_n}
\end{cases}
\]</span> x 的最小非负整数解，其中 <span class="math inline">\(m_i\)</span> 两两互质。</p>
<p>该方程组的通解为： <span class="math display">\[
\begin{aligned}
M&amp;=\prod_{i=1}^nm_i\\
M_i&amp;=\frac{M}{m_i}\\
t_i&amp;\equiv M_i^{-1}\pmod{m_i}\\
x&amp;\equiv \sum_{i=1}^n{a_it_iM_i\pmod M}
\end{aligned}
\]</span></p>
<p>x 最小的话，<span class="math inline">\(t_i\)</span> 最小，要在用 exgcd 求解 <span class="math inline">\(M_i^{-1}\)</span> 时保证 <span class="math inline">\(t_i\)</span> 最小。</p>
<h2 id="扩展中国剩余定理-excrt">扩展中国剩余定理 exCRT</h2>
<p>同样是一元线性同余方程组，不过 <span class="math inline">\(m_i\)</span> 不再两两互质了。</p>
<p>考虑将方程两两合并。</p>
<p><span class="math display">\[
\begin{cases}
x\equiv a\pmod{m}\\
x\equiv A\pmod{M}
\end{cases}
\]</span> 即 <span class="math display">\[
\begin{cases}
x=my+a\\
x=MY+A
\end{cases}
\]</span> <span class="math display">\[
\begin{aligned}
my+a&amp;=MY+A\\
my-MY&amp;=A-a
\end{aligned}
\]</span> 通过 exgcd 求出 y 关于 <span class="math inline">\(my+M(-Y)=\gcd(m,M)\)</span> 的解 <span class="math inline">\(y_0\)</span>，那么 y 的特定解为 <span class="math inline">\(y_0\times\frac{A-a}{\gcd(n,M)}\)</span>。</p>
<p>因为要最小化 x，所以要最小化 y。</p>
<p>y 在 exgcd 中通解为 <span class="math inline">\(y_0+\frac{M}{\gcd(m,M)}\)</span>，所以要最小值为 <span class="math display">\[
y=y_0\times\frac{A-a}{\gcd(n,M)}\bmod \frac{M}{\gcd(m,M)}
\]</span></p>
<p>两个同余方程合并为 <span class="math display">\[
x\equiv my+a\pmod{\operatorname{lcm}(m,M)}
\]</span></p>
<h3 id="excrt-code">exCRT code</h3>
<p>模板题 <a href="https://www.luogu.com.cn/problem/P4777">Luogu P4777</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">exCRT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ai 为 a，bi 为 m</span></span><br><span class="line">    LL ans = ai[<span class="number">1</span>], mod = bi[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        LL g, x, y, bg, a = ai[i], b = bi[i], c;</span><br><span class="line">        exgcd(mod, b, x, y, g);</span><br><span class="line">        c = (a - ans % b + b);</span><br><span class="line">        <span class="keyword">if</span> (c % g) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        x = mul(x, c/g, b/g); <span class="comment">// 防爆long long的快速乘</span></span><br><span class="line">        ans += x * mod;</span><br><span class="line">        mod = lcm(mod, b);</span><br><span class="line">        ans = (ans % mod + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Math</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>CRT</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 GarsiaWachs算法</title>
    <url>/2020/08/18/2020-08-18-%E6%9D%BF%E5%AD%90-GarsiaWachs%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>专门用来解决石子合并问题的算法。</p>
<a id="more"></a>
<p><a href="https://www.luogu.com.cn/problem/P5569">P5569 「SDOI2008」石子合并</a></p>
<p>数据范围：<span class="math inline">\(n\le 4\times 10^4\)</span>。</p>
<h2 id="做法">做法</h2>
<ul>
<li>找到最小的 i 满足 <span class="math inline">\(a_{i-1}&lt;a_{i+1}\)</span></li>
<li>合并 <span class="math inline">\(a_{i-1},a_i\)</span></li>
<li>找到最大的 j 满足 <span class="math inline">\(j &lt; k\)</span> 并且 <span class="math inline">\(a_j &gt; a_{i-1} + a_i\)</span></li>
<li>将 i-1,i 合并后的石子插入到 j 后面</li>
</ul>
<p>通过 vector 模拟，直到合并为一个元素。</p>
<p>注意处理边界 <span class="math inline">\(a_0=a_{n+1}=\infty\)</span>。</p>
<p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>，需要开 O2 才能过 qwq。</p>
<p>证明见 <a href="https://eastern.blog.luogu.org/post-ti-xie-garsiawachs-suan-fa">Eastern 的博客</a>。</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> RenaMoe &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(TT &amp;x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ans;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    a.push_back(INF);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; ++i)</span><br><span class="line">        read(x), a.push_back(x);</span><br><span class="line">    a.push_back(INF);</span><br><span class="line">    <span class="keyword">int</span> i, j, sum;</span><br><span class="line">    <span class="keyword">while</span> (n-- &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (a[i<span class="number">-1</span>] &lt; a[i+<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        sum = a[i<span class="number">-1</span>] + a[i];</span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; ~j; --j)</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; sum)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        a.erase(a.begin() + i - <span class="number">1</span>);</span><br><span class="line">        a.erase(a.begin() + i - <span class="number">1</span>);</span><br><span class="line">        a.insert(a.begin() + j + <span class="number">1</span>, sum);</span><br><span class="line">        ans += sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RenaMoe::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 LOJ#6500 「雅礼集训 2018 Day2」操作</title>
    <url>/2020/08/18/2020-08-18-%E9%A2%98%E8%A7%A3-LOJ-6500/</url>
    <content><![CDATA[<blockquote>
<p>给出一串 01 序列和正整数 k，一次操作将长度为 k 的子区间取反，m 次询问一个区间内全部变为 0 的最小操作次数，不可能完成输出 -1。</p>
<p><span class="math inline">\(1\le n\le 2\times 10^6,1\le m\le 5\times 10^5\)</span></p>
</blockquote>
<a id="more"></a>
<p>很考验问题转化的题。</p>
<h2 id="思路">思路</h2>
<h3 id="暴力">暴力</h3>
<p>原题 <span class="math inline">\(O(n^2)\)</span> 暴力有 30 分，翻转策略是从左向右扫，遇到 1 就将以它为左端点且长为 k 的区间取反。</p>
<p>至于正确性，显然该位左侧的点不能再被取反。</p>
<p>运用差分（异或意义下）可以将区间取反降到 <span class="math inline">\(O(1)\)</span>。</p>
<h3 id="正解">正解</h3>
<p>观察差分序列，我们暴力中每次会把距离为 k 的两个点取反。</p>
<p>我们将询问区间提取出来，左右侧加上 0，再差分，观察：</p>
<blockquote>
<p>原序列：0100011010</p>
<p>提取 [7, 9]：0 101 0</p>
<p>差分：01111</p>
</blockquote>
<p>当 k 为 2 时，该例需要两步（即[7,8]、[8,9]）。</p>
<p>问题转化成在这样的差分序列中，每次将距离为 k 的两个点取反，需要的最小操作次数。</p>
<h4 id="判断有解">判断有解</h4>
<p>可以得到，只有在编号模 k 值相同的位置中，1 的个数为偶数个，问题有解。</p>
<p>可以用<strong>哈希</strong> <span class="math inline">\(O(1)\)</span> 判断是否有解：</p>
<p>对编号模 k 值相同的位置赋一个 hash 值，然后对所有 1 做前缀异或和。</p>
<p>因为异或的性质，某个 hash 值有偶数个，异或起来为 0。</p>
<p>那么提取区间异或和即可判断是否有解。</p>
<h4 id="计算答案">计算答案</h4>
<p>现在要计算最小操作次数，易得我们需要将编号模 k 值相同的位置中，所有的 1 相邻两两配对。</p>
<p>答案就是每对位置差除以 k。</p>
<p>我们还是对这些答案做<strong>前缀和</strong>，以便 <span class="math inline">\(O(1)\)</span> 查询。</p>
<p>需要注意的是，两两配对的点中，做前缀和的话，如果有偶数个点那么恰好为答案；如果有奇数个点，要考虑到两个前缀和做差形成偶数个点的情况。</p>
<p>具体实现看预处理代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b[] 模k值相同的位置的前缀答案</span></span><br><span class="line"><span class="comment">// sum[] 所有位置的前缀答案</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    sum[i] = sum[i<span class="number">-1</span>];</span><br><span class="line">    hsum[i] = hsum[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span> (a[i] ^ a[i<span class="number">-1</span>]) &#123;</span><br><span class="line">        hsum[i] ^= hash[i%k];</span><br><span class="line">        <span class="comment">// 以下是重点</span></span><br><span class="line">        sum[i] -= b[i%k];</span><br><span class="line">        b[i%k] = i / k - b[i%k];</span><br><span class="line">        sum[i] += b[i%k];</span><br><span class="line">        <span class="comment">// 如果有偶数个点，b[i%k]值为两两距离差除以k，即答案</span></span><br><span class="line">        <span class="comment">// 如果有奇数个点，b[i%k]值为i/k-原b[i%k]，即该位置减去之前的答案</span></span><br><span class="line">        <span class="comment">// 手模可以发现，这样子两个奇数点前缀和相减，配对情况恰好错开，值为新配对的答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里多记录两个值以便后续处理左右端点的影响</span></span><br><span class="line">    bb[i] = b[i%k];</span><br><span class="line">    br[i] = b[(i+<span class="number">1</span>)%k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="左右端点的影响">左右端点的影响</h4>
<p>因为提取区间要让区间左右侧为 0，前缀和中并没有考虑。</p>
<blockquote>
<p>原序列：0100011010</p>
<p>提取 [7, 9] 的差分：</p>
<p>000000 1111 0</p>
<p>原序列 [7,9] 差分：</p>
<p>011001 0111 0</p>
</blockquote>
<p>因为我们提取之后让区间左侧都变为 0，所以差分序列中第 7 位是不同的。</p>
<p>询问区间 <span class="math inline">\([l,r]\)</span> 中，如果 l 处原来为 1，那么提取后的差分序列中该处一定为 1；同理，r 处为 1，那么差分序列中 r+1 处一定为 1。</p>
<p>其它地方的差分和预处理的就一样了。</p>
<p>那么就先通过预处理的计算 <span class="math inline">\([l+1,r]\)</span> 的答案，再把端点的影响加进去。</p>
<p>因此预处理时要多记录当前答案状态，最后加入方法和预处理一样。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bb[] 预处理中第i位的答案</span></span><br><span class="line"><span class="comment">// br[] 预处理中第i+1位的答案</span></span><br><span class="line"><span class="keyword">int</span> ans = sum[r] - sum[l];</span><br><span class="line"><span class="keyword">int</span> h = hsum[r] ^ hsum[l];</span><br><span class="line"><span class="keyword">if</span> (a[l]) &#123;</span><br><span class="line">    ans += bb[l] * <span class="number">2</span> - l / k;</span><br><span class="line">    h ^= hash[l%k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[r]) &#123;</span><br><span class="line">    ans += (r + <span class="number">1</span>) / k - <span class="number">2</span> * br[r];</span><br><span class="line">    h ^= hash[(r+<span class="number">1</span>)%k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> RenaMoe &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(TT &amp;x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k, m;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N], bb[N], br[N], hash[N], hsum[N], sum[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    read(n), read(k), read(m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) </span><br><span class="line">        hash[i] = (rand() % <span class="number">32767</span> * <span class="number">100000</span>) + (rand() % <span class="number">32767</span>); <span class="comment">// 这是什么辣鸡random方法啊</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = s[i] == <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        sum[i] = sum[i<span class="number">-1</span>];</span><br><span class="line">        hsum[i] = hsum[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span> (a[i] ^ a[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            hsum[i] ^= hash[i%k];</span><br><span class="line">            sum[i] -= b[i%k];</span><br><span class="line">            b[i%k] = i / k - b[i%k];</span><br><span class="line">            sum[i] += b[i%k];</span><br><span class="line">        &#125;</span><br><span class="line">        bb[i] = b[i%k];</span><br><span class="line">        br[i] = b[(i+<span class="number">1</span>)%k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        read(l), read(r);</span><br><span class="line">        <span class="keyword">int</span> ans = sum[r] - sum[l];</span><br><span class="line">        <span class="keyword">int</span> h = hsum[r] ^ hsum[l];</span><br><span class="line">        <span class="keyword">if</span> (a[l]) &#123;</span><br><span class="line">            ans += bb[l] * <span class="number">2</span> - l / k;</span><br><span class="line">            h ^= hash[l%k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[r]) &#123;</span><br><span class="line">            ans += (r + <span class="number">1</span>) / k - <span class="number">2</span> * br[r];</span><br><span class="line">            h ^= hash[(r+<span class="number">1</span>)%k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, h ? <span class="number">-1</span> : ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RenaMoe::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>思想</category>
      </categories>
      <tags>
        <tag>差分/前缀和</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title>总结 计算几何基础</title>
    <url>/2020/08/22/2020-08-22-%E6%80%BB%E7%BB%93-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>记录一些计算几何相关的知识。</p>
<a id="more"></a>
<p>推荐学习资料：<a href="https://www.luogu.com.cn/blog/wjyyy/geometry1">wjyyy 的博客</a> 。</p>
<h2 id="向量">向量</h2>
<h3 id="模">模</h3>
<p>向量的长度，<span class="math inline">\(\vec{a}=(x,y),|\vec{a}|=\sqrt{x^2+y^2}\)</span>。</p>
<h3 id="加减">加减</h3>
<p>几何意义为两个向量 <span class="math inline">\(\vec{a},\vec{b}\)</span> （线段）首尾相接，<span class="math inline">\(\vec{a}\)</span> 的头指向 <span class="math inline">\(\vec{b}\)</span> 的尾即 <span class="math inline">\(\vec{a}+\vec{b}\)</span>。</p>
<p>对于 <span class="math inline">\(\vec{a}=(x_1,y_1),\vec{b}=(x_2,y_2)\)</span>，<span class="math inline">\(\vec{a}+\vec{b}=(x_1+y_1,x_2+y_2)\)</span>。</p>
<h3 id="数乘">数乘</h3>
<p>对向量缩放。对于 <span class="math inline">\(\vec{a}=(x,y)\)</span>，<span class="math inline">\(\lambda\vec{a}=(\lambda x,\lambda y)\)</span>。</p>
<h3 id="点积数量积内积">点积（数量积、内积）</h3>
<p>几何意义为向量 <span class="math inline">\(\vec{a}\)</span> 在向量 <span class="math inline">\(\vec{b}\)</span> 上的投影再乘上向量 <span class="math inline">\(\vec{b}\)</span> 的模长。</p>
<p>点积是一个实数，设 <span class="math inline">\(\theta\)</span> 为 <span class="math inline">\(\vec{a},\vec{b}\)</span> 的夹角，<span class="math inline">\(\vec{a}\cdot \vec{b}=|\vec{a}||\vec{b}|\cos\theta\)</span>。</p>
<p>对于 <span class="math inline">\(\vec{a}=(x_1,y_1),\vec{b}=(x_2,y_2)\)</span>，<span class="math inline">\(\vec{a}\cdot\vec{b}=x_1x_2+x_2y_2\)</span>。</p>
<p>点积满足交换律。</p>
<h3 id="叉积外积">叉积（外积）</h3>
<p>几何意义为两个向量平行四边形法围成的有向面积。</p>
<p>叉积是一个伪向量（所以当成实数好了），设 <span class="math inline">\(\theta\)</span> 为 <span class="math inline">\(\vec{a},\vec{b}\)</span> 的夹角，<span class="math inline">\(\vec{a}\cdot \vec{b}=|\vec{a}||\vec{b}|\sin\theta\)</span>。</p>
<p>对于 <span class="math inline">\(\vec{a}=(x_1,y_1),\vec{b}=(x_2,y_2)\)</span>，<span class="math inline">\(\vec{a}\cdot\vec{b}=x_1y_2-x_2y_1\)</span>。</p>
<hr />
<p>咕咕咕。。。</p>
]]></content>
      <categories>
        <category>总结</category>
        <category>Math</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 bzoj#2395 [Balkan 2011]Timeismoney</title>
    <url>/2020/08/23/2020-08-23-%E9%A2%98%E8%A7%A3-bzoj2395-Balkan-2011Timeismoney/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://darkbzoj.tk/problem/2395">题面</a></p>
<p>给出一个 n 点 m 边的无向图，每个边有权值 <span class="math inline">\(c_i,t_i\)</span>，求出一个生成树使最小化： <span class="math display">\[
(\sum_{i=1}^m c_i)\times(\sum_{i=1}^m t_i)
\]</span> <span class="math inline">\(1\le n\le 200,1\le m\le 1\times 10^4\)</span></p>
</blockquote>
<a id="more"></a>
<h2 id="思路">思路</h2>
<p>不同寻常的最小生成树。</p>
<h3 id="转化题意">转化题意</h3>
<p>先对于所有生成树的答案，设 <span class="math inline">\(C=\sum c_i,T=\sum t_i\)</span>，把他们表示成一个二维平面上若干个点（x 表示 C，y 表示 T）。</p>
<p>那么要最小化 <span class="math inline">\(C\times T\)</span>，就是用一个曲线 <span class="math inline">\(y=\frac{C\times T}{x}\)</span> 在这些点中取值，答案点一定在这些点的<strong>左下凸壳</strong>上。</p>
<p>接下来就是考虑怎么求出所有左下凸壳上的点来更新答案。</p>
<h3 id="分治">分治</h3>
<p>先考虑凸壳上的极值：C 最小时，该点表示以 c 为边权做最小生成树的答案；T 最小时，该点表示以 t 为边权做最小生成树的答案。</p>
<p>设以上两个点为 P,Q，我们把 P,Q 相连，然后找到点 S 使得 <span class="math inline">\(S_{\triangle PQS}\)</span> <strong>最大</strong>，则 S 一定在凸壳上。</p>
<p><img src="https://s1.ax1x.com/2020/08/23/d0OmuQ.png" /></p>
<p>利用<strong>叉积</strong>来求三角形面积的话，已知 <span class="math inline">\(P=(x_1,y_1),Q=(x_2,y_2),S=(x,y)\)</span>： <span class="math display">\[
\begin{align}
2S_{\triangle PQS}&amp;=\vec{PS}\times\vec{PQ}\\
&amp;=(x-x_1,y-y_1)\times(x_2-x_1,y_2-y_1)\\
&amp;=(x-x_1)(y_2-y_1)-(x_2-x_1)(y-y_1)\\
&amp;=(y_2-y_1)x-(x_2-x_1)y-(y_2-y_1)x_1+(x_2-x_1)y_1
\end{align}
\]</span> 忽略后面两项常数，可以转化成<strong>最小化</strong> <span class="math inline">\((x_2-x_1)y-(y_2-y_1)x\)</span>。</p>
<p>那么把所有边权重新赋为 <span class="math inline">\((x_2-x_1)t-(y_2-y_1)c\)</span>，跑一边最小生成树即可找到点 S。</p>
<p>以 S 划分，分治下去即可。</p>
<p>注意<strong>边界</strong>：如果找到的点 S 在 PQ 直线上方（通过叉积判断），那么凸壳上 P,Q 相邻，不再分治。</p>
<h3 id="复杂度">复杂度</h3>
<p>不是很懂，<del>O(能过)</del>。</p>
<p><img src="https://s1.ax1x.com/2020/08/23/d0xTFs.png" /></p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> RenaMoe &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(TT &amp;x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    LL c, t, val;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Edge &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> val &lt; t.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    LL x, y;</span><br><span class="line">    Point() &#123;&#125;</span><br><span class="line">    Point(LL _x, LL _y) : x(_x), y(_y) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Point &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x * y == t.x * t.y ? x &lt; t.x : x * y &lt; t.x * t.y;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> -(<span class="keyword">const</span> Point &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - t.x, y - t.y);</span><br><span class="line">    &#125;</span><br><span class="line">    LL <span class="keyword">operator</span> *(<span class="keyword">const</span> Point &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x * t.y - y * t.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">Point ans;</span><br><span class="line"><span class="keyword">int</span> fa[N];</span><br><span class="line">Edge e[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Point <span class="title">Kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">re</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    sort(e+<span class="number">1</span>, e+m+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = find(e[i].x), y = find(e[i].y);</span><br><span class="line">        <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">            fa[x] = y;</span><br><span class="line">            re.x += e[i].c, re.y += e[i].t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// l: P,  r: Q,  mid: S </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(Point l, Point r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        e[i].val = e[i].t * (r.x - l.x) - e[i].c * (r.y - l.y);</span><br><span class="line">    Point mid = Kruskal();</span><br><span class="line">    <span class="keyword">if</span> ((mid - l) * (r - l) &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    ans = min(ans, mid);</span><br><span class="line">    solve(l, mid), solve(mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; ++i) &#123;</span><br><span class="line">        read(u), read(v), read(e[i].c), read(e[i].t);</span><br><span class="line">        e[i].x = u + <span class="number">1</span>, e[i].y = v + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) e[i].val = e[i].c;</span><br><span class="line">    Point l = Kruskal();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) e[i].val = e[i].t;</span><br><span class="line">    Point r = Kruskal();</span><br><span class="line">    ans = min(l, r);</span><br><span class="line">    solve(l, r);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>, ans.x, ans.y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RenaMoe::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图论</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
        <tag>最小生成树</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF1117G Recursive Queries</title>
    <url>/2020/08/24/2020-08-24-%E9%A2%98%E8%A7%A3-CF1117G-Recursive-Queries/</url>
    <content><![CDATA[<blockquote>
<p>给出一个长为 n 的排列，每次给出询问 <span class="math inline">\([l_i,r_i]\)</span>（可以离线），求 <span class="math inline">\(f(l_i,r_i)\)</span>： <span class="math display">\[
f(l,r)=\begin{cases}
(r-l+1)+f(l,m_{l,r}-1)+f(m_{l,r}+1,r)\quad &amp;(l\le r)\\
0\quad &amp;(l &gt; r)
\end{cases}
\]</span></p>
<p><span class="math inline">\(m_{l,r}\)</span> 为 <span class="math inline">\([l,r]\)</span> 的最大值的位置。</p>
</blockquote>
<a id="more"></a>
<h2 id="思路">思路</h2>
<h3 id="转化题意">转化题意</h3>
<p>给出的式子应该很好理解吧，就是区间最大值将区间分开，递归下去。</p>
<p>那么一个区间的最大值也就代表这个区间，其贡献为区间长度。</p>
<p>最后该区间的答案就是每个点的贡献之和。</p>
<p>设 i 左边第一个大于 <span class="math inline">\(a_i\)</span> 的位置为 <span class="math inline">\(lb(i)\)</span>，右边第一个大于 <span class="math inline">\(a_i\)</span> 的位置为 <span class="math inline">\(rb(i)\)</span>，（若无该位置，<span class="math inline">\(lb(i)=0,rb(i)=n+1\)</span>）。</p>
<p>其实就是要统计：</p>
<p><span class="math display">\[
\sum_{i=l}^r\min(rb(i)-1,r)-\max(lb(i)+1,l)+1
\]</span></p>
<h3 id="预处理-lbirbi">预处理 <span class="math inline">\(lb(i),rb(i)\)</span></h3>
<p>利用<strong>单调栈</strong> <span class="math inline">\(O(n)\)</span> 处理即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (top &amp;&amp; a[stk[top]] &lt; a[i])</span><br><span class="line">        rb[stk[top--]] = i;</span><br><span class="line">    lb[i] = stk[top];</span><br><span class="line">    stk[++top] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (top) rb[stk[top--]] = n + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="离线统计">离线统计</h3>
<p>现将每个点的贡献<strong>拆开</strong>，分别统计 <span class="math inline">\(lb(i),rb(i)\)</span>，需要区间求和。</p>
<p>以统计 <span class="math inline">\(lb(i)\)</span> 为例：</p>
<p>注意到如果 <span class="math inline">\(i\in [l,r],lb(i)+1&lt;l\)</span>，该点贡献为 <span class="math inline">\(l\)</span>。</p>
<p>我们将所有询问离线下来，固定 l，对每个 r 区间求和。</p>
<p>每次向右移动 l，所有 <span class="math inline">\(lb(i)=l\)</span> 的位置的贡献都应该改为 l。</p>
<p>那么就把这些位置去掉贡献，打上 tag，每次统计答案时，统计区间有 tag 的个数另外计算。</p>
<p>单点修改，区间查询，开两棵<strong>树状数组</strong>分别维护 <span class="math inline">\(lb(i)\)</span> 的贡献和 tag 个数。</p>
<p>统计 <span class="math inline">\(rb(i)\)</span> 的贡献同理，<strong>倒着</strong>做就行。</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> RenaMoe &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(TT &amp;x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ask</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[N], lb[N], rb[N], stk[N];</span><br><span class="line">LL ans[N];</span><br><span class="line">Ask q[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; qry[N], del[N]; <span class="comment">// qry[i]：左端点为i的询问，del[i]：lb为i的位置</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bit</span> &#123;</span></span><br><span class="line">    LL tr[N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(tr, <span class="number">0</span>, <span class="keyword">sizeof</span> tr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, LL k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += i &amp; -i)</span><br><span class="line">            tr[i] += k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        LL re = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i -= i &amp; -i)</span><br><span class="line">            re += tr[i];</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; tr1, tr2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) read(q[i].l);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) read(q[i].r);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单调栈求lb[i],rb[i]</span></span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &amp;&amp; a[stk[top]] &lt; a[i])</span><br><span class="line">            rb[stk[top--]] = i;</span><br><span class="line">        <span class="keyword">if</span> (top) lb[i] = stk[top];</span><br><span class="line">        stk[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (top) rb[stk[top--]] = n + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        del[lb[i]].push_back(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        qry[q[i].l].push_back(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        tr1.update(i, lb[i]); <span class="comment">// 注意+1-1的细节</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 清除贡献，打tag</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; del[i<span class="number">-1</span>].size(); ++j) &#123;</span><br><span class="line">            tr1.update(del[i<span class="number">-1</span>][j], -lb[del[i<span class="number">-1</span>][j]]);</span><br><span class="line">            tr2.update(del[i<span class="number">-1</span>][j], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; qry[i].size(); ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = qry[i][j];</span><br><span class="line">            ans[id] -= tr1.query(q[id].r) - tr1.query(q[id].l<span class="number">-1</span>);</span><br><span class="line">            ans[id] -= (LL)(i - <span class="number">1</span>) * (tr2.query(q[id].r) - tr2.query(q[id].l<span class="number">-1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">        del[i].clear(), qry[i].clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        del[rb[i]].push_back(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        qry[q[i].r].push_back(i);</span><br><span class="line">    tr1.clear(), tr2.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        tr1.update(i, rb[i]<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; del[i+<span class="number">1</span>].size(); ++j) &#123;</span><br><span class="line">            tr1.update(del[i+<span class="number">1</span>][j], -rb[del[i+<span class="number">1</span>][j]]+<span class="number">1</span>);</span><br><span class="line">            tr2.update(del[i+<span class="number">1</span>][j], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; qry[i].size(); ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = qry[i][j];</span><br><span class="line">            ans[id] += tr1.query(q[id].r) - tr1.query(q[id].l<span class="number">-1</span>);</span><br><span class="line">            ans[id] += (LL)i * (tr2.query(q[id].r) - tr2.query(q[id].l<span class="number">-1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, ans[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P3953 逛公园</title>
    <url>/2020/08/24/2020-08-24-%E9%A2%98%E8%A7%A3-P3953-%E9%80%9B%E5%85%AC%E5%9B%AD/</url>
    <content><![CDATA[<blockquote>
<p>给出 n 点 m 边的有向图，设 1 点到 n 点最短路为 d，求长度小于等于 d+k 的路线方案数。</p>
<p><span class="math inline">\(n\le 10^5,m\le 2\times 10^5,k\le50\)</span>，每条边边权为<strong>非负</strong>整数。</p>
<p>若方案数无穷，输出 -1。</p>
</blockquote>
<a id="more"></a>
<p>因为 0 环的问题，这题绝大部分题解都假了，<a href="https://www.luogu.com.cn/blog/salix-leaf/solution-p3953">详情看这里</a>。</p>
<h2 id="思路">思路</h2>
<h3 id="分层图">分层图</h3>
<p>先预处理以 1 和 n 为起点的单源最短路。</p>
<p>考虑 dp，设 <span class="math inline">\(f[u][i]\)</span> 表示 1 到 u 路径比原先最短路长度多出 i 的方案数。</p>
<p>对于每条边 <span class="math inline">\(E_{u\rightarrow v}\)</span>，<span class="math inline">\(f[v][i+dis_u+val_E-dis_v]\Longleftarrow f[u][i]\)</span>。</p>
<p>可以发现每条边上的转移 <span class="math inline">\(dis_u+val_E-dis_v\)</span> 是定值，于是把 dp 转化到分层图上。</p>
<p>在分层图上拓扑 dp，答案就是 <span class="math inline">\(\sum_{i=0}^k f[n][i]\)</span>。</p>
<p>我比较懒，直接把每个状态 <span class="math inline">\((u,i)\)</span> 新建了点（结果跑的巨慢）。</p>
<h3 id="无解情况">无解情况</h3>
<p>注意拓扑完如果仍有点未入队，证明有 0 环。</p>
<p>0 环一直跑下去，方案数肯定无穷啊。</p>
<p>但是我们看下面这个图：</p>
<p><img src="https://s1.ax1x.com/2020/08/24/drkaOs.png" /></p>
<p>有解的路径并没有经过 0 环，也就是我们应该去掉不在有解路径上的边。</p>
<p>判一下是否 <span class="math inline">\(dis_{1,u}+val_E+dis_{v,n}\le dis_{1,n}+k\)</span> 即可。</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> RenaMoe &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(TT &amp;x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> K = <span class="number">60</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> nxt, to, val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, dis;</span><br><span class="line">    Data() &#123;&#125;</span><br><span class="line">    Data(<span class="keyword">int</span> x, <span class="keyword">int</span> d) : id(x), dis(d) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Data &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dis &gt; t.dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, m, kk, mod, cnte;</span><br><span class="line"><span class="keyword">int</span> ex[N], ey[N], ew[N], head[N*K], dis1[N], disn[N], out[N*K], ans[N*K], q[N*K];</span><br><span class="line">Edge e[N*K];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;Data&gt; heap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[++cnte] = (Edge)&#123;head[u], v, w&#125;, head[u] = cnte;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cnte = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="built_in">memset</span>(out, <span class="number">0</span>, <span class="keyword">sizeof</span> out);</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span> ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分层图编号</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> k * n + x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> *dis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        dis[i] = INF, vis[i] = <span class="literal">false</span>;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    heap.push(Data(s, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span> (!heap.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = heap.top().id;</span><br><span class="line">        heap.pop();</span><br><span class="line">        <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt) &#123;</span><br><span class="line">            v = e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (dis[v] &gt; dis[u] + e[i].val) &#123;</span><br><span class="line">                dis[v] = dis[u] + e[i].val;</span><br><span class="line">                heap.push(Data(v, dis[v]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        init();</span><br><span class="line">        read(n), read(m), read(kk), read(mod);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            read(ex[i]), read(ey[i]), read(ew[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理最短路</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            add_edge(ex[i], ey[i], ew[i]);</span><br><span class="line">        Dijkstra(<span class="number">1</span>, dis1);</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span> head), cnte = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            add_edge(ey[i], ex[i], ew[i]);</span><br><span class="line">        Dijkstra(n, disn);</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span> head), cnte = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去掉不在有解路径上的边</span></span><br><span class="line">        <span class="keyword">int</span> tm = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis1[ex[i]] + ew[i] + disn[ey[i]] &lt;= dis1[n] + kk)</span><br><span class="line">                tm++, ex[tm] = ex[i], ey[tm] = ey[i], ew[tm] = ew[i];</span><br><span class="line">        &#125;</span><br><span class="line">        m = tm;</span><br><span class="line">        <span class="comment">// 建出分层图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> dt = dis1[ex[i]] + ew[i] - dis1[ey[i]];</span><br><span class="line">            <span class="keyword">int</span> u = id(ex[i], <span class="number">0</span>), v = id(ey[i], dt);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j + dt &lt;= kk; ++j) &#123;</span><br><span class="line">                add_edge(u, v, <span class="number">0</span>), out[v]++;</span><br><span class="line">                u += n, v += n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tot = id(n, kk), sum = <span class="number">0</span>, sum_ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 拓扑dp</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i)</span><br><span class="line">            <span class="keyword">if</span> (!out[i]) q[++r] = i;</span><br><span class="line">        ans[id(<span class="number">1</span>, <span class="number">0</span>)] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q[l++];</span><br><span class="line">            sum++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt) &#123;</span><br><span class="line">                v = e[i].to;</span><br><span class="line">                ans[v] = (ans[v] + ans[u]) % mod;</span><br><span class="line">                <span class="keyword">if</span> (!(--out[v]))</span><br><span class="line">                    q[++r] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum != tot)	</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>); <span class="comment">// 有0环</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= kk; ++i)</span><br><span class="line">                sum_ans = (sum_ans + ans[id(n, i)]) % mod;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum_ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RenaMoe::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图论</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P4998 信号站</title>
    <url>/2020/08/26/2020-08-26-%E9%A2%98%E8%A7%A3-P4998-%E4%BF%A1%E5%8F%B7%E7%AB%99/</url>
    <content><![CDATA[<blockquote>
<p>一条路上有 n 户人家，坐标为 <span class="math inline">\(a_i\)</span>，需要建 k 个不同位置的信号站，每个信号站的不合理值为所有人家到信号站的距离和，求不合理值最小的 k 个信号站不合理值之和。</p>
<p><span class="math inline">\(k\le n\le 10^6,0\le a_i\le 10^6\)</span></p>
</blockquote>
<a id="more"></a>
<p><del>我才不会告诉你我是趁着估值频繁更新的时候来水题解的。</del></p>
<h2 id="思路">思路</h2>
<p>k,n 和坐标值域是同阶的。</p>
<p>设位置 i 的人家数有 <span class="math inline">\(b_i\)</span> 个，单次处理某个点的答案复杂度是 <span class="math inline">\(O(n)\)</span> 的，即 <span class="math inline">\(f_i=\sum b_j\times |i-j|\)</span>。</p>
<p>这时候需要我们观察两个点的答案之间的关系，尝试利用状态重叠的部分减少复杂度。</p>
<p>常用技巧，推一下将信号站由 i 挪到 i+1 答案变化了多少：</p>
<ul>
<li>i 左边的点（包括 i 处）离信号站距离都加了一</li>
<li>i 右边的点离信号站距离都减了一</li>
</ul>
<p>那么我们要维护每个点左右边各有几个点，通过前缀和或者递推，可将每次查询降到 <span class="math inline">\(O(1)\)</span>。</p>
<h2 id="细节">细节</h2>
<p>我赌你写一发交上去，倒数第二个点会 WA。</p>
<p>为什么？我们如果只计算了 <span class="math inline">\(i\in [0,10^6]\)</span> 的值，会忽略掉信号站建在负数位置的答案。</p>
<p>看个例子就懂了：</p>
<blockquote>
<p>n = 3，位置 <span class="math inline">\(a_i\)</span> 都为 0，k = 3。</p>
<p>那么三个信号站的位置分别为：-1，0，1。</p>
</blockquote>
<p>把所有位置向右平移 <span class="math inline">\(10^6\)</span> 单位距离，计算答案的范围扩大一倍就行。</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> RenaMoe &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(TT &amp;x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line">LL l, r, ans;</span><br><span class="line">LL a[N&lt;&lt;<span class="number">1</span>], f[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; ++i)</span><br><span class="line">        read(x), a[x+L]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= L+L; ++i)</span><br><span class="line">        f[<span class="number">0</span>] += a[i] * i;</span><br><span class="line">    <span class="comment">// l,r 分别是该位置左右两边的点数</span></span><br><span class="line">    r = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= L+L; ++i) &#123;</span><br><span class="line">        l += a[i<span class="number">-1</span>];</span><br><span class="line">        f[i] = f[i<span class="number">-1</span>] + l - r;</span><br><span class="line">        r -= a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(f, f+L+L+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">        ans += f[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
  </entry>
  <entry>
    <title>题解 P1081 开车旅行</title>
    <url>/2020/08/28/2020-08-28-%E9%A2%98%E8%A7%A3-P1081-%E5%BC%80%E8%BD%A6%E6%97%85%E8%A1%8C/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.luogu.com.cn/problem/P1081">题面</a></p>
<p>题面不好概括，贴个链接好了。</p>
</blockquote>
<a id="more"></a>
<p><del>你一个倍增题怎么这么难码啊！抱歉，是我的亲手写的 sb bug 让我调一天。</del></p>
<p>还是放一下题面好了：</p>
<p><img src="https://s1.ax1x.com/2020/08/28/doohOH.png" /></p>
<h2 id="思路">思路</h2>
<p>调完已经筋疲力尽了，不多说。</p>
<p>找距离最近的，那就倒着插入 set 来维护。</p>
<p>利用倍增的思想，预处理 <span class="math inline">\(nxt_{i,j}\)</span> 表示 i 点走 <span class="math inline">\(2^j\)</span> 次到达位置，同理 <span class="math inline">\(fa_{i,j},fb_{i,j}\)</span> 为两人答案。</p>
<p>细节看代码好了。</p>
<h2 id="代码">代码</h2>
<p>得 <code>long long</code>，这里 <code>define</code> 是我偷懒了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> RenaMoe &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(TT &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">bool</span> f = <span class="literal">false</span>; <span class="keyword">char</span> in = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(in)) &#123; <span class="keyword">if</span> (in == <span class="string">&#x27;-&#x27;</span>) f = <span class="literal">true</span>; in = getchar(); &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(in)) x = x * <span class="number">10</span> + in - <span class="string">&#x27;0&#x27;</span>, in = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">City</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> h, id;</span><br><span class="line">    City() &#123;&#125;</span><br><span class="line">    City(<span class="keyword">int</span> _h, <span class="keyword">int</span> _id) : h(_h), id(_id) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> City &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> h == t.h ? id &lt; t.id : h &lt; t.h; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tmp</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> h, dth, id;<span class="comment">// dth 为距离（delta h）</span></span><br><span class="line">    Tmp() &#123;&#125;</span><br><span class="line">    Tmp(City t) : h(t.h), id(t.id) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Tmp &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dth == t.dth ? h &lt; t.h : dth &lt; t.dth;<span class="comment">// 一定要好好读题qwq</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, ans_a, ans_b;</span><br><span class="line"><span class="keyword">int</span> h[N], nxt[N][<span class="number">20</span>], fa[N][<span class="number">20</span>], fb[N][<span class="number">20</span>], da[N], db[N], na[N], nb[N];</span><br><span class="line"><span class="built_in">multiset</span>&lt;City&gt; st;</span><br><span class="line">Tmp tmp[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    ans_a = ans_b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> (nxt[s][i] &amp;&amp; ans_a + ans_b + fa[s][i] + fb[s][i] &lt;= d) &#123;</span><br><span class="line">            ans_a += fa[s][i];</span><br><span class="line">            ans_b += fb[s][i];</span><br><span class="line">            s = nxt[s][i];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        read(h[i]);</span><br><span class="line">    st.insert(City(-INF, <span class="number">0</span>)), st.insert(City(-INF, <span class="number">0</span>));</span><br><span class="line">    st.insert(City(INF, n+<span class="number">1</span>)), st.insert(City(INF, n+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">multiset</span>&lt;City&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) &#123;</span><br><span class="line">        <span class="function">City <span class="title">u</span><span class="params">(h[i], i)</span></span>;</span><br><span class="line">        st.insert(u);</span><br><span class="line">        it = st.find(u);</span><br><span class="line">        tmp[<span class="number">0</span>] = Tmp(*--it), tmp[<span class="number">1</span>] = Tmp(*--it);</span><br><span class="line">        it = st.find(u);</span><br><span class="line">        tmp[<span class="number">2</span>] = Tmp(*++it), tmp[<span class="number">3</span>] = Tmp(*++it);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) </span><br><span class="line">            tmp[j].dth = <span class="built_in">abs</span>(tmp[j].h - h[i]);</span><br><span class="line">        sort(tmp, tmp+<span class="number">4</span>);</span><br><span class="line">        <span class="comment">// na,nb：分别以a,b开车的下一个位置，da,db为其距离</span></span><br><span class="line">        na[i] = tmp[<span class="number">1</span>].id, da[i] = tmp[<span class="number">1</span>].dth;</span><br><span class="line">        nb[i] = tmp[<span class="number">0</span>].id, db[i] = tmp[<span class="number">0</span>].dth;</span><br><span class="line">        nxt[i][<span class="number">0</span>] = na[i], fa[i][<span class="number">0</span>] = da[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        nxt[i][<span class="number">1</span>] = nb[na[i]];</span><br><span class="line">        fa[i][<span class="number">1</span>] = fa[i][<span class="number">0</span>], fb[i][<span class="number">1</span>] = db[na[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">19</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++u) &#123;</span><br><span class="line">            nxt[u][i] = nxt[nxt[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">            fa[u][i] = fa[u][i<span class="number">-1</span>] + fa[nxt[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">            fb[u][i] = fb[u][i<span class="number">-1</span>] + fb[nxt[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> s, x, ans;</span><br><span class="line">    read(x);</span><br><span class="line">    <span class="keyword">double</span> rat = (<span class="keyword">double</span>)INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        solve(i, x);</span><br><span class="line">        <span class="keyword">if</span> (ans_b == <span class="number">0</span>) ans_a = INF, ans_b = <span class="number">1</span>;<span class="comment">// 注意ans_b为0的情况</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">double</span>)ans_a / (<span class="keyword">double</span>)ans_b &lt; rat)</span><br><span class="line">            rat = (<span class="keyword">double</span>)ans_a / (<span class="keyword">double</span>)ans_b, ans = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    read(m);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        read(s), read(x);</span><br><span class="line">        solve(s, x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>, ans_a, ans_b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RenaMoe::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>20年11月13日 小测</title>
    <url>/2020/11/14/20%E5%B9%B411%E6%9C%8813%E6%97%A5%E5%B0%8F%E6%B5%8B/</url>
    <content><![CDATA[<p>贪心 + 状压 DP。</p>
<p>死刚 A 题，30 分。</p>
<a id="more"></a>
<h1 id="a">A</h1>
<p><a href="http://sjzezoj.com:9280/problem/44">题目</a></p>
<blockquote>
<p>给出 m 个长度不超过 n 的黑白序列，每次将同色的长度大于 1 的区间换成一个相反颜色的点，求每一列直到到不能操作的最少步数之和。 <span class="math inline">\(n\le 10^4,m\le100\)</span>。</p>
</blockquote>
<p>贪心。</p>
<p>每次操作就是将相邻三个（边界是两个）合并，贪心的想，一定是从中间能消的开始消（尽量每次消除两个区间）。</p>
<p>如果中间两个可行的区间中间的区间个数超过总数一半，那么答案为中间的区间数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, len, tot, ans;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s+<span class="number">1</span>);</span><br><span class="line">        len = <span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[i<span class="number">-1</span>]) a[tot]++;</span><br><span class="line">            <span class="keyword">else</span> a[++tot] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; <span class="number">1</span>) a[i] = <span class="number">1</span>, flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> a[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> l = tot &gt;&gt; <span class="number">1</span>, r = l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &amp;&amp; !a[l]) l--;</span><br><span class="line">        <span class="keyword">while</span> (r &lt;= tot &amp;&amp; !a[r]) r++;</span><br><span class="line">        <span class="keyword">if</span> (!l) &#123;</span><br><span class="line">            ans += r;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &gt; tot) &#123;</span><br><span class="line">            ans += tot - l + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((r - l) * <span class="number">2</span> &gt;= tot) ans += r - l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> ans += tot / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="b">B</h1>
<p><a href="http://sjzezoj.com:9280/contest/10/problem/45">题目</a></p>
<blockquote>
<p>n 个商店 m 个物品，每种物品在每个商店有不同的价值，每个商店有交通费，求买完所有物品的最小费用。 <span class="math inline">\(n\le 100,m\le 16\)</span>。</p>
</blockquote>
<p>状压 DP。</p>
<p>设 <span class="math inline">\(f_{i,S}\)</span> 表示前 i 个商店已购买 S 状态的最小费用。对于每个商店，强制去该商店，更新所有状态，再与不去该商店的状态取 <span class="math inline">\(\min\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">109</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, maxn;</span><br><span class="line"><span class="keyword">int</span> f[M][N], val[M][M], fee[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        read(fee[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            read(val[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    maxn = (<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(f[<span class="number">0</span>], <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f[<span class="number">0</span>]);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= maxn; ++j) &#123;</span><br><span class="line">            f[i][j] = f[i<span class="number">-1</span>][j] + fee[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= maxn; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((j &amp; (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>))) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                f[i][j] = min(f[i][j], f[i][j ^ (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>))] + val[i][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= maxn; ++j) &#123;</span><br><span class="line">            f[i][j] = min(f[i][j], f[i<span class="number">-1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\\n&quot;</span>, f[n][maxn]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
  </entry>
  <entry>
    <title>20年11月14日 模拟赛</title>
    <url>/2020/11/15/20%E5%B9%B411%E6%9C%8814%E6%97%A5-%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>规律 + 树链剖分 + trie 树 + 简单 DP。</p>
<p>235分，算是没有挂分。</p>
<a id="more"></a>
<h1 id="a-演讲">A 演讲</h1>
<p><a href="http://sjzezoj.com:9280/problem/49">题目</a></p>
<blockquote>
<p>给定矩阵 <span class="math inline">\(g\)</span>，如果 i 被 j D，那么 i 就会去 D <span class="math inline">\(g_{i,j}\)</span>，一直循环下去，求第 d 个人。</p>
<p><span class="math inline">\(n\le 600,d\le 10^{18}\)</span>。</p>
</blockquote>
<p>规律题。</p>
<p>可以发现状态 <span class="math inline">\((i,j)\)</span> 只能转移到确定的一处，手模一下可以发现，这样下去会产生一个 ρ 型环。</p>
<p>只要预处理 <span class="math inline">\(n^2\)</span> 个状态就能找到环。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">609</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, tot, cur;</span><br><span class="line">LL d;</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="built_in">pair</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mem[N*N];</span><br><span class="line"><span class="built_in">map</span> &lt;<span class="built_in">pair</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(d);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            read(g[i][j]);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">1</span>;</span><br><span class="line">    mem[tot = <span class="number">1</span>] = <span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> id = <span class="number">2</span>; ; ++id) &#123;</span><br><span class="line">        <span class="built_in">pair</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; t(i, j);</span><br><span class="line">        <span class="keyword">if</span> (mp.count(t)) &#123;</span><br><span class="line">            cur = mp[t];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mp[t] = id;</span><br><span class="line">        mem[++tot] = t;</span><br><span class="line">        <span class="keyword">int</span> k = g[i][j];</span><br><span class="line">        j = i, i = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (d &lt;= tot)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\\n&quot;</span>, mem[d].first);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        d -= cur - <span class="number">1</span>;</span><br><span class="line">        d = (d - <span class="number">1</span>) % (tot - cur + <span class="number">1</span>) + cur;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\\n&quot;</span>, mem[d].first);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="b-卡车调度">B 卡车调度</h1>
<p><a href="http://sjzezoj.com:9280/problem/50">题目</a></p>
<blockquote>
<p>给出一个 n 点 m 边带权无向图，q 次询问：每次需要选的 x 和 y之间的路径和另外一条边（该边一端点是选定路径上的点），最小化这些边的最大值。</p>
<p><span class="math inline">\(n,q\le 3\times 10^5,m\le10^6\)</span>。</p>
</blockquote>
<p>最小生成树 + 树链剖分。</p>
<p>易证该路径一定在最小生成树上，树链剖分或倍增维护。</p>
<p>问题在于如何处理多出来的这条边。</p>
<p>对于路径上的每个点（不包括两端），已经被两条边经过，第三条边一定不大于该点第三小的出边，直接维护每个点第三小的出边边值，端点单独处理。（这里的边是原图的边。）</p>
<p>为什么？如果已经经过的两条边为最小的两条出边，那么该边就是第三小的最优；如果不是，该边为最小或第二小，其权值会经过的那两条边覆盖。</p>
<p>最后只要对 路径边权最大值 和 路径点第三小边权 两者取最大值。</p>
<p>有些地方用了奇怪的 trick，莫名其妙被别人慢很多。好像还是最长的？？？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e6</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">int</span> head[N], nxt[N&lt;&lt;<span class="number">1</span>], to[N&lt;&lt;<span class="number">1</span>], val[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        nxt[++cnt] = head[u], to[cnt] = v, val[cnt] = w, head[u] = cnt;</span><br><span class="line">        nxt[++cnt] = head[v], to[cnt] = u, val[cnt] = w, head[v] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; G;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, val;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Edge &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> val &lt; t.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FindSet</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fa[N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fa[x] == x ? x : fa[x] = find(fa[x]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; F; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, Q, tot;</span><br><span class="line"><span class="keyword">int</span> a1[N], a2[N], fa[N], deep[N], son[N], size[N], top[N], id[N];</span><br><span class="line">Edge ed[M];</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; out[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    deep[u] = deep[pre] + <span class="number">1</span>;</span><br><span class="line">    fa[u] = pre;</span><br><span class="line">    size[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = G.head[u], v; i; i = G.nxt[i]) &#123;</span><br><span class="line">        v = G.to[i];</span><br><span class="line">        <span class="keyword">if</span> (v == pre) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(v, u);</span><br><span class="line">        size[u] += size[v];</span><br><span class="line">        <span class="keyword">if</span> (!son[u] || size[v] &gt; size[son[u]]) son[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegTree</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(x) ((x) &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(x) ((x) &lt;&lt; 1 | 1)</span></span><br><span class="line">    <span class="keyword">int</span> ma[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    SegTree() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (N&lt;&lt;<span class="number">2</span>); ++i) ma[i] = -INF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> suc)</span> </span>&#123;</span><br><span class="line">        ma[suc] = max(ma[ls(suc)], ma[rs(suc)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> *a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            ma[suc] = a[l];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        build(ls(suc), l, mid, a), build(rs(suc), mid+<span class="number">1</span>, r, a);</span><br><span class="line">        push_up(suc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            ma[suc] = k;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (p &lt;= mid) update(ls(suc), l, mid, p, k);</span><br><span class="line">        <span class="keyword">else</span> update(rs(suc), mid+<span class="number">1</span>, r, p, k);</span><br><span class="line">        push_up(suc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) <span class="keyword">return</span> ma[suc];</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, res = -INF;</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= mid) res = max(res, query(ls(suc), l, mid, ql, qr));</span><br><span class="line">        <span class="keyword">if</span> (qr &gt; mid) res = max(res, query(rs(suc), mid+<span class="number">1</span>, r, ql, qr));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; tr1, tr2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tp, <span class="keyword">int</span> eval)</span> </span>&#123;</span><br><span class="line">    id[u] = ++tot;</span><br><span class="line">    top[u] = tp;</span><br><span class="line">    a1[id[u]] = eval;</span><br><span class="line">    <span class="keyword">if</span> (!son[u]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = G.head[u], v; i; i = G.nxt[i]) &#123;</span><br><span class="line">        v = G.to[i];</span><br><span class="line">        <span class="keyword">if</span> (v == son[u]) &#123;</span><br><span class="line">            dfs2(v, tp, G.val[i]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = G.head[u], v; i; i = G.nxt[i]) &#123;</span><br><span class="line">        v = G.to[i];</span><br><span class="line">        <span class="keyword">if</span> (v == fa[u] || v == son[u]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs2(v, v, G.val[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = -INF;</span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deep[top[x]] &lt; deep[top[y]]) swap(x, y);</span><br><span class="line">        res = max(res, tr1.query(<span class="number">1</span>, <span class="number">1</span>, n, id[top[x]], id[x]));</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (deep[x] &gt; deep[y]) swap(x, y);</span><br><span class="line">    <span class="keyword">if</span> (x != y) res = max(res, tr1.query(<span class="number">1</span>, <span class="number">1</span>, n, id[x]+<span class="number">1</span>, id[y]));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = -INF;</span><br><span class="line">    <span class="keyword">int</span> tx = x, ty = y;</span><br><span class="line">    tr2.update(<span class="number">1</span>, <span class="number">1</span>, n, id[tx], -INF), tr2.update(<span class="number">1</span>, <span class="number">1</span>, n, id[ty], -INF);</span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deep[top[x]] &lt; deep[top[y]]) swap(x, y);</span><br><span class="line">        res = max(res, tr2.query(<span class="number">1</span>, <span class="number">1</span>, n, id[top[x]], id[x]));</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (deep[x] &gt; deep[y]) swap(x, y);</span><br><span class="line"><span class="comment">//	printf(&quot;&gt; %d %d\\n&quot;, id[x], id[y]);</span></span><br><span class="line">    res = max(res, tr2.query(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[y]));</span><br><span class="line">    tr2.update(<span class="number">1</span>, <span class="number">1</span>, n, id[tx], a2[id[tx]]), tr2.update(<span class="number">1</span>, <span class="number">1</span>, n, id[ty], a2[id[ty]]);</span><br><span class="line">    <span class="keyword">return</span> -res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(m), read(Q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        read(ed[i].x), read(ed[i].y), read(ed[i].val);</span><br><span class="line">    &#125;</span><br><span class="line">    F.init(n);</span><br><span class="line">    sort(ed+<span class="number">1</span>, ed+m+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = F.find(ed[i].x), y = F.find(ed[i].y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">continue</span>;</span><br><span class="line">        F.fa[x] = y;</span><br><span class="line">        G.add(ed[i].x, ed[i].y, ed[i].val);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">0</span>), dfs2(<span class="number">1</span>, <span class="number">1</span>, -INF), tr1.build(<span class="number">1</span>, <span class="number">1</span>, n, a1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        out[ed[i].x].push_back(ed[i].val);</span><br><span class="line">        out[ed[i].y].push_back(ed[i].val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        sort(out[i].begin(), out[i].end());</span><br><span class="line">        <span class="keyword">if</span> (out[i].size() &gt;= <span class="number">3</span>) a2[id[i]] = -out[i][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">else</span> a2[id[i]] = -INF;</span><br><span class="line">    &#125;</span><br><span class="line">    tr2.build(<span class="number">1</span>, <span class="number">1</span>, n, a2);</span><br><span class="line">    <span class="comment">//for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, id[i]); puts(&quot;&quot;);</span></span><br><span class="line">    <span class="comment">//printf(&quot;&gt;&gt; %d\\n&quot;, tr2.query(1, 1, n, 1, 3));</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">        read(x), read(y);</span><br><span class="line">        <span class="keyword">int</span> q1 = query1(x, y); <span class="comment">//puts(&quot;(* _ *)&quot;);</span></span><br><span class="line">        <span class="keyword">int</span> q2 = query2(x, y);</span><br><span class="line">        <span class="keyword">if</span> (q2 == INF &amp;&amp; out[x].size() == <span class="number">1</span> &amp;&amp; out[y].size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (out[x].size() &gt;= <span class="number">2</span>) q2 = min(q2, out[x][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (out[y].size() &gt;= <span class="number">2</span>) q2 = min(q2, out[y][<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\\n&quot;</span>, max(q1, q2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="c-篝火舞蹈">C 篝火舞蹈</h1>
<p><a href="http://sjzezoj.com:9280/problem/51">题目</a></p>
<blockquote>
<p>给出 <span class="math inline">\([0,3^n]\)</span> 的序列 <span class="math inline">\(a\)</span>，有两个操作：1 操作将序列分成三部分，交换第二个和第三个部分，然后各部分递归重复该操作；2 操作将序列整体右移，即 <span class="math inline">\(a_i=a_{i-1},a_1=a_n\)</span>。</p>
<p><span class="math inline">\(n\le 12,Q\le 2\times 10^5\)</span>。</p>
</blockquote>
<p>trie 树。</p>
<p>真是难想又巧妙的思路。</p>
<p>将下标转化到 3 进制，可以发现 1 操作就是对于每一位将值为 1 的和值为 2 的交换。</p>
<p>那么可以放到 trie 树上，通过 lazy tag 优化（两次 1 操作会抵消）单次 <span class="math inline">\(\mathcal O(1)\)</span>。</p>
<p>2 操作难以直接转化到 trie 树上，那么换一个编号方式：</p>
<p><img src="https://s3.ax1x.com/2020/11/15/Di2HZn.png" /></p>
<p><del>这怎么想的到啊。</del>因为 1 操作的性质，正反插 trie 都是一样的。</p>
<p>2 操作其实是让所有编号的位置加一，最低位是 0 和 1 的只改变 1 位，是 2 的会进位，所以从低位到高位插 trie 的话，每一层只要交换三个子树，然后往一个子树内递归即可，单次复杂度降至 <span class="math inline">\(\mathcal{O}(\log_2n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, lim, Q, tot;</span><br><span class="line"><span class="keyword">int</span> ch[N][<span class="number">3</span>], id[N], tag[N], pw3[N], ans[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> deep, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deep == n) &#123;</span><br><span class="line">        id[suc] = k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        ch[suc][i] = ++tot;</span><br><span class="line">        build(ch[suc][i], deep+<span class="number">1</span>, k + i * pw3[deep]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> suc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tag[suc]) <span class="keyword">return</span>;</span><br><span class="line">    swap(ch[suc][<span class="number">1</span>], ch[suc][<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        tag[ch[suc][i]] ^= <span class="number">1</span>;</span><br><span class="line">    tag[suc] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">circle</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> deep)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deep == n) <span class="keyword">return</span>;</span><br><span class="line">    push_down(suc);</span><br><span class="line">    <span class="keyword">int</span> t = ch[suc][<span class="number">2</span>];</span><br><span class="line">    ch[suc][<span class="number">2</span>] = ch[suc][<span class="number">1</span>], ch[suc][<span class="number">1</span>] = ch[suc][<span class="number">0</span>], ch[suc][<span class="number">0</span>] = t;</span><br><span class="line">    circle(ch[suc][<span class="number">0</span>], deep+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_tag</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> deep, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deep == n) &#123;</span><br><span class="line">        ans[id[suc]] = k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(suc);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        clear_tag(ch[suc][i], deep+<span class="number">1</span>, k + i * pw3[deep]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s+<span class="number">1</span>);</span><br><span class="line">    Q = <span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    pw3[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) pw3[i] = pw3[i<span class="number">-1</span>] * <span class="number">3</span>;</span><br><span class="line">    lim = <span class="built_in">pow</span>(<span class="number">3</span>, n);</span><br><span class="line">    build(tot = <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;S&#x27;</span>) tag[<span class="number">1</span>] ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> circle(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clear_tag(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="d-练习曲">D 练习曲</h1>
<p>简单 DP。</p>
<p>不修改的话 DP 方程： <span class="math display">\[
\begin{aligned}
f_i&amp;=\min_{i-L\le j&lt;i}\{f_j\}+w(j+1,i)\\
w(j,i)&amp;=\max\{\max_{j\le k&lt;i}\{a_k\},\ a_i-1\} + 1
\end{aligned}
\]</span></p>
<p>修改的话，发现一个点只影响 <span class="math inline">\(2L\)</span> 个 DP 值，那么预处理正着和倒着分别 DP 一遍，处理影响的一段后拼接得到答案。</p>
<p>可以发现 <span class="math inline">\(f_i\)</span> 是单调不降的。从 <span class="math inline">\((x-L,x]\)</span> 中固定一个起点，当 <span class="math inline">\(x\)</span> 所在段权值一定时，这一段越长越好。</p>
<p>所以每次只要 <span class="math inline">\(\mathcal O(L)\)</span> 处理即可，复杂度 <span class="math inline">\(\mathcal O((n+q)L)\)</span>。其实觉得过不了的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6e5</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, L, Q;</span><br><span class="line">LL a[N], f[N], g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(L), read(Q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] + a[i];</span><br><span class="line">        LL ma = a[i] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt; <span class="number">0</span> &amp;&amp; i - j + <span class="number">1</span> &lt;= L; --j) &#123;</span><br><span class="line">            ma = max(ma, a[j]);</span><br><span class="line">            f[i] = min(f[i], f[j - <span class="number">1</span>] + ma + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> last = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        g[i] = g[i + <span class="number">1</span>] + a[i];</span><br><span class="line">        LL ma = a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n &amp;&amp; j - i + <span class="number">1</span> &lt;= L; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt;= ma) last = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> ma = a[j], last = <span class="literal">false</span>;</span><br><span class="line">            g[i] = min(g[i], g[j + <span class="number">1</span>] + ma + last);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    LL val;</span><br><span class="line">    <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">        read(x), read(val);</span><br><span class="line">        LL ans = f[x - <span class="number">1</span>] + g[x + <span class="number">1</span>] + val;</span><br><span class="line">        <span class="keyword">int</span> j = x + <span class="number">1</span>;</span><br><span class="line">        LL ma = val;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; x - i &lt;= L; --i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt;= n &amp;&amp; j - i - <span class="number">1</span> &lt;= L &amp;&amp; a[j] &lt;= ma) ++j;</span><br><span class="line">            j = min(j, i + L + <span class="number">1</span>);</span><br><span class="line">            ans = min(ans, f[i] + g[j] + ma + <span class="number">1</span>);</span><br><span class="line">            ma = max(ma, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        j = x - <span class="number">1</span>, ma = val;</span><br><span class="line">        <span class="keyword">bool</span> last = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x + <span class="number">1</span>; i &lt;= n + <span class="number">1</span> &amp;&amp; i - x &lt;= L; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; i - j - <span class="number">1</span> &lt;= L &amp;&amp; a[j] &lt; ma) --j;</span><br><span class="line">            j = max(j, i - L - <span class="number">1</span>);</span><br><span class="line">            ans = min(ans, f[j] + g[i] + ma + last);</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt;= ma) last = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> ma = a[i], last = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
  </entry>
  <entry>
    <title>20年11月22日 「启智树」模拟赛</title>
    <url>/2020/11/22/20%E5%B9%B411%E6%9C%8822%E6%97%A5-%E3%80%8C%E5%90%AF%E6%99%BA%E6%A0%91%E3%80%8D%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>数论 + 模拟 + 图论 + 带权并查集。</p>
<p>88 块钱的比赛竟然没好好打 QAQ。</p>
<a id="more"></a>
<h1 id="a-等差数列">A 等差数列</h1>
<blockquote>
<p>给出两个等差数列 <span class="math inline">\(a,b\)</span>，求区间 <span class="math inline">\([l,r]\)</span> 中同时出现在两个等差数列的数的个数。</p>
<p><span class="math inline">\(a_1,b_1\le 100, r\le 10^{18}\)</span>。</p>
</blockquote>
<p>数论。</p>
<p>设 <span class="math inline">\(a,b\)</span> 的等差数列公差 <span class="math inline">\(d_1,d_2\)</span>，每 <span class="math inline">\(\operatorname{lcm}(d_1,d_2)\)</span> 就会出现一个符合条件的数，这个循环长度只有 <span class="math inline">\(10^4\)</span> 级别，暴力找即可。</p>
<p>然后 <span class="math inline">\([1,n]\)</span> 的答案就是最小的符合条件的数到 <span class="math inline">\(n\)</span> 之间的循环机个数，上取整。</p>
<p>最后答案差分一下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL a, aa, d1, b, bb, d2, l, r, fir, cc;</span><br><span class="line">LL sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; fir) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (LL)<span class="built_in">ceil</span>((<span class="keyword">double</span>)(n - fir + <span class="number">1</span>) / (<span class="keyword">double</span>)cc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(a), read(aa), read(b), read(bb), read(l), read(r);</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) swap(a, b), swap(aa, bb);</span><br><span class="line">    d1 = aa - a, d2 = bb - b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a; i &lt;= <span class="number">1e5</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((i - a) % d1 == <span class="number">0</span> &amp;&amp; (i - b) % d2 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!fir) fir = i;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cc = i - fir;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, solve(r) - solve(l<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="b-玩具">B 玩具</h1>
<p><img src="https://s3.ax1x.com/2020/11/22/DGnDZn.png" /></p>
<blockquote>
<p><span class="math inline">\(n\le 10^6\)</span>。</p>
<p>模拟题题目好长就不概括了。</p>
</blockquote>
<p>就是类似队列的思想预处理每个点到其之前 <span class="math inline">\(L\)</span> 个可行位置的长度，贪心地跳即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e6</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, B, L;</span><br><span class="line">LL ans;</span><br><span class="line">LL g[N];</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; B) sum -= str[i - B] == <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        sum += str[i] == <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= B &amp;&amp; sum &lt; L) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(L), read(B), read(n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!check()) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;IMPOSSIBLE&quot;</span>), <span class="keyword">void</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = L;</span><br><span class="line">    g[L] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L + <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            r = i, l++;</span><br><span class="line">            <span class="keyword">while</span> (str[l] == <span class="string">&#x27;0&#x27;</span>) l++;</span><br><span class="line">        &#125;</span><br><span class="line">        g[i] = l;</span><br><span class="line">    &#125;</span><br><span class="line">    l = L, r = B;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; n) &#123;</span><br><span class="line">        ans += L;</span><br><span class="line">        l = r, r = g[r] + B - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; n) ans += L;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans + n - B);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="c-整除">C 整除</h1>
<blockquote>
<p>给定 <span class="math inline">\(k,m\)</span>，求一个最小的能被 <span class="math inline">\(m\)</span> 整除的 <span class="math inline">\(n\)</span>，保证 <span class="math inline">\(n\)</span> 的每一位数字都属于 <span class="math inline">\([0,k)\)</span>。</p>
<p><span class="math inline">\(k\le 10,m\le 10^6\)</span>。</p>
</blockquote>
<p>图论。</p>
<p>设 <span class="math inline">\(f_i\)</span> 表示 <span class="math inline">\(n \bmod m = i\)</span> 的最小的 <span class="math inline">\(n\)</span>，<span class="math inline">\(f_i\)</span> 可以向 <span class="math inline">\(f_i\times10+j\quad(j\in[0,k))\)</span> 连边。</p>
<p>对每个点的出边从小到大 bfs，即可保证答案最小。</p>
<p><span class="math inline">\(f_i\)</span> 存不下，只存最低位的前驱点即可，最后从 <span class="math inline">\(0\)</span> 点往回倒推。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> K, m;</span><br><span class="line"><span class="keyword">int</span> dis[N], ans[N], pre[N], q[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; e[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; output;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(K), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; m; ++u) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; K; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = (u * <span class="number">10</span> + j) % m;</span><br><span class="line">            e[u].push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">        pre[u] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="keyword">int</span> ql = <span class="number">1</span>, qr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt; K; ++u) &#123;</span><br><span class="line">        ans[u] = u;</span><br><span class="line">        dis[u] = <span class="number">0</span>;</span><br><span class="line">        q[++qr] = u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ql &lt;= qr) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q[ql++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e[u].size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[u][i];</span><br><span class="line">            <span class="keyword">if</span> (dis[v] &gt; dis[u] + <span class="number">1</span>) &#123;</span><br><span class="line">                ans[v] = i;</span><br><span class="line">                dis[v] = dis[u] + <span class="number">1</span>;</span><br><span class="line">                pre[v] = u;</span><br><span class="line">                q[++qr] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u != <span class="number">-1</span>; u = pre[u]) &#123;</span><br><span class="line">        output.push_back(ans[u] + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = output.size() - <span class="number">1</span>; ~i; --i)</span><br><span class="line">        <span class="built_in">putchar</span>(output[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="d-集合">D 集合</h1>
<p>类似 <a href="https://www.luogu.com.cn/problem/CF571D">CF571D Campus</a>。</p>
<p>可以看这道题的 <a href="/2020/11/26/题解-CF571D-Campus">题解</a>（没用带权并查集）。</p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
  </entry>
  <entry>
    <title>20年12月 刷题记录</title>
    <url>/2020/12/02/20%E5%B9%B412%E6%9C%88-%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>考完 NOIP 就要回去补文化课了，这个月可能做不了多少题了。</p>
<a id="more"></a>
<h1 id="日">2日</h1>
<h2 id="s2oj123-数组入门">S2OJ#123 数组入门</h2>
<p><a href="https://sjzezoj.com/problem/123">题目</a></p>
<p>分块。</p>
<p>取模可能会让中间的某些值修改后变成最小值，所以要用维护权值的数据结构。</p>
<p>考虑分块，每个块维护一个排好序的 vector，下放标记就重构，查询就 lower_bound。</p>
<p>经过多次调参和提交，发现块的大小为 <span class="math inline">\(n^{0.4}\)</span> 能 AC，复杂度 <span class="math inline">\(\mathcal O(m(n^{0.6}+n^{0.4}\log n^{0.4}))\)</span>。</p>
<h2 id="p1776-宝物筛选">P1776 宝物筛选</h2>
<p><a href="https://www.luogu.com.cn/problem/P1776">题目</a></p>
<p>单调队列优化多重背包。 <span class="math display">\[
\begin{aligned}
f(i,j)&amp;\leftarrow \max_{0\le k\le c}\{f(i-1, j-kw)+v\times k\}\\
f(i,d+kw)&amp;\leftarrow \max_{k-c\le k&#39;\le k}\{f(i-1, d+k&#39;w)-v\times k&#39;\}+v\times k
\end{aligned}
\]</span> 对于每个 <span class="math inline">\(d\ (0\le d &lt; w)\)</span> 分别用单调队列维护 DP，总复杂度 <span class="math inline">\(\mathcal O(nm)\)</span>。</p>
<h1 id="日-1">3日</h1>
<h2 id="u142829-魔法商店">U142829 魔法商店</h2>
<p><a href="https://www.luogu.com.cn/problem/U142829">题目</a></p>
<p>物品重量很小，按重量分类再排序，转化成多重背包。</p>
<p>设 <span class="math inline">\(s(i,j)\)</span> 为物品 <span class="math inline">\(i\)</span> 最大的前 <span class="math inline">\(j\)</span> 个物品价值和。 <span class="math display">\[
f(i,d+kw)\leftarrow \max_{k-c\le k&#39;\le k}\{f(i-1, d+k&#39;w)+s(i,k-k&#39;)\}
\]</span> <span class="math inline">\(s(i,j)\)</span> 是凸的，<span class="math inline">\(f(i,j)\)</span> 单调不降，所以这东西有决策单调性，可以单调队列优化，或者分治。</p>
<h2 id="cf220b-little-elephant-and-array">CF220B Little Elephant and Array</h2>
<p><a href="https://www.luogu.com.cn/problem/CF220B">题目</a></p>
<p>树状数组 + 离线。</p>
<p>离散化，用 vector 把每种权值的所有位置按顺序存起来，先令区间左端点为 <span class="math inline">\(1\)</span>，确定右端点合法范围，用树状数组区间打标记。</p>
<p>将所有询问离线，从左往右扫，对于以该点为左端点的询问在树状数组上单点查询；每次只有 <span class="math inline">\(1\)</span> 种权值答案改变，在树状数组上撤销和修改即可。</p>
<p>总复杂度 <span class="math inline">\(\mathcal O(n\log n)\)</span>。</p>
<h2 id="u144136-距离">U144136 距离</h2>
<p><a href="https://www.luogu.com.cn/problem/U144136">题目</a></p>
<p>倍增 + 二分 + 最短路。</p>
<p>发现不断地往 图里加边，<span class="math inline">\(1\)</span> 到 <span class="math inline">\(n\)</span> 的最短路单调不升，可以二分。</p>
<p>考虑 <span class="math inline">\(47\)</span> 分：对于某个时间段里的边建出图来跑最短路，二分 <span class="math inline">\(5\)</span> 次即可，复杂度 <span class="math inline">\(\mathcal O(n\log^2n)\)</span>。</p>
<p>至于满分做法，因为清空图的时间段很多，每次二分边界中有许多无用的范围，考虑用倍增缩小二分范围。</p>
<p>设上次清空时间点 <span class="math inline">\(D\)</span>，倍增到最小的时间点 <span class="math inline">\(D+2^i\)</span> 满足 <span class="math inline">\(dis(1,n)\le T\)</span>，在中间二分并更新 <span class="math inline">\(D\)</span>。</p>
<p>每条边最多被处理 <span class="math inline">\(\log q\)</span> 次，复杂度应该是 <span class="math inline">\(\mathcal O(q\log q)\)</span>。</p>
<p>毒瘤 <span class="math inline">\(\rm \color{black}{A}\color{red}{zusaCat}\)</span>，她卡了 SPFA。</p>
<h1 id="日-2">15日</h1>
<h2 id="p5410-模板扩展-kmpz-函数">P5410 【模板】扩展 KMP（Z 函数）</h2>
<p><a href="https://www.luogu.com.cn/problem/P5410">题目</a></p>
<p>见 <a href="/2020/01/17/2020-01-17-板子-kmp/">板子 kmp</a></p>
<h1 id="日-3">16日</h1>
<h2 id="p1494-国家集训队小z的袜子">P1494 [国家集训队]小Z的袜子</h2>
<p><a href="https://www.luogu.com.cn/problem/P1494">题目</a></p>
<p>经典莫队板子，复习。</p>
<h1 id="日-4">17日</h1>
<h2 id="sp10707-cot2---count-on-a-tree-ii">SP10707 COT2 - Count on a tree II</h2>
<p><a href="https://www.luogu.com.cn/problem/SP10707">题目</a></p>
<p>树上莫队，见 <a href="/2020/12/17/总结-莫队/">莫队总结</a>。</p>
<h1 id="日-5">19日</h1>
<h2 id="at1219-歴史の研究">AT1219 歴史の研究</h2>
<p><a href="https://www.luogu.com.cn/problem/AT1219">题目</a></p>
<p>回滚莫队，见 <a href="/2020/12/17/总结-莫队/">莫队总结</a>。</p>
<h1 id="日-6">20日</h1>
<h2 id="p4887-模板莫队二次离线第十四分块前体">P4887 【模板】莫队二次离线（第十四分块(前体)）</h2>
<p><a href="https://www.luogu.com.cn/problem/P4887">题目</a></p>
<p>二次离线莫队，见 <a href="/2020/12/17/总结-莫队/">莫队总结</a>。</p>
<h2 id="p4074-wc2013糖果公园">P4074 「WC2013」糖果公园</h2>
<p><a href="https://www.luogu.com.cn/problem/P4074">题目</a></p>
<p>树上莫队 + 带修莫队。</p>
<p>不太好码。</p>
<h1 id="日-7">21日</h1>
<h2 id="p2713-罗马游戏">P2713 罗马游戏</h2>
<p><a href="https://www.luogu.com.cn/problem/P2713">题目</a></p>
<p>可并堆。</p>
<h2 id="p4556-vani有约会雨天的尾巴-模板线段树合并">P4556 [Vani有约会]雨天的尾巴 /【模板】线段树合并</h2>
<p><a href="https://www.luogu.com.cn/problem/P4556">题目</a></p>
<p>树上差分 + 线段树合并。</p>
<p>注意是多次路径修改并且一次询问，树上差分后把所有询问插入对应点的线段树中，dfs 一遍把每个点儿子的线段树合并到它的线段树上，然后在线段树上查即可。</p>
<p>插入点数 <span class="math inline">\(n\)</span>，复杂度 <span class="math inline">\(\mathcal O(n\log n)\)</span>。</p>
<h1 id="日-8">22日</h1>
<h2 id="p3224-hnoi2012永无乡">P3224 [HNOI2012]永无乡</h2>
<p><a href="https://www.luogu.com.cn/problem/P3224">题目</a></p>
<p>并查集 + 线段树合并。</p>
<p>并查集维护连通性，线段树合并硬上即可，每次合并都没有重合的点，复杂度 <span class="math inline">\(\mathcal O(n\log n)\)</span>。</p>
<h2 id="p3919-模板可持久化线段树-1可持久化数组">P3919 【模板】可持久化线段树 1（可持久化数组）</h2>
<p><a href="https://www.luogu.com.cn/problem/P3919">题目</a></p>
<p>可持久化线段树。</p>
<h2 id="p2839-国家集训队middle">P2839 [国家集训队]middle</h2>
<p><a href="https://www.luogu.com.cn/problem/P2839">题目</a></p>
<p>二分 + 可持久化线段树。</p>
<p>中位数套路：把大于等于 <span class="math inline">\(x\)</span> 的设为 <span class="math inline">\(+1\)</span>，小于 <span class="math inline">\(x\)</span> 的设为 <span class="math inline">\(-1\)</span>，若和为 <span class="math inline">\(1\)</span> 或 <span class="math inline">\(0\)</span> 则 <span class="math inline">\(x\)</span> 为中位数。</p>
<p>先考虑询问固定的区间，二分最大的 <span class="math inline">\(x\)</span> 满足区间和 <span class="math inline">\(\ge 0\)</span>，所以需要对于每一个值开一棵求中位数的线段树。</p>
<p>相邻两个值的线段树只有很少几个值不同，可以通过可持久化线段树将时间空间降到 <span class="math inline">\(\mathcal O(n\log n)\)</span>。</p>
<p>对于询问 <span class="math inline">\(a,b,c,d\)</span>，<span class="math inline">\([b,c]\)</span> 是一定要选的，查和即可；因为要让中位数尽可能大，所以 check 时的区间可也要尽可能大，所以取 <span class="math inline">\([a,b)\)</span> 的最大后缀和、<span class="math inline">\((c,d]\)</span> 的最大前缀和。</p>
<h2 id="p1712-noi2016区间">P1712 [NOI2016]区间</h2>
<p><a href="https://www.luogu.com.cn/problem/P1712">题目</a></p>
<p>尺取法 + 线段树。</p>
<p>把所有区间按长度排序，然后模拟一个队列，每次向后挪动 <span class="math inline">\(r\)</span> 至有至少一个点覆盖次数 <span class="math inline">\(\ge m\)</span>，再尽量往后挪动 <span class="math inline">\(l\)</span>，更新答案，覆盖次数用线段树维护。</p>
]]></content>
      <categories>
        <category>刷题记录</category>
      </categories>
  </entry>
  <entry>
    <title>20年12月1日 模拟赛</title>
    <url>/2020/12/01/20%E5%B9%B412%E6%9C%881%E6%97%A5-%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>博弈论 + 模拟 + 贪心 + 状压 DP。</p>
<p><del>100(?) + 40(?) + 60 + 10 = 210（数据太水了）</del></p>
<p>48 + 20 + 60 + 10 = 138。</p>
<a id="more"></a>
<h2 id="t1-树树">T1 树树</h2>
<blockquote>
<p>给出 <span class="math inline">\(n\)</span> 个点的树，两人轮流染色，先手染黑，后手染白，染完后若存在一个黑点相邻的都是黑点则先手赢。问结局。</p>
<p><span class="math inline">\(2\le n \le 10^5\)</span>。</p>
</blockquote>
<p>原题 <a href="https://atcoder.jp/contests/agc014/tasks/agc014_d">AGC014D Black and White Tree</a></p>
<p>博弈论 + DP。</p>
<p>一些显然的性质（考场上写的部分分）：</p>
<ul>
<li>一条链，奇数个点先手赢；</li>
<li>树上某一个点有大于等于两个叶子节点，先手赢。</li>
</ul>
<p><strong>正解</strong></p>
<p>若一个点出度为二，且有一个儿子为叶子，先手一定会选择她，后手会选择那个叶子。</p>
<p>这两个点染完色对上方的点没有影响，相当于从原树中删去，剩下的树再如此考虑。</p>
<p>直到只剩根节点，或者某一个点有大于等于两个叶子节点，判先手赢。</p>
<p>可以发现这个 DP 过程就是树上完美匹配。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">int</span> head[N], nxt[N * <span class="number">2</span>], to[N * <span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        ++cnt, nxt[cnt] = head[u], to[cnt] = v, head[u] = cnt;</span><br><span class="line">        ++cnt, nxt[cnt] = head[v], to[cnt] = u, head[v] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; G;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> size[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = G.head[u]; i; i = G.nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = G.to[i];</span><br><span class="line">        <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v, u);</span><br><span class="line">        <span class="keyword">if</span> (size[v] == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">        size[u] += size[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (size[u] &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;First&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ++size[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        read(u), read(v);</span><br><span class="line">        G.add(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (size[<span class="number">1</span>] &amp; <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;First&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Second&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t2-网格">T2 网格</h2>
<h2 id="t3-有手就行">T3 有手就行</h2>
<blockquote>
<p>给出 <span class="math inline">\(n\)</span> 个物品，每个物品有两个权值 <span class="math inline">\(a_i,b_i\)</span>，一个物品最多选 <span class="math inline">\(3\)</span> 次：第一次 <span class="math inline">\(a_i\)</span>，第二次 <span class="math inline">\(b_i\)</span>，第三次 <span class="math inline">\(a_i\)</span>。</p>
<p><span class="math inline">\(f(i)\)</span> 为选 <span class="math inline">\(i\)</span> 个物品最大权值和，求 <span class="math inline">\(\displaystyle \operatorname{xor}_{i=1}^mf(i)\)</span>。</p>
<p><span class="math inline">\(1\le n\le 5\times 10^6,1\le m\le 3\times n\)</span>。</p>
</blockquote>
<p>一个物品选 <span class="math inline">\(1\dots3\)</span> 次的状态可以拆成两个物品：<span class="math inline">\(A_i=a_i\)</span> 和 <span class="math inline">\(B_i=a_i+b_i\)</span>，两类物品空间为 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(2\)</span>。</p>
<p>发现物品空间只有两种，可以贪心地将两类物品从大到小排序，之后 DP 就轻松了。</p>
<p>设 <span class="math inline">\(f_i\)</span> 为选 <span class="math inline">\(i\)</span> 个物品最大权值和，每个状态同时维护两类物品分别取到了第几个 <span class="math inline">\(p^A_i,p^B_i\)</span>： <span class="math display">\[
\large f_i\leftarrow \max\{f_{i-1}+A_{p^A_{i-1}},\quad f_{i-2}+B_{p^B_{i-2}}\}
\]</span> 复杂度就是 <span class="math inline">\(\mathcal O(n\log n + n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> threshold = <span class="number">10000000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e7</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">ull k1, k2;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ull <span class="title">Rand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ull k3 = k1, k4 = k2;</span><br><span class="line">    k1 = k4;</span><br><span class="line">    k3 ^= (k3 &lt;&lt; <span class="number">23</span>);</span><br><span class="line">    k2 = k3 ^ k4 ^ (k3 &gt;&gt; <span class="number">17</span>) ^ (k4 &gt;&gt; <span class="number">26</span>);</span><br><span class="line">    <span class="keyword">return</span> k2 + k4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">LL ans;</span><br><span class="line">LL a[N], b[N], f[N];</span><br><span class="line"><span class="keyword">int</span> pa[N], pb[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">gen</span><span class="params">(<span class="keyword">int</span> n, ull _k1, ull _k2)</span> </span>&#123;</span><br><span class="line">    k1 = _k1, k2 = _k2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        a[i] = Rand() % threshold + <span class="number">1</span>;</span><br><span class="line">        b[i] = Rand() % threshold + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ull k1, k2;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k1 &gt;&gt; k2;</span><br><span class="line">    gen(n, k1, k2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) b[i] += a[i];</span><br><span class="line">    sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    sort(b + <span class="number">1</span>, b + n + <span class="number">1</span>);</span><br><span class="line">    reverse(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    reverse(b + <span class="number">1</span>, b + n + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    pa[<span class="number">0</span>] = pb[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    f[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">    pa[<span class="number">1</span>] = <span class="number">2</span>, pb[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pa[i - <span class="number">1</span>] &lt;= n &amp;&amp; (f[i - <span class="number">1</span>] + a[pa[i - <span class="number">1</span>]] &gt; f[i - <span class="number">2</span>] + b[pb[i - <span class="number">2</span>]])) &#123;</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>] + a[pa[i - <span class="number">1</span>]];</span><br><span class="line">            pa[i] = pa[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            pb[i] = pb[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            f[i] = f[i - <span class="number">2</span>] + b[pb[i - <span class="number">2</span>]];</span><br><span class="line">            pa[i] = pa[i - <span class="number">2</span>];</span><br><span class="line">            pb[i] = pb[i - <span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) ans ^= f[i];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t4-求余数">T4 求余数</h2>
<blockquote>
<p>有多少长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(a\)</span>，满 足 <span class="math inline">\(1\le a_i \le m\)</span> 且对于任意 <span class="math inline">\(1\le i &lt; j \le n\)</span> 都满足 <span class="math inline">\(\gcd(a_i,a_j)=1\)</span>。</p>
<p><span class="math inline">\(n\le 10^5,m\le100,T\le 500\)</span>。</p>
</blockquote>
<p>数论 + 状压 DP。</p>
<p>其实只要先求所有数都 <span class="math inline">\(\ge 2\)</span> 的序列方案数，剩下的位置填 <span class="math inline">\(1\)</span> 即可。</p>
<p>观察到 <span class="math inline">\(m\)</span> 很小，将 <span class="math inline">\([2,m]\)</span> 的数的质因子出现的情况可以状压（<span class="math inline">\(100\)</span> 以内只有二十多个质数）。</p>
<p>进一步地，每个数大于 <span class="math inline">\(\sqrt{m}\)</span> 的质因子至多有 <span class="math inline">\(1\)</span> 个，所以只需要把 <span class="math inline">\(2,3,5,7\)</span> 四个质数压进状态，然后将 <span class="math inline">\([2,m]\)</span> 所有数按照（大于 <span class="math inline">\(7\)</span> 的）最大质因子分组。</p>
<p>对于质因子只有 <span class="math inline">\(2,3,5,7\)</span> 的数，用背包 DP 统计方案数，设 <span class="math inline">\(f_{i,j,S}\)</span> 表示前 <span class="math inline">\(i\)</span> 个数中选 <span class="math inline">\(j\)</span> 个数质因子状态为 <span class="math inline">\(S\)</span> 的方案数： <span class="math display">\[
f_{i,j,S}\leftarrow f_{i-1,j,S}+f_{i-1,j-1,S-p(x)}
\]</span> 对于分组后每一组的数，一个状态中至多选一个，同理进行 DP。</p>
<p>注意上界最多选二十多个数，并且第一维可以省去。</p>
<p>然后统计选 <span class="math inline">\(i\)</span> 个数的方案数为 <span class="math inline">\(g_i\)</span>，最后答案为： <span class="math display">\[
\begin{aligned}
&amp;\sum_{i=0}^{\min\{m,30\}}g_i\times i!\times \binom{n}{i}\\
&amp;=n!\times\sum_{i=0}^{\min\{m,30\}} g_i\times \frac{1}{(n-i)!}
\end{aligned}
\]</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">109</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Lim = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, m;</span><br><span class="line"><span class="keyword">int</span> p[M], f[M][<span class="number">20</span>], g[M], fac[N], ifac[N];</span><br><span class="line"><span class="keyword">int</span> prime[] = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) a[i].clear();</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span> p);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = prime[j];</span><br><span class="line">            <span class="keyword">if</span> (t % k) <span class="keyword">continue</span>;</span><br><span class="line">            p[i] |= <span class="number">1</span> &lt;&lt; j;</span><br><span class="line">            <span class="keyword">while</span> (t % k == <span class="number">0</span>) t /= k;</span><br><span class="line">        &#125;</span><br><span class="line">        a[t].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lm = <span class="number">1e5</span>;</span><br><span class="line">    fac[<span class="number">0</span>] = ifac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lm; ++i) fac[i] = (LL)fac[i - <span class="number">1</span>] * i % P;</span><br><span class="line">    ifac[lm] = power(fac[lm], P - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lm - <span class="number">1</span>; i; --i) ifac[i] = (LL)ifac[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % P;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        clear();</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        dec();</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)a[<span class="number">1</span>].size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = a[<span class="number">1</span>][i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">30</span>; j; --j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; Lim; ++s) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((s &amp; p[x]) != p[x]) <span class="keyword">continue</span>;</span><br><span class="line">                    f[j][s] = (f[j][s] + f[j - <span class="number">1</span>][s ^ p[x]]) % P;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i].empty()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">30</span>; j; --j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; Lim; ++s) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; (<span class="keyword">int</span>)a[i].size(); ++k) &#123;</span><br><span class="line">                        <span class="keyword">int</span> x = a[i][k];</span><br><span class="line">                        <span class="keyword">if</span> ((s &amp; p[x]) != p[x]) <span class="keyword">continue</span>;</span><br><span class="line">                        f[j][s] = (f[j][s] + f[j - <span class="number">1</span>][s ^ p[x]]) % P;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">30</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt;= Lim; ++s) g[i] = (g[i] + f[i][s]) % P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= min(m, <span class="number">30</span>); ++i) &#123;</span><br><span class="line">            ans = (ans + (LL)g[i] * ifac[n - i]) % P;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = (LL)ans * fac[n] % P;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
  </entry>
  <entry>
    <title>CSP2020 游记</title>
    <url>/2020/11/06/CSP2020-%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>多图警告⚠️。</p>
<a id="more"></a>
<h2 id="初赛">初赛</h2>
<p>没啥感觉，水过去了。</p>
<blockquote>
<p>教练：只要你们听话，初赛保你们过。</p>
</blockquote>
<h2 id="复赛">复赛</h2>
<h3 id="day0">day0</h3>
<p>上午坐公交车，晕，睡。</p>
<p>我的手机在 n 老师那里，关着机但是没关闹钟……</p>
<p>上了动车，发现坐在过道，我得坐四五站，但是靠窗的的位置每到一站就换一个人。</p>
<p>后来我就<del>死皮赖脸地</del>坐在靠窗的位置，还好每次来的都是比较和善的大叔，都答应了。</p>
<p>到了燕大，门口有个坡，客车上不去 2333。</p>
<p>那个铭牌生锈的燕大宾馆不见了，取而代之的是闲庭四艺酒店（Four Arts Hotel），wow，全部装修了一番，<del>甲醛的味道</del>书墨的香气蛮浓的。</p>
<p><img src="https://s1.ax1x.com/2020/11/07/B46SjU.jpg" /></p>
<p><img src="https://s1.ax1x.com/2020/11/07/B4yzcT.jpg" /></p>
<p><img src="https://s1.ax1x.com/2020/11/07/B4yx3V.jpg" /></p>
<p><img src="https://s1.ax1x.com/2020/11/07/B4yXhq.jpg" /></p>
<p><img src="https://s1.ax1x.com/2020/11/07/B46PHJ.jpg" /></p>
<p>每一房间都有《宋代书画》，还有《毕业季》（看起来是言情小说？）。</p>
<p><img src="https://s1.ax1x.com/2020/11/07/B46PHJ.jpg" /></p>
<p>下午就开始模拟赛。</p>
<p>T1 算是模拟填数题？细节烦人，刚了两个小时才过大样例，心态大崩。</p>
<p>T2 结论题，打表找半天规律没成，摸了。</p>
<p>T4 数位 DP，推了会儿式子，调了快一个小时，大样例过了。</p>
<p>T3 时间紧，暴力都没写，听说很毒瘤。</p>
<p>和 ywk 一个房间，晚上想迫害他去隔壁房间玩恐怖游戏，没成 qwq。</p>
<p>题解数据发了，T1 写搜索这么轻松？？？T4 我正解写挂，和分块打表一个分？？？T2就这？？？</p>
<p>感觉 CSP 悬啊。<img src="https://cdn.jsdelivr.net/gh/xaoxuu/volantis@1.0.6/img/qq/快哭了.gif" /></p>
<p>不管了，明天再说。</p>
<h3 id="day0.5">day0.5</h3>
<p>失败的开始。</p>
<p>十点多洗完澡往床上一摊，“这个床好软啊~”</p>
<p>翻来覆去一个多小时没睡着，太软了感觉怎么躺都腰肩酸痛（硬板床睡习惯了），十二点时无奈之下下床做了几个俯卧撑，趁着疲惫睡去。</p>
<p>为什么我的鼻子对被子和枕头过敏啊！！！</p>
<p>在梦里都感觉呼吸困难，迷糊的我知道是鼻窦炎发作了，不过为了保证充足的睡眠，决定扛到天亮。</p>
<p>然后就因为差点窒息而被迫清醒了过来。</p>
<p>怎么才 3 点多啊？？？还得睡下去。（居然会有一天觉得睡觉很痛苦。QAQ）</p>
<p>把枕头用外套包起来，把能穿的衣服都穿在身上，被子只盖下半身。喷了一些药，睡。</p>
<p>这一觉还算舒畅，可惜只睡了 3 个小时。ywk 要考 PJ，7 点左右就有人来敲门。</p>
<h3 id="day1">day1</h3>
<p>一个上午都在颓废打音游打雀魂，想补觉没补成。</p>
<p>中午临时冲了杯咖啡，就去考试了。</p>
<p>密码输了五六遍没对，告诉我 <code>()</code> 也是密码？？？</p>
<p>开场<del>大力敲击键盘</del>慢悠悠地建完文件夹，读了半小时题，读完题后懵了。</p>
<p>T1 似乎写个二分在加亿点细节就好，woc 码不出来啊，调不对啊。刚了一个半小时才过大样例，还是悬。</p>
<p>T2 什么算法啊，是模拟吗？乱写一通过了大样例。</p>
<p>只剩 45 分钟了，写 T3 暴力，似乎线段树暴力做还算好写，还剩 15 分钟时调完，不知道能拿多少分。不过后来听说是个图论题。</p>
<p>花五分钟看 T4 发现 20 分白给，慌忙糊了几行。（考后发现把“不降”看成“不降”了，白给的 20 分没了。）</p>
<p>linux 下整理完了，还剩 2 分钟在 win7 发现莫名其妙有个叫 <code>@#</code> 的文件。</p>
<p>考完大脑有点晕。</p>
<hr />
<p>晚上一块去看海。</p>
<p><img src="https://s1.ax1x.com/2020/11/07/BIaxPK.jpg" /></p>
<p><img src="https://s1.ax1x.com/2020/11/07/BIasgg.jpg" /></p>
<p><img src="https://s1.ax1x.com/2020/11/07/BIar8S.jpg" /></p>
<p><img src="https://s3.ax1x.com/2020/12/05/DL74v8.jpg" /></p>
<p>不想吃晚饭，和 wxh，ycs，wgx 一块买了冷饮（本来想买奶茶的），然后寒风中在街边摊位等薯条汉堡。</p>
<p>回宿舍颓颓颓。</p>
<h2 id="后续">后续</h2>
<p>什么信竞题库有了民间数据，T1 85（数据水？），T2 90（破服务器卡常），T3 75，T4 0。</p>
<p>然后牛客似乎也有了，T1 40，T2 95。</p>
<p>洛谷上 T1 也是 40，看了 T1 真的挂没了，T2 被卡常 70，T3 30 比较真实。</p>
<p>这回考的都是什么啊，T1 出题人谁啊！！！</p>
<p>官方成绩出来，数据特特特别水，似乎到处被喷。</p>
<p>最后 100 + 95 + 70 + 0 = 265，辣鸡 RenaMoe。</p>
<p>膜拜 <a href="https://www.luogu.com.cn/user/120033">iuyi</a> 330 分巨佬 Orz。</p>
<h2 id="总结">总结</h2>
<p>虽然这次比赛不怎么重要，并且题目方向比较，但是暴露了不少问题。</p>
<ul>
<li>考试策略依旧不当，T1 写太久，后面题差点没时间写暴力。</li>
<li>代码能力差，主要为 T1 的问题，还是做题少写得慢。</li>
<li>没有对拍，不太会造数据。</li>
</ul>
<p>其它知识能力问题 NOIP 之前可能解决不了多少，毕竟 whk 太差了来机房时间有限。</p>
<p>以后周末多打打 cf 和 oi 赛制模拟赛吧，一定要把自己会的发挥好。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>NOIP2020 游记</title>
    <url>/2020/12/05/NOIP2020-%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p><del>没什么实感啊。</del>我考的什么玩意啊。</p>
<a id="more"></a>
<p><del>这次手机全程在 n 老师那里，没有照片。</del>照片都是 piao 来的。</p>
<h2 id="day-0">day 0</h2>
<p>早上被骗去做 <span class="math inline">\(\rm \color{black}{A}\color{red}{zusaCat}\)</span> 的题 <a href="https://www.luogu.com.cn/problem/U144136">U144136 距离</a>，倍增 + 二分好妙啊，写挂好多细节。</p>
<p>然后还没咋敲板子题就该走了。</p>
<p>火车上想敲板子，有点晕，敲不动，连扫描线都没敲完。</p>
<p>有趣的是今天的伙食：</p>
<p>中午提前去超市买了泡面，特意选了白象的（汤确实好喝），没看清买了金汤酸菜鱼。（谁知道那玩意是辣的啊！）</p>
<p>我是几乎不吃辣的，火车上把面送进嘴里的时候我是绝望的。</p>
<p>或许我当时红着嘴唇、小口又急促地喘气的样子很可笑吧。</p>
<p>算了算了真烦，强迫自己睡了一觉。</p>
<p>这次住首旅京伦酒店，听说是海景房，很期待。</p>
<p><img src="https://s3.ax1x.com/2020/12/05/DLOGkQ.jpg" /></p>
<p>打开房间门，看见了一面巨大的接地窗，能够清晰地看到。。。旁边的工地。</p>
<p>不过比上次的闲庭四艺酒店的空气好多了，在屋子里待着鼻窦炎没有发作。</p>
<p>幸好我爸和我一起来了，带着一套自家的枕头被子，终于能好好睡一觉了。</p>
<p>到秦皇岛的宾馆就该吃晚饭了？时间过得好快，板子题还没咋敲，我慌了。</p>
<p>点了 KFC 的外卖，又眼瞎了，点了个辣堡。不过一点辣味都没有，不知道是不是该高兴。</p>
<p>说实话这 19 块钱的汉堡做得和 石门 六块钱的汉堡差不多，莫名其妙开始想念石门。</p>
<p>晚上继续<del>水裙</del>敲板子，敲了两道然后就该睡觉了？</p>
<h2 id="day-1">day 1</h2>
<p>好像什么都不会就去考试的感觉。</p>
<figure>
<img src="https://s3.ax1x.com/2020/12/05/DLO3Tg.jpg" alt="早上风景还行" /><figcaption aria-hidden="true">早上风景还行</figcaption>
</figure>
<p>早饭没有胃口，但是吃完了差点迟到。</p>
<p>含着糖，算是撑住了没晕车。</p>
<figure>
<img src="https://s3.ax1x.com/2020/12/05/DLzxYD.jpg" alt="考前二中合影" /><figcaption aria-hidden="true">考前二中合影</figcaption>
</figure>
<p>座位号 <code>5-14</code>？我害怕极了。</p>
<p>经考场前得先用免洗洗手液洗手，一不小心挤多了，手上全是酒精，一时还干不了，拿着弄湿的准考证给监考员时有点尴尬。</p>
<p>坐在座位上看见玻璃外面是 <span class="math inline">\(\rm \color{black}{l}\color{red}{hm\_}\)</span>，为了告诉他不要像我一样犯傻，专门打手势告诉他，<del>不知道他懂了没有</del>他只是一直点头。</p>
<p>发现座位右前方是集训队爷，我害怕极了。</p>
<hr />
<p>开考没输错解压密码，好评。</p>
<p>T1，拓扑一下，再手写一下分数，过。</p>
<p>T2，卡住了，用哈希判循环节 <span class="math inline">\(\mathcal O(1)\)</span>，枚举约数 <span class="math inline">\(\mathcal O(\log n)\)</span>，就是不知道怎么二维数点，<span class="math inline">\(\log 26\cdot\log n\)</span> 和 <span class="math inline">\(26\log n\)</span> 能差多少啊！边写边改，写了个 <span class="math inline">\(\mathcal O(26\cdot n\log n)\)</span>，预计 <span class="math inline">\(68\)</span> ~ <span class="math inline">\(84\)</span> 分。</p>
<p>T3，什么鬼玩意，暴力都不会写。</p>
<p>T4，貌似可以倍增？码了半个多小时一个倍增 + 两个二分，发现自己复杂度的瓶颈在于 <span class="math inline">\(\mathcal O(w^k)\)</span> 枚举起点，删掉了。时间不够了，写个朴素的 <span class="math inline">\(30\)</span> 分暴力就跑。</p>
<p>跑个毛线，该交卷了。</p>
<p>恍惚的一下子就结束了。</p>
<hr />
<p>有点失落。</p>
<p>突然想起 T2 二维数点直接二维前缀和就好了，就可以少去那个 <span class="math inline">\(26\)</span> 的常数了。</p>
<p>水群时发现 T1 得写高精（其实考场上想过会不会爆 <code>long long</code>，但是不会构造又懒得写，就不管了）。</p>
<p><a href="https://www.oitiku.com/">信奥题库</a> 好快啊，马上就有了数据，虽然似乎很水。</p>
<p>测了一下，90 + 84 + 0 + 30 = 204。</p>
<p>担心官方数据 T1 会不会被卡成狗。</p>
<p>说实话觉得自己什么都不会。</p>
<p><img src="https://s3.ax1x.com/2020/12/05/DLx25D.png" /></p>
<p>还真就考了高精，我退役就是。</p>
<p><span class="math inline">\(\rm \color{black}{y}\color{red}{ouwike}\)</span> 好强啊，初三就考的比我高。</p>
<figure>
<img src="https://s3.ax1x.com/2020/12/05/DLHkP1.jpg" alt="youwike 考好的秘诀" /><figcaption aria-hidden="true">youwike 考好的秘诀</figcaption>
</figure>
<h2 id="尾声">尾声</h2>
<p>因为高二学考，高一就放假三天。</p>
<p>回家就开始颓颓颓，生活作息极不规律。</p>
<p>已经预感到事情不对了，等成绩一发：</p>
<p>60 + 84 + 0 + 25 = 169。</p>
<p>T1 卡成狗，不过这成绩也符合我的真实水平。</p>
<p>不过省排名 rk18 -&gt; rk28，感觉 7 级没希望了，不知道有没有省一。</p>
<p>菜是原罪，最后还是把命运交给了出题人。</p>
<p>回去补了一周文化课，月考前临时抱佛脚。</p>
<p>再后来发现 T1 可以用 <code>long double</code> 诶。</p>
<h2 id="总结">总结</h2>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>总结 四边形不等式优化DP</title>
    <url>/2020/11/21/%E6%80%BB%E7%BB%93-%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%BC%98%E5%8C%96DP/</url>
    <content><![CDATA[<p>四边形不等式优化是对特定形式的状态转移方程进行优化的一种方法。</p>
<a id="more"></a>
<p>开坑！</p>
<hr />
<p>对于 2D1D 的 DP（比如石子合并一类的区间 DP）： <span class="math display">\[
f_{i,j}=\min_{i\le k&lt;j}\{f_{i,k}+f_{k+1,j}\}+cost(i,j)
\]</span> 可以通过四边形不等式从 <span class="math inline">\(\mathcal O(n^3)\)</span> 优化到 <span class="math inline">\(\mathcal O(n^2)\)</span>。</p>
<h2 id="step-1证明-cost-为凸">step 1：证明 cost 为凸</h2>
<p>对于 <span class="math inline">\(i&lt;i+1\le j&lt;j+1\)</span>： <span class="math display">\[
w(i,j)+w(i+1,j+1)\le w(i+1,j)+w(i,j+1)
\]</span></p>
<h2 id="step-2证明-dp-为凸">step 2：证明 DP 为凸</h2>
<p>同理，对于 <span class="math inline">\(i&lt;i+1\le j&lt;j+1\)</span>： <span class="math display">\[
f(i,j)+f(i+1,j+1)\le f(i+1,j)+f(i,j+1)
\]</span></p>
<h2 id="step-3证明决策单调性">step 3：证明决策单调性</h2>
<p>设 <span class="math inline">\(g(i,j)\)</span> 为 <span class="math inline">\(f(i,j)\)</span> 的最优决策点： <span class="math display">\[
g(i,j-1)\le g(i,j) \le g(i+1,j)
\]</span></p>
<h2 id="应用">应用</h2>
<p><del>猜单调性后打表证明。</del></p>
<p><del>发现不行就改改式子往上套。</del></p>
<p>咕~</p>
]]></content>
      <categories>
        <category>总结</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>单调性优化</tag>
      </tags>
  </entry>
  <entry>
    <title>常用组合数</title>
    <url>/2020/10/24/%E6%80%BB%E7%BB%93-%E5%B8%B8%E7%94%A8%E7%BB%84%E5%90%88%E6%95%B0/</url>
    <content><![CDATA[<p>包括组合数、卡特兰数、第一二类斯特林数等。</p>
<a id="more"></a>
<h2 id="组合数">组合数</h2>
<p><span class="math display">\[
\begin{align}
\binom{n}{m}&amp;=\frac{n!}{(n-m)!m!}\\
\binom{n}{m}&amp;=\binom{n-1}{m}+\binom{n-1}{m-1}
\end{align}
\]</span></p>
<h3 id="插板法">插板法</h3>
<blockquote>
<p>将 <span class="math inline">\(n\)</span> 个相同物品分为 <span class="math inline">\(k\)</span> 组（非空）的方案数。</p>
</blockquote>
<p>对于 <span class="math inline">\(n\)</span> 个点，相邻两个有一个槽，插入 <span class="math inline">\(k-1\)</span> 个板，也就分成了 <span class="math inline">\(k\)</span> 组。</p>
<p>所以答案为 <span class="math inline">\(\displaystyle \binom{n-1}{k-1}\)</span>。</p>
<h3 id="多重集的组合数">多重集的组合数</h3>
<blockquote>
<p>从 <span class="math inline">\(n\)</span> 个数中选出 <span class="math inline">\(k\)</span> 个数组成多重集的方案数。</p>
</blockquote>
<p>等价于解 <span class="math inline">\(x_1+x_2+x_3+\cdots +x_n=k\)</span> 的非负整数解个数。</p>
<p>答案： <span class="math display">\[
\binom{n+k-1}{k-1}
\]</span> 插板法：在原来的 <span class="math inline">\(n-1\)</span> 个槽基础上再加 <span class="math inline">\(k\)</span> 个槽，被选则表示该组为空。</p>
<h2 id="卡特兰数">卡特兰数</h2>
<p><a href="https://oi-wiki.org/math/catalan/">详见OI Wiki</a></p>
<table>
<thead>
<tr class="header">
<th><span class="math inline">\(H_0\)</span></th>
<th><span class="math inline">\(H_1\)</span></th>
<th><span class="math inline">\(H_2\)</span></th>
<th><span class="math inline">\(H_3\)</span></th>
<th><span class="math inline">\(H_4\)</span></th>
<th><span class="math inline">\(H_5\)</span></th>
<th><span class="math inline">\(H_6\)</span></th>
<th>...</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>1</td>
<td>2</td>
<td>5</td>
<td>14</td>
<td>42</td>
<td>132</td>
<td>...</td>
</tr>
</tbody>
</table>
<h3 id="常用公式">常用公式：</h3>
<p><span class="math display">\[
\begin{align}
H_n&amp;=\frac{1}{n+1}\dbinom{2n}{n}
\\
H_n&amp;=\dbinom{2n}{n}-\dbinom{2n}{n-1}
\\
H_n&amp;=\begin{cases}
\sum_{i=1}^{n}H_{i-1}H_{n-i} &amp;n\ge2,n\in\mathbb{N_{+}}\\
1 &amp;n=0,1
\end{cases}
\\
H_n&amp;=\frac{4n-2}{n+1}H_{n-1}\\
\end{align}
\]</span></p>
<h3 id="应用">应用</h3>
<p><span class="math inline">\(H_n\)</span>：</p>
<ol type="1">
<li><p>表示由 <span class="math inline">\(n\)</span> 个节点组成不同构二叉树的方案数。</p></li>
<li><p>表示有 <span class="math inline">\(2n+1\)</span> 个节点组成不同构满二叉树的方案数。</p></li>
<li><p>表示通过连接顶点将 <span class="math inline">\((n+2)\)</span> 边的凸多边形分成三角形的方法个数。</p></li>
<li><p>表示在 <span class="math inline">\(n\times n\)</span> 的网格图中不越过对角线的路径条数。</p></li>
<li><p>表示长度为 <span class="math inline">\(2n\)</span> 的 <span class="math inline">\(\texttt{dyck word}\)</span> 个数(有 <span class="math inline">\(n\)</span> 个"X"与 <span class="math inline">\(n\)</span> 个"Y"组成的字符串，满足前缀“X”的个数大于等于前缀“Y”的个数)。</p></li>
</ol>
<h2 id="第一类斯特林数">第一类斯特林数</h2>
<p>表示将 <span class="math inline">\(n\)</span> 个两两不同的元素，划分为 <span class="math inline">\(k\)</span> 个非空圆排列的方案数。 <span class="math display">\[
\begin{bmatrix}n\\k\end{bmatrix}=\begin{bmatrix}n-1\\k-1\end{bmatrix}+(n-1)\begin{bmatrix}n-1\\k\end{bmatrix}
\]</span> 边界 <span class="math inline">\(\displaystyle \begin{bmatrix}n\\0\end{bmatrix}=[n=0]\)</span>。</p>
<h2 id="第二类斯特林数">第二类斯特林数</h2>
<p>表示将 <span class="math inline">\(n\)</span> 个两两不同的元素，划分为 <span class="math inline">\(k\)</span> 个非空子集的方案数。 <span class="math display">\[
\begin{Bmatrix}n\\k\end{Bmatrix}=\begin{Bmatrix}n-1\\k-1\end{Bmatrix}+k\begin{Bmatrix}n-1\\k\end{Bmatrix}
\]</span> 边界 <span class="math inline">\(\displaystyle \begin{Bmatrix}n\\0\end{Bmatrix}=[n=0]\)</span>。</p>
]]></content>
      <categories>
        <category>总结</category>
        <category>Math</category>
      </categories>
      <tags>
        <tag>组合数</tag>
      </tags>
  </entry>
  <entry>
    <title>总结 树链剖分</title>
    <url>/2019/12/25/%E6%80%BB%E7%BB%93-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/</url>
    <content><![CDATA[<p>咕了很久，敲完才体会到什么是“出题人<del>毫无意义地</del>强行把代码增加5KB”</p>
<hr />
<p>首先，树剖是把一棵树划分成多条轻重链，然后用线段树维护这些链</p>
<a id="more"></a>
<p><a href="https://www.luogu.org/problem/P3384">模板题</a></p>
<p>通过基础的树剖，可以做以下操作：</p>
<ul>
<li>将树从x到y最短路径上的权值都加上z</li>
<li>求树从x到y最短路径上的权值和</li>
<li>将以x为根节点的子树内权值都加上z</li>
<li>求将以x为根节点的子树内的权值和</li>
</ul>
<h2 id="具体做法">具体做法:</h2>
<h3 id="dfs1">dfs1</h3>
<p>遍历一遍树，求出每个点的：</p>
<p><span class="math inline">\(fa[x]\)</span>：父亲</p>
<p><span class="math inline">\(deep[x]\)</span>：深度</p>
<p><span class="math inline">\(sz[x]\)</span>：子树大小</p>
<p><span class="math inline">\(son[x]\)</span>：重儿子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">    fa[x] = last;</span><br><span class="line">    deep[x] = deep[last] + <span class="number">1</span>;</span><br><span class="line">    sz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> y, maxson = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != last) &#123;</span><br><span class="line">            y = e[i].to;</span><br><span class="line">            dfs1(y, x);</span><br><span class="line">            sz[x] += sz[y];</span><br><span class="line">            <span class="keyword">if</span> (sz[y] &gt; maxson)</span><br><span class="line">                maxson = sz[y], son[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dfs2">dfs2</h3>
<p>第二遍遍历要划分轻重链，先求出：</p>
<p><span class="math inline">\(id[x]\)</span>：x的<span class="math inline">\(dfs\)</span>序</p>
<p><span class="math inline">\(top[x]\)</span>：x所在链的起始点</p>
<p>注意先走重儿子，再遍历轻儿子，使得重链每个点的<span class="math inline">\(dfs\)</span>序一定是连续的</p>
<p>根据<span class="math inline">\(dfs\)</span>序的性质，x的子树每个点的<span class="math inline">\(dfs\)</span>序也是连续的</p>
<p>因此可以用线段树维护得到的<span class="math inline">\(dfs\)</span>序（记得把权值转移到<span class="math inline">\(dfs\)</span>序上）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> top_)</span> </span>&#123;</span><br><span class="line">    id[x] = ++cnt;</span><br><span class="line">    top[x] = top_;</span><br><span class="line">    segtree.val[id[x]] = val[x];<span class="comment">// 转移权值</span></span><br><span class="line">    <span class="keyword">if</span> (!son[x])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    dfs2(son[x], top_);<span class="comment">// 先重儿子</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != fa[x] &amp;&amp; e[i].to != son[x])</span><br><span class="line">            dfs2(e[i].to, e[i].to);<span class="comment">// 轻儿子新开一条链</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线段树">线段树</h3>
<p>直接在<span class="math inline">\(dfs\)</span>序上建立线段树，套模板即可</p>
<p>这里就不贴code了</p>
<blockquote>
<p>update on 2020.1.21</p>
<p>听学长讲，对于每个链单独开一棵线段树可以减小常数</p>
</blockquote>
<hr />
<p>下面是<del>愉快的</del>各种操作。。。</p>
<h3 id="路径修改查询">路径修改/查询</h3>
<p>对于每个x和y</p>
<p>我们可以不停的让<strong>深度大的</strong>跳到所在链的顶部，在线段树上直接操作一个链</p>
<p>直到x和y在同一个链上，然后还是线段树操作</p>
<p>（注意，让深度小的往上跳，可能会错过最短路径）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change_road</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deep[x] &lt; deep[y])</span><br><span class="line">        swap(x, y);<span class="comment">// 选深度大的</span></span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y]) &#123;<span class="comment">// 不在同一条链时</span></span><br><span class="line">        <span class="keyword">if</span> (deep[top[x]] &lt; deep[top[y]])</span><br><span class="line">            swap(x, y);<span class="comment">//注意深度</span></span><br><span class="line">        segtree.change(<span class="number">1</span>, <span class="number">1</span>, n, id[top[x]], id[x], k);<span class="comment">// 注意顺序，链顶的id一定大于x的id</span></span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (deep[x] &gt; deep[y])</span><br><span class="line">        swap(x, y);<span class="comment">// 注意顺序</span></span><br><span class="line">    segtree.change(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[y], k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>路径查询同理，就不贴了</p>
<blockquote>
<p>话说这里太容易出bug了 QAQ</p>
</blockquote>
<h3 id="子树修改查询">子树修改/查询</h3>
<p>因为以x为根的子树在<span class="math inline">\(dfs\)</span>序上一定是连续的一段</p>
<p>线段树直接操作<span class="math inline">\(id[x]\)</span>到<span class="math inline">\(id[x]+sz[x]-1\)</span>的区间</p>
<p><code>segtree.change(1, 1, n, id[x], id[x]+sz[x]-1, z);</code></p>
<p>查询同理</p>
<hr />
<h3 id="luogup3384-ac代码">LuoguP3384 AC代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BANANA &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; T k = <span class="number">1</span>; <span class="keyword">char</span> in = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(in)) &#123; <span class="keyword">if</span> (in == <span class="string">&#x27;-&#x27;</span>) k = <span class="number">-1</span>; in = getchar(); &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(in)) x = x * <span class="number">10</span> + in - <span class="string">&#x27;0&#x27;</span>, in = getchar();</span><br><span class="line">    x *= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> nxt, to;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segtree</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Leave</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> ls, rs, sum, lazy;</span><br><span class="line">    &#125;;</span><br><span class="line">    Leave tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> mod, cnt;</span><br><span class="line">    <span class="keyword">int</span> val[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> suc)</span> </span>&#123;</span><br><span class="line">        tr[suc].sum = (tr[tr[suc].ls].sum + tr[tr[suc].rs].sum) % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ls = tr[suc].ls, rs = tr[suc].rs, mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        (tr[ls].lazy += tr[suc].lazy) %= mod;</span><br><span class="line">        (tr[ls].sum += (mid - L + <span class="number">1</span>) * tr[suc].lazy) %= mod;</span><br><span class="line">        (tr[rs].lazy += tr[suc].lazy) %= mod;</span><br><span class="line">        (tr[rs].sum += (R - mid) * tr[suc].lazy) %= mod;</span><br><span class="line">        tr[suc].lazy = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        tr[suc].lazy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">            tr[suc].sum = val[L];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        tr[suc].ls = ++cnt, tr[suc].rs = ++cnt;</span><br><span class="line">        build(tr[suc].ls, L, mid), build(tr[suc].rs, mid+<span class="number">1</span>, R);</span><br><span class="line">        push_up(suc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> cl, <span class="keyword">int</span> cr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cl &lt;= L &amp;&amp; R &lt;= cr) &#123;</span><br><span class="line">            (tr[suc].sum += (R - L + <span class="number">1</span>) * k) %= mod;</span><br><span class="line">            (tr[suc].lazy += k) %= mod;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        push_down(suc, L, R);</span><br><span class="line">        <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (cl &lt;= mid)</span><br><span class="line">            change(tr[suc].ls, L, mid, cl, cr, k);</span><br><span class="line">        <span class="keyword">if</span> (cr &gt; mid)</span><br><span class="line">            change(tr[suc].rs, mid+<span class="number">1</span>, R, cl, cr, k);</span><br><span class="line">        push_up(suc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= L &amp;&amp; R &lt;= qr)</span><br><span class="line">            <span class="keyword">return</span> tr[suc].sum;</span><br><span class="line">        push_down(suc, L, R);</span><br><span class="line">        <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (qr &lt;= mid)</span><br><span class="line">            <span class="keyword">return</span> query(tr[suc].ls, L, mid, ql, qr);</span><br><span class="line">        <span class="keyword">if</span> (ql &gt; mid)</span><br><span class="line">            <span class="keyword">return</span> query(tr[suc].rs, mid+<span class="number">1</span>, R, ql, qr);</span><br><span class="line">        <span class="keyword">return</span> (query(tr[suc].ls, L, mid, ql, qr) + query(tr[suc].rs, mid+<span class="number">1</span>, R, ql, qr)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, Q, root, mod, cnt;</span><br><span class="line"><span class="keyword">int</span> head[N], val[N], deep[N], sz[N], fa[N], son[N], top[N], id[N];</span><br><span class="line">Edge e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line">Segtree segtree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[++cnt] = (Edge)&#123;head[u], v&#125;, head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = a;</span><br><span class="line">    a = b, b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">    fa[x] = last;</span><br><span class="line">    deep[x] = deep[last] + <span class="number">1</span>;</span><br><span class="line">    sz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> y, maxson = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != last) &#123;</span><br><span class="line">            y = e[i].to;</span><br><span class="line">            dfs1(y, x);</span><br><span class="line">            sz[x] += sz[y];</span><br><span class="line">            <span class="keyword">if</span> (sz[y] &gt; maxson)</span><br><span class="line">                maxson = sz[y], son[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> top_)</span> </span>&#123;</span><br><span class="line">    id[x] = ++cnt;</span><br><span class="line">    top[x] = top_;</span><br><span class="line">    segtree.val[id[x]] = val[x];</span><br><span class="line">    <span class="keyword">if</span> (!son[x])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    dfs2(son[x], top_);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != fa[x] &amp;&amp; e[i].to != son[x])</span><br><span class="line">            dfs2(e[i].to, e[i].to);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change_road</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deep[x] &lt; deep[y])</span><br><span class="line">        swap(x, y);</span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deep[top[x]] &lt; deep[top[y]])</span><br><span class="line">            swap(x, y);</span><br><span class="line">        segtree.change(<span class="number">1</span>, <span class="number">1</span>, n, id[top[x]], id[x], k);</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (deep[x] &gt; deep[y])</span><br><span class="line">        swap(x, y);</span><br><span class="line">    segtree.change(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[y], k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query_road</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deep[x] &lt; deep[y])</span><br><span class="line">        swap(x, y);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deep[top[x]] &lt; deep[top[y]])</span><br><span class="line">            swap(x, y);</span><br><span class="line">        (res += segtree.query(<span class="number">1</span>, <span class="number">1</span>, n, id[top[x]], id[x])) %= mod;</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (deep[x] &gt; deep[y])</span><br><span class="line">        swap(x, y);</span><br><span class="line">    (res += segtree.query(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[y])) %= mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(Q), read(root), read(mod);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        read(val[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++i)</span><br><span class="line">        read(u), read(v), add(u, v), add(v, u);</span><br><span class="line">    dfs1(root, <span class="number">0</span>);</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    dfs2(root, root);</span><br><span class="line">    segtree.mod = mod, segtree.cnt = <span class="number">1</span>;</span><br><span class="line">    segtree.build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> opt, x, y, z;</span><br><span class="line">    <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">        read(opt);</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                read(x), read(y), read(z);</span><br><span class="line">                change_road(x, y, z);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                read(x), read(y);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, query_road(x, y));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                read(x), read(y);</span><br><span class="line">                segtree.change(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[x]+sz[x]<span class="number">-1</span>, y);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                read(x);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, segtree.query(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[x]+sz[x]<span class="number">-1</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BANANA::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次写的时候太艰辛了，调了半天发现是<span class="math inline">\(swap()\)</span>写错了<span class="math inline">\(qwq\)</span></p>
]]></content>
      <categories>
        <category>总结</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>总结 莫队</title>
    <url>/2020/12/17/%E6%80%BB%E7%BB%93-%E8%8E%AB%E9%98%9F/</url>
    <content><![CDATA[<p>基于分块优化的暴力。</p>
<p>离线算法，适用于能够快速加减单点的贡献的区间询问。</p>
<a id="more"></a>
<h2 id="普通莫队">普通莫队</h2>
<p>板子题：<a href="https://www.luogu.com.cn/problem/P1494">P1494 「国家集训队」小Z的袜子</a> 或者：<a href="https://www.luogu.com.cn/problem/P2709">P2709 小B的询问</a>。</p>
<blockquote>
<p>给出长为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(a\)</span>，每次询问区间内 <span class="math inline">\(\displaystyle \sum_{i=l}^r a_i^2\)</span>。</p>
</blockquote>
<p>从暴力开始优化：</p>
<p>一个区间询问可以移动左右端点来得到另一个区间询问的答案，从而避免重复计算两个区间重叠的部分，那就设两个指针 <span class="math inline">\(l,r\)</span>，在序列上移动。</p>
<p>但还是会被卡成 <span class="math inline">\(\mathcal O(n^2)\)</span>。</p>
<p>于是将询问 <span class="math inline">\([l,r]\)</span> 离线下来排序，怎么排？</p>
<p>将序列分块，<span class="math inline">\(l\)</span> 所在块相同就按右端点排，不同就按 <span class="math inline">\(l\)</span> 所在块排。</p>
<h3 id="复杂度">复杂度</h3>
<p>对于 <span class="math inline">\(l\)</span>，每个块内有 <span class="math inline">\(k_i\)</span> 个询问，块内最坏 <span class="math inline">\(\mathcal O(k_i\sqrt{n})\)</span>，总共 <span class="math inline">\(\mathcal O(\sum k_i\sqrt{n})=\mathcal O(n\sqrt{n})\)</span>。</p>
<p>对于 <span class="math inline">\(r\)</span>，每个块最坏移动 <span class="math inline">\(n\)</span> 次，总共 <span class="math inline">\(\mathcal O(n\sqrt{n})\)</span>。</p>
<p>不考虑计算答案复杂度，这样莫队的总体复杂度就是 <span class="math inline">\(\mathcal O(n\sqrt{n})\)</span>。</p>
<h3 id="奇偶性优化">奇偶性优化</h3>
<p>为了衔接相邻两个块的 <span class="math inline">\(r\)</span> 指针，<span class="math inline">\(l\)</span> 所在块为奇数就令 <span class="math inline">\(r\)</span> 升序，偶数则降序。</p>
<h2 id="树上莫队">树上莫队</h2>
<p><a href="https://www.luogu.com.cn/problem/SP10707">SP10707 COT2 - Count on a tree II</a></p>
<blockquote>
<p>给定 <span class="math inline">\(n\)</span> 个结点的树，每个结点有一种颜色，<span class="math inline">\(m\)</span> 次询问，每次询问 <span class="math inline">\(u,v\)</span> 之间的路径上的结点的不同颜色数。</p>
<p><span class="math inline">\(1\le n\le 4\times 10^4\)</span>，<span class="math inline">\(1\le m\le 10^5\)</span>。</p>
</blockquote>
<p>把树转化成欧拉序，就是序列问题了，设 <span class="math inline">\(st_u,ed_u\)</span> 表示欧拉序中 <span class="math inline">\(u\)</span> 的进栈、出栈顺序。</p>
<p><span class="math inline">\(st_u&lt;st_v\)</span> 时：</p>
<ul>
<li><span class="math inline">\(u\)</span> 为 <span class="math inline">\(v\)</span> 的祖先，查询 <span class="math inline">\([st_u,st_v]\)</span> 中所有出现 <span class="math inline">\(1\)</span> 次的点的答案；</li>
<li>否则，查询 <span class="math inline">\([ed_u,st_v]\)</span> 的所有出现 <span class="math inline">\(1\)</span> 次的点的答案，记得单独处理 <span class="math inline">\(\operatorname{LCA}\)</span>。</li>
</ul>
<p>通过重链剖分可以轻松得到 <span class="math inline">\(\operatorname{LCA}\)</span> 和欧拉序，然后就是普通莫队问题了。</p>
<h2 id="带修莫队">带修莫队</h2>
<p><a href="https://www.luogu.com.cn/problem/P1903">P1903 「国家集训队」数颜色 / 维护队列</a></p>
<p>相对于普通莫队多了修改操作。</p>
<p>同样是把左右操作离线，分开询问和修改，并都打上时间戳。</p>
<p>可以想到多设一个指针在 <span class="math inline">\(p\)</span> 在<strong>修改操作的序列</strong>上移动，对于莫队过程中相邻的两个询问的时间戳 <span class="math inline">\(t_x,t_y\)</span>，将 <span class="math inline">\(t_x,t_y\)</span> 之间在当前区间内的修改操作统计到答案里。</p>
<p>发现这样单次会被卡成 <span class="math inline">\(\mathcal O(n)\)</span>，怎么优化？</p>
<h3 id="调整排序方法">调整排序方法</h3>
<ul>
<li>第一关键字：<span class="math inline">\(l\)</span> 所在块；</li>
<li>第二关键字：<span class="math inline">\(r\)</span> 所在块；</li>
<li>第三关键字：时间戳。</li>
</ul>
<p>这样 <span class="math inline">\(l\)</span> 所在块相同并且 <span class="math inline">\(r\)</span> 所在块相同的若干个询问，会按照时间总小到大排序。</p>
<h3 id="调整块的大小">调整块的大小</h3>
<p>设修改操作序列长为 <span class="math inline">\(t\)</span>，将块的大小调整为 <span class="math inline">\(\sqrt[3]{nt}\)</span> 最优，此时总体复杂度 <span class="math inline">\(\mathcal O(\sqrt[3]{n^4t})\)</span>。</p>
<p>证明见 <a href="https://www.luogu.com.cn/blog/KYD/solution-p1903">Minclxc 的博客</a>。</p>
<p><del>懒得话</del>实测 <span class="math inline">\(n^{\frac{2}{3}}\)</span> 跑的更快，毕竟 <span class="math inline">\(n\)</span>，<span class="math inline">\(t\)</span> 同阶。</p>
<h2 id="回滚莫队">回滚莫队</h2>
<p><a href="https://www.luogu.com.cn/problem/AT1219">AT1219 歴史の研究</a></p>
<blockquote>
<p>给出长为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(a\)</span>，<span class="math inline">\(c(x)\)</span> 为 <span class="math inline">\([l,r]\)</span> 中 <span class="math inline">\(x\)</span> 出现的次数，每次询问区间内 <span class="math inline">\(\displaystyle \max_{i=l}^r \{a_i\times c(a_i)\}\)</span>。</p>
</blockquote>
<p>发现由于 <span class="math inline">\(\max\)</span> 的性质，莫队无法做到 <span class="math inline">\(\mathcal O(1)\)</span> 减去某个点的贡献。</p>
<p><strong>只能加点不能删点</strong>，这时候回滚莫队就出现了。</p>
<p>还是先套路地分块，像普通莫队一样排序（不加奇偶性优化）。</p>
<p>同一个块里的询问右端点单调递增，满足只加不减。</p>
<p>发现左端点在块里反复横跳，干脆每次都从块的右端向左扩展，这样总复杂度仍然控制在 <span class="math inline">\(\mathcal O(n\sqrt{n})\)</span>。</p>
<p>好了，现在有了完整的思路：</p>
<p>为了方便，将询问按左端点所在块分组，组内排序。</p>
<p>注意要将左右端点在同一块的询问单独处理。</p>
<p>对于每一个块内，设指针 <span class="math inline">\(l,r\)</span>，我们要<strong>保留块的右端点到上一次 <span class="math inline">\(r\)</span> 的答案为 <span class="math inline">\(last\)</span> </strong>；</p>
<p><span class="math inline">\(r\)</span> 从上一次的 <span class="math inline">\(r\)</span> 向右扩展，更新 <span class="math inline">\(last\)</span>；</p>
<p><span class="math inline">\(l\)</span> 从块的右端暴力向左扩展，更新答案后撤销掉贡献的所有 <span class="math inline">\(c(a_i)\)</span>。</p>
<h2 id="二次离线莫队">二次离线莫队</h2>
<p><a href="https://www.luogu.com.cn/problem/P4887">P4887 【模板】莫队二次离线（第十四分块(前体)）</a></p>
<blockquote>
<p>给了你一个序列 <span class="math inline">\(a\)</span>，每次查询给一个区间 <span class="math inline">\([l,r]\)</span> 查询 <span class="math inline">\(l \leq i&lt; j \leq r\)</span> 且 <span class="math inline">\(a_i \oplus a_j\)</span> 的二进制表示下有 <span class="math inline">\(k\)</span> 个 <span class="math inline">\(1\)</span> 的二元组 <span class="math inline">\((i,j)\)</span> 的个数。</p>
<p><span class="math inline">\(1 \leq n , m \leq 100000 , 0 \leq a_i , k &lt; 16384\)</span>。</p>
</blockquote>
<p>莫队需要考虑怎么从 <span class="math inline">\([l,r]\)</span> 的答案 <span class="math inline">\(\mathcal O(1)\)</span> 得到 <span class="math inline">\([l-1,r],[l+1,r],[l,r-1],[l,r+1]\)</span> 的答案。</p>
<p>设 <span class="math inline">\(f(x,[l,r])\)</span> 表示 <span class="math inline">\(x\)</span> 对区间 <span class="math inline">\([l,r]\)</span> 的贡献，每次增减的答案就是这个东西，但是很难计算。</p>
<p>考虑<strong>差分</strong>，以从 <span class="math inline">\([l,r]\)</span> 扩展到 <span class="math inline">\([l,r+1]\)</span> 为例： <span class="math display">\[
f(r+1,[l,r]) = f(r+1,[1,r])-f(r+1,[1,l-1])
\]</span> 发现 <span class="math inline">\(f(r+1,[1,r])\)</span> 可以预处理出来，重点是后面的这项，莫队的过程中在线的求很难。</p>
<p>所以就把对 <span class="math inline">\(f(r+1,[1,l-1])\)</span> 的询问<strong>再次离线</strong>下来（这也就是叫做“二次离线”的原因），把 <span class="math inline">\(r+1\)</span> 挂在 <span class="math inline">\(l-1\)</span> 的 <code>vector</code> 上，莫队之后从前到后扫，就类似<strong>扫描线</strong>一样处理。</p>
<p>其它的三种情况类似。</p>
<p>具体的预处理方法，运用异或运算的性质：<span class="math inline">\(a \operatorname{xor} b=c \Leftrightarrow a \operatorname{xor} c=b\)</span>，所以处理 <span class="math inline">\(\binom{14}{k}\)</span> 个可能的结果，开个桶统计即可。</p>
<p>并且每次将 <span class="math inline">\([l,r]\)</span> 扩展到 <span class="math inline">\([l,r&#39;]\)</span> 时，中间需要挂在 <span class="math inline">\(l-1\)</span> 处的点是个区间，可以将空间复杂度由 <span class="math inline">\(\mathcal O(n\sqrt{n})\)</span> 降到 <span class="math inline">\(\mathcal O(n)\)</span>。</p>
<p>这题有个坑点：<span class="math inline">\(k=0\)</span> 时，在差分处理 <span class="math inline">\(f(x,[l,r]),x\le r\)</span> 时，<span class="math inline">\(x\)</span> 在桶中会多算一次，因为 <span class="math inline">\(x\operatorname{xor}x=0\)</span> 但不符合题目要求。</p>
<p><strong>总结</strong>一下，二次离线就是在莫队时，通过扫描线一类的方法，将需要更新的答案再次离线处理。</p>
<h2 id="一些题目">一些题目</h2>
<ul>
<li><p><a href="https://www.luogu.com.cn/problem/P4074">P4074 「WC2013」糖果公园</a></p>
<p>树上莫队 + 带修莫队。</p>
<p>不太好码。</p></li>
</ul>
]]></content>
      <categories>
        <category>总结</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 Pollard-Rho &amp; Miller-Rabin</title>
    <url>/2020/10/24/%E6%9D%BF%E5%AD%90-Pollard-Rho-Miller-Rabin/</url>
    <content><![CDATA[<p>对于大数字的玄学复杂度质因数分解方法 Pollard-Rho，以及快速的素数判定方法 Millar-Rabin。</p>
<a id="more"></a>
<p><a href="https://www.luogu.com.cn/problem/P4718">P4718 【模板】Pollard-Rho算法</a></p>
<h2 id="前置知识">前置知识</h2>
<h3 id="快速乘">快速乘</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">mul</span><span class="params">(LL a, LL b, LL p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a * b - (LL)((<span class="keyword">long</span> <span class="keyword">double</span>)a * b / p) * p + p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>快速幂</p>
<p><del>GCD</del></p>
<p>费马小定理</p>
<h2 id="miller-rabin">Miller-Rabin</h2>
<p>很好的讲解及代码：<a href="https://oi-wiki.org/math/prime/">OI Wiki</a>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Miller_Rabin</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> n == <span class="number">2</span>;</span><br><span class="line">    LL a = n - <span class="number">1</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!(a &amp; <span class="number">1</span>)) a &gt;&gt;= <span class="number">1</span>, b++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j; i &lt;= <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        LL u = rand() % (n - <span class="number">2</span>) + <span class="number">2</span>, v = power(u, a, n);</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="number">1</span> || v == n - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= b; ++j) &#123;</span><br><span class="line">            v = mul(v, v, n);</span><br><span class="line">            <span class="keyword">if</span> (v == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == b + <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pollard-rho">Pollard-Rho</h2>
<p>很好的讲解及代码：<a href="https://oi-wiki.org/math/pollard-rho/">OI Wiki</a>，<a href="https://www.luogu.com.cn/blog/_post/118765">LinearODE's blog</a>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Pollard_Rho</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">    LL s = <span class="number">0</span>, t = <span class="number">0</span>, val = <span class="number">1</span>, c = rand() % (n - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> goal = <span class="number">1</span>; ; goal &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        s = t, val = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> step = <span class="number">1</span>; step &lt;= goal; ++step) &#123;</span><br><span class="line">            t = next_rand(t, c, n);</span><br><span class="line">            val = mul(val, t - s, n);</span><br><span class="line">            <span class="keyword">if</span> (step % <span class="number">127</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                LL d = gcd(val, n);</span><br><span class="line">                <span class="keyword">if</span> (d &gt; <span class="number">1</span>) <span class="keyword">return</span> d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LL d = gcd(val, n);</span><br><span class="line">        <span class="keyword">if</span> (d &gt; <span class="number">1</span>) <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模板题代码">模板题代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> RenaMoe &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(TT &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">bool</span> f = <span class="literal">false</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> LD;</span><br><span class="line"></span><br><span class="line">LL T, n, maxans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">mul</span><span class="params">(LL a, LL b, LL p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a * b - (LL)((LD)a * b / p) * p + p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">power</span><span class="params">(LL a, LL b, LL p)</span> </span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = mul(res, a, p);</span><br><span class="line">        a = mul(a, a, p), b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">next_rand</span><span class="params">(LL x, LL c, LL p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (mul(x, x, p) + c) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Miller_Rabin</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> n == <span class="number">2</span>;</span><br><span class="line">    LL a = n - <span class="number">1</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!(a &amp; <span class="number">1</span>)) a &gt;&gt;= <span class="number">1</span>, b++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j; i &lt;= <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        LL u = rand() % (n - <span class="number">2</span>) + <span class="number">2</span>, v = power(u, a, n);</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="number">1</span> || v == n - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= b; ++j) &#123;</span><br><span class="line">            v = mul(v, v, n);</span><br><span class="line">            <span class="keyword">if</span> (v == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == b + <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Pollard_Rho</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">    LL s = <span class="number">0</span>, t = <span class="number">0</span>, val = <span class="number">1</span>, c = rand() % (n - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> goal = <span class="number">1</span>; ; goal &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        s = t, val = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> step = <span class="number">1</span>; step &lt;= goal; ++step) &#123;</span><br><span class="line">            t = next_rand(t, c, n);</span><br><span class="line">            val = mul(val, t - s, n);</span><br><span class="line">            <span class="keyword">if</span> (step % <span class="number">127</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                LL d = gcd(val, n);</span><br><span class="line">                <span class="keyword">if</span> (d &gt; <span class="number">1</span>) <span class="keyword">return</span> d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LL d = gcd(val, n);</span><br><span class="line">        <span class="keyword">if</span> (d &gt; <span class="number">1</span>) <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fac</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= maxans || n &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (Miller_Rabin(n)) &#123;</span><br><span class="line">        maxans = max(maxans, n);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL p = n;</span><br><span class="line">    <span class="keyword">while</span> (p &gt;= n) p = Pollard_Rho(n);</span><br><span class="line">    <span class="keyword">while</span> (!(n % p)) n /= p;</span><br><span class="line">    fac(n), fac(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    read(T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        read(n);</span><br><span class="line">        maxans = <span class="number">0</span>;</span><br><span class="line">        fac(n);</span><br><span class="line">        <span class="keyword">if</span> (maxans == n) <span class="built_in">puts</span>(<span class="string">&quot;Prime&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, maxans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RenaMoe::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
        <category>Math</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 可持久化线段树 / 主席树</title>
    <url>/2020/01/17/%E6%9D%BF%E5%AD%90-%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91-%E4%B8%BB%E5%B8%AD%E6%A0%91/</url>
    <content><![CDATA[<p>将线段树或者权值线段树可持久化。</p>
<a id="more"></a>
<h2 id="主席树">主席树</h2>
<p>不太严谨的描述，将权值线段树可持久化。可以做区间第 K 大一类问题。</p>
<p><a href="https://www.luogu.com.cn/problem/P3834">luogu P3834</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Seg_Tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> cnt, n;</span><br><span class="line">    <span class="keyword">int</span> rt[N], sum[N&lt;&lt;<span class="number">5</span>], ls[N&lt;&lt;<span class="number">5</span>], rs[N&lt;&lt;<span class="number">5</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> suc)</span> </span>&#123;</span><br><span class="line">        sum[suc] = sum[ls[suc]] + sum[rs[suc]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        sum[suc] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        build(ls[suc] = ++cnt, l, mid), build(rs[suc] = ++cnt, mid+<span class="number">1</span>, r);</span><br><span class="line">        push_up(suc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> pre, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ls[suc] = ls[pre], rs[suc] = rs[pre], sum[suc] = sum[pre] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid)</span><br><span class="line">            update(ls[suc] = ++cnt, ls[pre], l, mid, x);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            update(rs[suc] = ++cnt, rs[pre], mid+<span class="number">1</span>, r, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">int</span> t = sum[ls[v]] - sum[ls[u]], mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= t)</span><br><span class="line">            <span class="keyword">return</span> query(ls[u], ls[v], l, mid, k);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> query(rs[u], rs[v], mid+<span class="number">1</span>, r, k - t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; tr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        read(a[i]), b[i] = a[i];</span><br><span class="line">    sort(b+<span class="number">1</span>, b+n+<span class="number">1</span>);</span><br><span class="line">    tr.n = unique(b+<span class="number">1</span>, b+n+<span class="number">1</span>) - b - <span class="number">1</span>;</span><br><span class="line">    tr.build(tr.rt[<span class="number">0</span>] = ++tr.cnt, <span class="number">1</span>, tr.n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = lower_bound(b+<span class="number">1</span>, b+tr.n+<span class="number">1</span>, a[i]) - b;</span><br><span class="line">        tr.update(tr.rt[i] = ++tr.cnt, tr.rt[i<span class="number">-1</span>], <span class="number">1</span>, tr.n, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l, r, k;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        read(l), read(r), read(k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b[tr.query(tr.rt[l<span class="number">-1</span>], tr.rt[r], <span class="number">1</span>, tr.n, k)]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可持久化线段树">可持久化线段树</h2>
<p><a href="https://www.luogu.com.cn/problem/P3919">P3919 【模板】可持久化线段树 1（可持久化数组）</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NN = <span class="number">2e7</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PersistableSegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">int</span> val[NN], ls[NN], rs[NN], rt[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;suc, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!suc) suc = ++cnt;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            val[suc] = a[l];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        build(ls[suc], l, mid), build(rs[suc], mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;suc, <span class="keyword">int</span> pre, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        suc = ++cnt;</span><br><span class="line">        ls[suc] = ls[pre], rs[suc] = rs[pre];</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            val[suc] = k;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) update(ls[suc], ls[pre], l, mid, x, k);</span><br><span class="line">        <span class="keyword">else</span> update(rs[suc], rs[pre], mid + <span class="number">1</span>, r, x, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> val[suc];</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) <span class="keyword">return</span> query(ls[suc], l, mid, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query(rs[suc], mid + <span class="number">1</span>, r, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(a[i]);</span><br><span class="line">    T.build(T.rt[<span class="number">0</span>], <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">int</span> base, opt, x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        read(base), read(opt);</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">            read(x), read(y);</span><br><span class="line">            T.update(T.rt[i], T.rt[base], <span class="number">1</span>, n, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            read(x);</span><br><span class="line">            T.rt[i] = T.rt[base];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, T.query(T.rt[i], <span class="number">1</span>, n, x));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title>通过namespace防止命名冲突</title>
    <url>/2019/12/25/%E9%80%9A%E8%BF%87namespace%E9%98%B2%E6%AD%A2%E5%91%BD%E5%90%8D%E5%86%B2%E7%AA%81/</url>
    <content><![CDATA[<p>不止一位学长讲述过一些选手因为"next""pipe"而暴毙的英雄事迹。。。</p>
<p>那么Linux下如何防止命名冲突？</p>
<a id="more"></a>
<p><del>或者仅仅是因为懒得想变量名</del></p>
<p><strong><em>听过学长的指导后，本文全程口糊，有不恰当处还请指出</em></strong></p>
<p>C++中有了<strong>命名空间</strong>这个东西，不同命名空间的元素可以同名</p>
<p>你平时写的<code>using namespace std;</code>就是代替了每次调用时的<code>std::</code>，相当于把std作为此程序的命名空间</p>
<p>我们可以创建自己的命名空间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> NAME &#123;<span class="comment">// NAME可以是你自己取的名字</span></span><br><span class="line">    <span class="comment">// code...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面的程序正常写就行</p>
<p>不过C++的运行端口是::main，所以main函数写在namespace里会找不到端口，无法运行</p>
<p>只把main写在外面？<del>这辈子都不会的</del></p>
<p>为了程序的优美性，可以namespace里写一个main，外面调用即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> BANANA &#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;<span class="comment">// inline是一点优化，自己百度。因为没必要必须返回0，可以是void</span></span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BANANA::main();<span class="comment">// 和std同理，通过BANANA::调用就没有冲突</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话写一大堆函数和全局变量的时候，main函数依然优美</p>
<p><strong>总之自己看着舒服就行</strong></p>
<p>另外，namespace是可以<strong>嵌套</strong>的，并且优先级是<strong>本层namespace &gt; 外层namespace</strong></p>
<p>调用时本层找不到就会从上一层找</p>
<p>于是我们照样写<code>using namespace std</code>，不受影响，<del>太棒了不用写烦人的std</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">namespace</span> BANANA &#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">namespace</span> OI &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;兜售小main包烤绿鸟&quot;</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// cout照样用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 这里的a = 1</span></span><br><span class="line">        OI::sell();<span class="comment">// 调用其他namespace的元素同理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BANANA::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了你还怕什么？</p>
<p>不过学长实测，如果你起linux,unix的变量名，还是会翻车，<del>他们太硬了</del></p>
<p>不过你可以随心所欲地打万能头了。。。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">namespace</span> BANANA &#123;</span><br><span class="line">    <span class="keyword">int</span> x1, x2, y1, y2;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> pipe, next[<span class="number">105</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;小main包烤绿鸟还有人要么！！！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BANANA::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>祝大家敲代码愉快~</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>题解 P3233 [HNOI2014]世界树</title>
    <url>/2020/04/06/%E9%A2%98%E8%A7%A3%20P3233%20HNOI2014%E4%B8%96%E7%95%8C%E6%A0%91/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3233">题目</a></p>
<blockquote>
<p>给一棵树，每条边距离为1，q 次询问，每次选择 k 个关键点，树上每个点由距离最近的关键的管辖（距离相同选择编号最小的），求每个关键的管辖点数</p>
<p><span class="math inline">\(N,q\le3\times10^5,\sum_{i=1}^q{k_i}\le3\times10^5\)</span></p>
</blockquote>
<a id="more"></a>
<h2 id="思路">思路</h2>
<p><strong>树形dp</strong>，看数据范围，需要建<strong>虚树</strong>来优化</p>
<p>考虑每次把关键点建出虚树</p>
<p>dp求出每个点 u 的 <span class="math inline">\(belong_u\)</span>（管辖 u 的关键点），<span class="math inline">\(dis_u\)</span> （u 到 <span class="math inline">\(belong_u\)</span> 的距离）</p>
<p>类似最短路的松弛，注意第一遍dp统计儿子对父亲的贡献，第二遍统计父亲对儿子的贡献</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (dis[u] &gt; dis[v] + E[i].val || (dis[u] == dis[v] + E[i].val &amp;&amp; bl[u] &gt; bl[v]))</span><br><span class="line">    dis[u] = dis[v] + E[i].val, bl[u] = bl[v];</span><br></pre></td></tr></table></figure>
<p>第三遍dp统计答案，设 <span class="math inline">\(f_u\)</span> 表示原树中经过 u 增加 <span class="math inline">\(belong_u\)</span> 贡献的点数</p>
<p>在虚树上有两种情况：</p>
<ul>
<li>以 u 为根的原树的子树中没有关键点，那么这棵子树都由 u 或 <span class="math inline">\(belong_u\)</span> 管辖</li>
<li>虚树上连接 u 和 v 的边（u 为 v 的父亲），代表原树中的一条链，又分两种情况：
<ul>
<li><span class="math inline">\(belong_u=belong_v\)</span>，这一条链除了 v 点其它都是 u 的贡献（v 点及其子树为 v 的贡献）</li>
<li><span class="math inline">\(belong_u\not=belong_v\)</span>，这条链被分成两部分，通过倍增找出分界点，划分 u,v 贡献</li>
</ul></li>
</ul>
<p>把 u 贡献加到 <span class="math inline">\(belong_u\)</span> 的答案上即可</p>
<h3 id="细节">细节</h3>
<p>这题一堆全局变量数组（命名冲突好麻烦），比大数据结构难调</p>
<p>关于链上找分界点（属于 v 范围的最高点）：</p>
<p>先求出 <span class="math inline">\(belong_u\)</span> 和 <span class="math inline">\(belong_v\)</span> 的距离 d，<code>deep[v] - (d / 2 - dis[v])</code> 即中间点的 deep</p>
<p>如果 u，v 中间有奇数个点，必定有一个点 x 到两个关键点的距离相等，要让 d - 1，倍增后中间点为 x 的儿子（对 d 为偶数没有影响），看两个关键点编号大小选择是否往上走</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> d = deep[v] - deep[u] + dis[u] + dis[v] - <span class="number">1</span>, tmp = d / <span class="number">2</span> - dis[v], mid = v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">19</span>; ~j; --j)</span><br><span class="line">    <span class="keyword">if</span> (deep[fa[mid][j]] &gt;= deep[v] - tmp)</span><br><span class="line">        mid = fa[mid][j];</span><br><span class="line"><span class="keyword">if</span> ((d &amp; <span class="number">1</span>) &amp;&amp; tmp &gt;= <span class="number">0</span> &amp;&amp; bl[u] &gt; bl[v]) mid = fa[mid][<span class="number">0</span>];<span class="comment">// tmp 可能为负</span></span><br></pre></td></tr></table></figure>
<p>另外<strong>多测要清空</strong></p>
<h2 id="code">code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TT&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(TT x, <span class="keyword">char</span> end = <span class="string">&#x27;\n&#x27;</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> nxt, to, val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, cnt_e, Q, k, dfu, tot, top;</span><br><span class="line"><span class="keyword">int</span> head[N], Head[N], pu[N], po[N];</span><br><span class="line"><span class="keyword">int</span> deep[N], fa[N][<span class="number">20</span>], size[N], a[N], t[N&lt;&lt;<span class="number">1</span>], stk[N];</span><br><span class="line"><span class="keyword">int</span> dis[N], bl[N], f[N], ans[N];</span><br><span class="line">Edge e[N&lt;&lt;<span class="number">1</span>], E[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> is[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[++cnt_e] = (Edge)&#123;head[u], v, w&#125;, head[u] = cnt_e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    E[++cnt_e] = (Edge)&#123;Head[u], v, w&#125;, Head[u] = cnt_e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">    pu[u] = ++dfu;</span><br><span class="line">    deep[u] = deep[last] + <span class="number">1</span>;</span><br><span class="line">    fa[u][<span class="number">0</span>] = last;</span><br><span class="line">    size[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; <span class="number">1</span> &lt;&lt; i &lt;= deep[u]; ++i)</span><br><span class="line">        fa[u][i] = fa[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span> ((v = e[i].to) != last)</span><br><span class="line">            dfs(v, u), size[u] += size[v];</span><br><span class="line">    po[u] = ++dfu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deep[x] &lt; deep[y]) swap(x, y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> (deep[fa[x][i]] &gt;= deep[y])</span><br><span class="line">            x = fa[x][i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> (fa[x][i] != fa[y][i])</span><br><span class="line">            x = fa[x][i], y = fa[y][i];</span><br><span class="line">    <span class="keyword">return</span> x == y ? x : fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; <span class="number">0</span> ? pu[x] : po[-x]) &lt; (y &gt; <span class="number">0</span> ? pu[y] : po[-y]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build_tree</span><span class="params">(<span class="keyword">int</span> kk)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> vis[N];</span><br><span class="line">    tot = top = cnt_e = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= kk; ++i)</span><br><span class="line">        t[++tot] = a[i], vis[t[tot]] = <span class="literal">true</span>;</span><br><span class="line">    sort(t+<span class="number">1</span>, t+tot+<span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, lca; i &lt; kk; ++i) &#123;</span><br><span class="line">        lca = LCA(t[i], t[i+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (!vis[lca]) t[++tot] = lca, vis[lca] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!vis[<span class="number">1</span>]) t[++tot] = <span class="number">1</span>;</span><br><span class="line">    kk = tot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= kk; ++i)</span><br><span class="line">        t[++tot] = -t[i];</span><br><span class="line">    sort(t+<span class="number">1</span>, t+tot+<span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= tot; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t[i] &gt; <span class="number">0</span>) stk[++top] = t[i];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            v = stk[top--], u = stk[top];</span><br><span class="line">            Add_edge(u, v, deep[v] - deep[u]), Add_edge(v, u, deep[v] - deep[u]);</span><br><span class="line">            vis[v] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is[u]) dis[u] = <span class="number">0</span>, bl[u] = u;</span><br><span class="line">    <span class="keyword">else</span> dis[u] = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Head[u], v; i; i = E[i].nxt)</span><br><span class="line">        <span class="keyword">if</span> ((v = E[i].to) != last) &#123;</span><br><span class="line">            dp1(v, u);</span><br><span class="line">            <span class="keyword">if</span> (dis[u] &gt; dis[v] + E[i].val || (dis[u] == dis[v] + E[i].val &amp;&amp; bl[u] &gt; bl[v]))</span><br><span class="line">                dis[u] = dis[v] + E[i].val, bl[u] = bl[v];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我把第二三遍dp合在一块了</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">    f[u] = size[u];<span class="comment">// 初值为子树size</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Head[u], v; i; i = E[i].nxt)</span><br><span class="line">        <span class="keyword">if</span> ((v = E[i].to) != last) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[v] &gt; dis[u] + E[i].val || (dis[v] == dis[u] + E[i].val &amp;&amp; bl[v] &gt; bl[u]))</span><br><span class="line">                dis[v] = dis[u] + E[i].val, bl[v] = bl[u];</span><br><span class="line">            dp2(v, u);</span><br><span class="line">            <span class="keyword">if</span> (bl[u] == bl[v])</span><br><span class="line">                f[u] -= size[v];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> d = deep[v] - deep[u] + dis[u] + dis[v] - <span class="number">1</span>, tmp = d / <span class="number">2</span> - dis[v], mid = v;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">19</span>; ~j; --j)</span><br><span class="line">                    <span class="keyword">if</span> (deep[fa[mid][j]] &gt;= deep[v] - tmp)</span><br><span class="line">                        mid = fa[mid][j];</span><br><span class="line">                <span class="keyword">if</span> ((d &amp; <span class="number">1</span>) &amp;&amp; tmp &gt;= <span class="number">0</span> &amp;&amp; bl[u] &gt; bl[v]) mid = fa[mid][<span class="number">0</span>];<span class="comment">// tmp可能为负数</span></span><br><span class="line">                f[u] -= size[mid];</span><br><span class="line">                f[v] += size[mid] - size[v];</span><br><span class="line">            &#125;</span><br><span class="line">            ans[bl[v]] += f[v];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (u == <span class="number">1</span>) ans[bl[<span class="number">1</span>]] += f[<span class="number">1</span>];<span class="comment">// 别落下根节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++i)	</span><br><span class="line">        read(u), read(v), add_edge(u, v, <span class="number">0</span>), add_edge(v, u, <span class="number">0</span>);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    read(Q);</span><br><span class="line">    <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">        read(k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">            read(a[i]), is[a[i]] = <span class="literal">true</span>;</span><br><span class="line">        build_tree(k);</span><br><span class="line">        dp1(<span class="number">1</span>, <span class="number">0</span>), dp2(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">            print(ans[a[i]], <span class="string">&#x27; &#x27;</span>), is[a[i]] = ans[a[i]] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// 清空，用memset会TLE</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i)</span><br><span class="line">            <span class="keyword">if</span> (t[i] &gt; <span class="number">0</span>)</span><br><span class="line">                Head[t[i]] = dis[t[i]] = bl[t[i]] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>倍增</tag>
        <tag>树形DP</tag>
        <tag>虚树</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF571D Campus</title>
    <url>/2020/11/26/%E9%A2%98%E8%A7%A3-CF571D-Campus/</url>
    <content><![CDATA[<p>转化成树上问题 + 树状数组上二分技巧。</p>
<a id="more"></a>
<h2 id="题意">题意</h2>
<p><a href="https://www.luogu.com.cn/problem/CF571D">题目</a></p>
<blockquote>
<p>维护两类集合 <span class="math inline">\(A,B\)</span>，初始 <span class="math inline">\(A_x=B_x=x\)</span>，序列全为 0，有五个操作：</p>
<ul>
<li>将 <span class="math inline">\(A_y\)</span> 合并到 <span class="math inline">\(A_x\)</span>；</li>
<li>将 <span class="math inline">\(B_y\)</span> 合并到 <span class="math inline">\(B_x\)</span>；</li>
<li>将集合 <span class="math inline">\(A_x\)</span> 中元素所在序列的值加上 <span class="math inline">\(|A_x|\)</span>；</li>
<li>将集合 <span class="math inline">\(B_x\)</span> 中元素所在序列的值都设为 <span class="math inline">\(0\)</span>；</li>
<li>求序列下标 <span class="math inline">\(x\)</span> 的值。</li>
</ul>
<p><span class="math inline">\(n,m\le 10^5\)</span>。</p>
</blockquote>
<h2 id="思路">思路</h2>
<p>每次把两个集合合并时新建一个虚点作为两者的父亲，操作 <span class="math inline">\(3\)</span> 就是二叉树上的子树加。</p>
<p>查询单点时就在树上 dfs，用树状数组在时间上维护权值和。</p>
<p>问题在于操作 <span class="math inline">\(2,4\)</span>，我们需要知道单点询问时，该点最晚的清零操作的时间。</p>
<p>我们用同样的合并方法在第二棵树上处理操作 <span class="math inline">\(2,4\)</span>，在这棵树上 dfs，用树状数组在时间上维护清零操作。</p>
<p>如果该点有询问操作，那就在树状数组里二分最晚的清零操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回s[i]小于s[x]的最大的i</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">bound</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    LL s = query(x);</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> &lt;&lt; <span class="number">19</span>; i; i &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x + i &lt; N &amp;&amp; sum[x + i] &lt; s) &#123;</span><br><span class="line">            x += i;</span><br><span class="line">            s -= sum[x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>这样就可以避免像辣鸡的 RenaMoe 一样在外面套一次二分了，又多个 <span class="math inline">\(\log\)</span>。</del></p>
<p>梳理一下，就是先建出两棵树，第二棵树上处理出每个询问点最晚的清零操作，然后在第一棵树上对每个询问点区间查和，复杂度 <span class="math inline">\(\mathcal O(n\log n)\)</span>。</p>
<h2 id="代码">代码</h2>
<p>这里的第一棵树和第二棵树是反着的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ask</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> opt;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BitTree</span> &#123;</span></span><br><span class="line">    LL sum[N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, LL k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt; N; i += i &amp; -i) sum[i] += k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        LL res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i -= i &amp; -i) res += sum[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">bound</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        LL s = query(x);</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> &lt;&lt; <span class="number">19</span>; i; i &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x + i &lt; N &amp;&amp; sum[x + i] &lt; s) &#123;</span><br><span class="line">                x += i;</span><br><span class="line">                s -= sum[x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; T;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    <span class="keyword">int</span> ls[N], rs[N], fa[N], size[N], id[N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        tot = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; ++i) size[i] = <span class="number">1</span>, id[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        ++tot;</span><br><span class="line">        fa[id[x]] = fa[id[y]] = tot;</span><br><span class="line">        ls[tot] = id[x], rs[tot] = id[y];</span><br><span class="line">        size[tot] = size[id[x]] + size[id[y]];</span><br><span class="line">        id[x] = tot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; G1, G2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">LL ans[N];</span><br><span class="line">Ask q[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; add[N], clr[N], qry[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clr[u].size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = clr[u][i];</span><br><span class="line">        T.update(j, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qry[u].size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = qry[u][i];</span><br><span class="line">            q[j].y = T.bound(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> dfs1(G1.ls[u]), dfs1(G1.rs[u]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clr[u].size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = clr[u][i];</span><br><span class="line">        T.update(j, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; add[u].size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = add[u][i];</span><br><span class="line">        T.update(j, G2.size[u]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qry[u].size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = qry[u][i];</span><br><span class="line">            ans[j] = T.query(j) - T.query(q[j].y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> dfs2(G2.ls[u]), dfs2(G2.rs[u]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; add[u].size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = add[u][i];</span><br><span class="line">        T.update(j, -G2.size[u]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">        q[i].opt = str[<span class="number">0</span>];</span><br><span class="line">        read(q[i].x);</span><br><span class="line">        <span class="keyword">if</span> (q[i].opt == <span class="string">&#x27;U&#x27;</span> || q[i].opt == <span class="string">&#x27;M&#x27;</span>) read(q[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    G1.init(n), G2.init(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[i].opt == <span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">            G1.link(q[i].x, q[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q[i].opt == <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = G1.id[q[i].x];</span><br><span class="line">            clr[x].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q[i].opt == <span class="string">&#x27;U&#x27;</span>) &#123;</span><br><span class="line">            G2.link(q[i].x, q[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q[i].opt == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = G2.id[q[i].x];</span><br><span class="line">            add[x].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q[i].opt == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            qry[q[i].x].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= G1.tot; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!G1.fa[i]) dfs1(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= G2.tot; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!G2.fa[i]) dfs2(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[i].opt == <span class="string">&#x27;Q&#x27;</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 GYM102331B Bitwise Xor</title>
    <url>/2020/11/27/%E9%A2%98%E8%A7%A3-GYM102331B-Bitwise-Xor/</url>
    <content><![CDATA[<p>jiangly contest T3。</p>
<p>用 01-trie 优化 DP。</p>
<a id="more"></a>
<h2 id="题意">题意</h2>
<p><a href="https://codeforces.com/gym/102331/problem/B">题目</a></p>
<blockquote>
<p>给出长为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(x\)</span>，若一个 <span class="math inline">\(a\)</span> 的长为 <span class="math inline">\(k\)</span> 的子序列 <span class="math inline">\(b\)</span> 满足对于 <span class="math inline">\(b_i \operatorname{xor} b_j \ge x(1\le i &lt; j\le k)\)</span>，则是合法的序列，求 <span class="math inline">\(a\)</span> 的合法序列方案数。</p>
<p><span class="math inline">\(1\le n\le 3\times 10^5,0\le a_i\le 2^{60}-1\)</span>。</p>
</blockquote>
<h2 id="思路">思路</h2>
<p><span class="math inline">\(b\)</span> 的条件要求 <span class="math inline">\(b_i \operatorname{xor} b_j\)</span> 的最小值大于等于 <span class="math inline">\(x\)</span>，条件很严苛。</p>
<p>但是将 <span class="math inline">\(b\)</span> 排序后，这个最小值只能出现在相邻两项的异或值。</p>
<figure>
<img src="https://s3.ax1x.com/2020/11/27/DrNPN4.png" alt="证明 by jiangly" /><figcaption aria-hidden="true">证明 by jiangly</figcaption>
</figure>
<p>于是我们只要保证相邻两项异或值大于等于 <span class="math inline">\(x\)</span>。（考场上看错题的）</p>
<p>可以轻松的到 <span class="math inline">\(\mathcal O(n^2)\)</span> 的 DP 转移方程： <span class="math display">\[
f_i\leftarrow 1+\sum_{1\le j&lt; i}[a_i \operatorname{xor} a_j\ge x]f_j
\]</span> 考虑从异或入手，可以想到 01-trie。</p>
<p>在 01-trie 上节点存子树权值和，每次查询符合条件的 <span class="math inline">\(\sum f_j\)</span> 并插入 <span class="math inline">\(a_i\)</span> 权值为 <span class="math inline">\(f_i\)</span>。</p>
<p>如何查询？</p>
<p>我们令 <span class="math inline">\(a_i \operatorname{xor} a_j=x\)</span>，在 trie 上 <span class="math inline">\(a_j\)</span> 的这条路径上，对于从高到低每一位，设这一位 <span class="math inline">\(a_j\)</span> 为 <span class="math inline">\(a\)</span>，<span class="math inline">\(a_j\)</span> 为 <span class="math inline">\(b\)</span>，<span class="math inline">\(x\)</span> 为 <span class="math inline">\(c\)</span>。</p>
<p>如果 <span class="math inline">\(c\)</span> 为 <span class="math inline">\(0\)</span>，那么这一位可以为 <span class="math inline">\(1\)</span>，加上 <span class="math inline">\(a \operatorname{xor} 1\)</span> 的子树。</p>
<p>复杂度 <span class="math inline">\(\mathcal O(n\log a)\)</span>。</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n, tot;</span><br><span class="line">LL k, ans;</span><br><span class="line">LL a[N], sum[N*<span class="number">60</span>], ch[N*<span class="number">60</span>][<span class="number">2</span>], f[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(LL x, LL val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">61</span>; ~i; --i) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!ch[p][c]) ch[p][c] = ++tot;</span><br><span class="line">        p = ch[p][c];</span><br><span class="line">        (sum[p] += val) %= P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">query</span><span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">61</span>; ~i; --i) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = (x &gt;&gt; i) &amp; <span class="number">1</span>, d = (k &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!d) (res += sum[ch[p][c ^ <span class="number">1</span>]]) %= P;</span><br><span class="line">        p = ch[p][c ^ d];</span><br><span class="line">        <span class="keyword">if</span> (!p) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    (res += sum[p]) %= P;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(a[i]);</span><br><span class="line">    sort(a+<span class="number">1</span>, a+n+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    tot = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        f[i] = (query(a[i]) + <span class="number">1</span>) % P;</span><br><span class="line">        insert(a[i], f[i]);</span><br><span class="line">        (ans += f[i]) %= P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>01-trie</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P1322 logo语言</title>
    <url>/2019/12/24/%E9%A2%98%E8%A7%A3-P1322-logo%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p><strong>这里是栈的做法</strong></p>
<p>递归快写吐了，决心用栈，结果调了半天。。。</p>
<a id="more"></a>
<p>应该都能想到，FD就加，BF就减，REPEAT就压栈，']'就弹栈</p>
<p>手写栈比较舒服，<del>用STL的stack有点丑</del></p>
<p><strong>细节太重要了</strong></p>
<p>敲的时候应该注意：读入是否从有效字符开始（用char[]的注意）、']'的读入、用过的那层栈要清空。。。</p>
<p><del>都是废话，自己写写就知道了</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BANANA &#123;<span class="comment">//防止命名冲突</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;<span class="comment">// 快读</span></span><br><span class="line">    <span class="keyword">int</span> re = <span class="number">0</span>, k = <span class="number">1</span>; <span class="keyword">char</span> in = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(in)) &#123; <span class="keyword">if</span> (in == <span class="string">&#x27;-&#x27;</span>) k = <span class="number">-1</span>; in = getchar(); &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(in)) re = re * <span class="number">10</span> + in - <span class="string">&#x27;0&#x27;</span>, in = getchar();</span><br><span class="line">    <span class="keyword">return</span> re * k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[<span class="number">305</span>], k[<span class="number">305</span>];<span class="comment">// stack：栈，k：这一层栈repeat的次数</span></span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">num</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;<span class="comment">// 把s串开头的数字提出来</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; <span class="built_in">isdigit</span>(s[i]); i++)</span><br><span class="line">        ans = ans * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s) &#123;<span class="comment">// ctrl+z结束</span></span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">            <span class="built_in">stack</span>[top] += num(s);</span><br><span class="line">            <span class="keyword">int</span> len = s.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (s[len] == <span class="string">&#x27;]&#x27;</span>)<span class="comment">// 结尾有&#x27;]&#x27;要退栈</span></span><br><span class="line">                <span class="built_in">stack</span>[top<span class="number">-1</span>] += k[top<span class="number">-1</span>] * <span class="built_in">stack</span>[top], top--, len--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">            <span class="built_in">stack</span>[top] -= num(s);</span><br><span class="line">            <span class="keyword">int</span> len = s.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (s[len] == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">                <span class="built_in">stack</span>[top<span class="number">-1</span>] += k[top<span class="number">-1</span>] * <span class="built_in">stack</span>[top], top--, len--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">            k[top] = read();</span><br><span class="line">            top++;</span><br><span class="line">            <span class="built_in">stack</span>[top] = <span class="number">0</span>;<span class="comment">// 用之前清空（之前因为这个WA了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 特判&quot;[]&quot;里什么都没有的</span></span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">// 前面已经读入了&#x27;[&#x27;，所以从0开始</span></span><br><span class="line">            <span class="keyword">while</span> (s[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; i &lt; s.size())</span><br><span class="line">                <span class="built_in">stack</span>[top<span class="number">-1</span>] += k[top<span class="number">-1</span>] * <span class="built_in">stack</span>[top], top--, i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">abs</span>(<span class="built_in">stack</span>[<span class="number">1</span>]));<span class="comment">// 注意是距离（绝对值）</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BANANA::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2054 [AHOI2005]洗牌</title>
    <url>/2019/12/25/%E9%A2%98%E8%A7%A3-P2054-AHOI2005%E6%B4%97%E7%89%8C/</url>
    <content><![CDATA[<p>洗牌???</p>
<p><del>吐槽一下题目的图片，差点误导了我</del></p>
<p>这么麻烦的题面当然先模拟啦。。。</p>
<a id="more"></a>
<p>打表发现每次洗牌后第 <span class="math inline">\(i\)</span> 张牌会转移到第 <span class="math inline">\(2*i \%(n+1)\)</span> 的位置上</p>
<p>即在<span class="math inline">\(\mod{n+1}\)</span>意义下，<span class="math inline">\(i\)</span> 和 <span class="math inline">\(2i\)</span> 是同余的</p>
<p>so，可以列出一个同余方程：</p>
<p><span class="math inline">\(i * 2^{m} \equiv l\pmod {n+1}\)</span></p>
<p>再转化为</p>
<p><span class="math display">\[2 ^ {m} * i + (n+1) * k = l\]</span></p>
<p><span class="math display">\[2^{m} * \frac{i}{l} + (n+1) * \frac{k}{l} = 1\]</span></p>
<p>此时利用<span class="math inline">\(exgcd\)</span>完美地算出<span class="math inline">\(\frac{i}{l}\)</span>，乘上<span class="math inline">\(l\)</span>即可</p>
<p><strong>注意：</strong>范围1e10，如果直接乘会gg，要用快速乘，和快速幂差不多</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;<span class="comment">// 快读</span></span><br><span class="line">    x = <span class="number">0</span>; T k = <span class="number">1</span>; <span class="keyword">char</span> in = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(in)) &#123; <span class="keyword">if</span> (in == <span class="string">&#x27;-&#x27;</span>) k = <span class="number">-1</span>; in = getchar(); &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(in)) x = x * <span class="number">10</span> + in - <span class="string">&#x27;0&#x27;</span>, in = getchar();</span><br><span class="line">    x *= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;<span class="comment">// 开long long</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速乘</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">mul</span><span class="params">(ll a, ll b, ll p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将乘法变为加法，二进制优化，边加边模</span></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            ans = (ans + a) % p;</span><br><span class="line">        a = (a + a) % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速幂，其实只要写针对2的整次幂就行，这里犯懒。。。</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">q_pow</span><span class="params">(ll a, ll b, ll p)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            ans = mul(ans, a, p) % p;</span><br><span class="line">        a = mul(a, a, p) % p, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标配扩欧</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y, ll &amp;g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>, g = a;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        exgcd(b, a%b, y, x, g);</span><br><span class="line">        y -= a / b * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n, m, l, x, y, g, t;</span><br><span class="line">    read(n), read(m), read(l);</span><br><span class="line">    t = q_pow(<span class="number">2</span>, m, n+<span class="number">1</span>);<span class="comment">// 2的m次幂</span></span><br><span class="line">    exgcd(t, n+<span class="number">1</span>, x, y, g);</span><br><span class="line">    x = (x % (n+<span class="number">1</span>) + n+<span class="number">1</span>) % (n+<span class="number">1</span>);<span class="comment">// 注意exgcd后解可能为负</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, mul(x, l, n+<span class="number">1</span>));<span class="comment">// 乘上l</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Math</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2704 [NOI2001]炮兵阵地</title>
    <url>/2019/12/25/%E9%A2%98%E8%A7%A3-P2704-NOI2001%E7%82%AE%E5%85%B5%E9%98%B5%E5%9C%B0/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P2704">题目</a></p>
<p><del>珍爱头发，远离状压</del></p>
<p>首先如果没做过状压的话，出门<a href="https://www.luogu.org/problem/P1879">右转</a></p>
<a id="more"></a>
<h2 id="思路">思路</h2>
<p>这道题。。。数据范围很状压</p>
<p><del>显然</del>，把每一行的地图（有山为1，否则为0）压到一个数里</p>
<p>把枚举的状态压成有炮为1，否则为0</p>
<p><strong>把有解的情况存下来</strong>，便于枚举，并预处理每种情况的炮兵个数</p>
<p>现在<strong>用<span class="math inline">\(f_{i,j,k}\)</span>表示第<span class="math inline">\(i\)</span>行是状态<span class="math inline">\(j\)</span>，是由状态<span class="math inline">\(k\)</span>转移来的，最大的炮兵个数</strong></p>
<p>单独处理第一行和第二行</p>
<p>后面<span class="math inline">\(dp\)</span>的时候注意:</p>
<p>如何使一列中的每三行只有一个炮兵？</p>
<p>保证<span class="math inline">\(k1\)</span> &amp; <span class="math inline">\(k2\)</span>, <span class="math inline">\(k2\)</span> &amp; <span class="math inline">\(k3\)</span>, <span class="math inline">\(k1\)</span> &amp; <span class="math inline">\(k3\)</span>都为0即可（显然）</p>
<p>另外，空间有点。。。建议<strong>滚动数组</strong></p>
<hr />
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; T k = <span class="number">1</span>; <span class="keyword">char</span> in = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(in)) &#123; <span class="keyword">if</span> (in == <span class="string">&#x27;-&#x27;</span>) k = <span class="number">-1</span>; in = getchar(); &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(in)) x = x * <span class="number">10</span> + in - <span class="string">&#x27;0&#x27;</span>, in = getchar();</span><br><span class="line">    x *= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1</span>&lt;&lt;<span class="number">11</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">105</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, maxn, ans;</span><br><span class="line"><span class="keyword">int</span> mp[N], f[<span class="number">3</span>][M][M];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; d, v;<span class="comment">// 可行状态的对应的炮兵个数</span></span><br><span class="line"><span class="keyword">char</span> in[<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算每种情况的炮兵个数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> re = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">30</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (x &amp; (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">            re++;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(m);</span><br><span class="line">    maxn = (<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, in);</span><br><span class="line">        <span class="comment">//处理地图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">            <span class="keyword">if</span> (in[j] == <span class="string">&#x27;H&#x27;</span>)</span><br><span class="line">                mp[i] |= <span class="number">1</span> &lt;&lt; j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 预处理可行状态</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxn; ++i)</span><br><span class="line">        <span class="keyword">if</span> ((i &amp; (i &gt;&gt; <span class="number">1</span>)) == <span class="number">0</span> &amp;&amp; (i &amp; (i &gt;&gt; <span class="number">2</span>)) == <span class="number">0</span>)</span><br><span class="line">            d.push_back(i), v.push_back(count(i));</span><br><span class="line">    <span class="comment">// 单独处理一二行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.size(); ++i)</span><br><span class="line">        <span class="keyword">if</span> ((d[i] &amp; mp[<span class="number">0</span>]) == <span class="number">0</span>)<span class="comment">// 一贯的保证可行</span></span><br><span class="line">            f[<span class="number">0</span>][d[i]][<span class="number">0</span>] = v[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.size(); ++i)</span><br><span class="line">        <span class="keyword">if</span> ((d[i] &amp; mp[<span class="number">1</span>]) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; d.size(); ++j)</span><br><span class="line">                <span class="keyword">if</span> ((d[j] &amp; d[i]) == <span class="number">0</span>)</span><br><span class="line">                    f[<span class="number">1</span>][d[i]][d[j]] = max(f[<span class="number">1</span>][d[i]][d[j]], f[<span class="number">0</span>][d[j]][<span class="number">0</span>] + v[i]);</span><br><span class="line">    <span class="comment">// 愉快的dp</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i)<span class="comment">// 行数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; d.size(); ++j)<span class="comment">// 该行</span></span><br><span class="line">            <span class="keyword">if</span> ((d[j] &amp; mp[i]) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; d.size(); ++k)<span class="comment">// 上一行</span></span><br><span class="line">                    <span class="keyword">if</span> ((d[k] &amp; d[j]) == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; d.size(); ++l)<span class="comment">// 上二行</span></span><br><span class="line">                            <span class="keyword">if</span> ((d[l] &amp; d[k]) == <span class="number">0</span> &amp;&amp; (d[l] &amp; d[j]) == <span class="number">0</span>)</span><br><span class="line">                                f[i%<span class="number">3</span>][d[j]][d[k]] = max(f[i%<span class="number">3</span>][d[j]][d[k]], f[(i<span class="number">-1</span>)%<span class="number">3</span>][d[k]][d[l]] + v[j]);<span class="comment">// 重点</span></span><br><span class="line">    <span class="comment">// 统计最后一行的最大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.size(); ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; d.size(); ++j)</span><br><span class="line">            ans = max(ans, f[(n<span class="number">-1</span>)%<span class="number">3</span>][d[i]][d[j]]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P3538 [POI2012]OKR-A Horrible Poem</title>
    <url>/2019/12/25/%E9%A2%98%E8%A7%A3-P3538-POI2012-OKR-A-Horrible-Poem/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P3538">题面</a></p>
<a id="more"></a>
<h2 id="思路">思路</h2>
<p>判断字符串循环节最方便的是<span class="math inline">\(hash\)</span></p>
<p>不会的请<a href="https://www.luogu.org/problem/P3370">出门左转P3370</a></p>
<p>我们先把字符串<span class="math inline">\(hash\)</span>一遍</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/olzrdhcj.png" /></p>
<p>如图，如果设循环节长度为<span class="math inline">\(3\)</span>时，<span class="math inline">\(s1\)</span>和<span class="math inline">\(s2\)</span>的<span class="math inline">\(hash\)</span>值是相等的</p>
<p>所以只需要找最小的<span class="math inline">\(len\)</span>使得<span class="math inline">\(hash(l+len,r)=hash(l,r-len)\)</span></p>
<hr />
<p>另外，<strong>循环节的长度的循环次数都一定是总长的约数</strong></p>
<p>我的做法是把<strong>总长除掉循环次数</strong></p>
<p>先把<span class="math inline">\(len\)</span>分解质因数</p>
<p>（线性筛质数，并记录下每个数的最小质因子加速分解，<del>这已经是常规操作了</del>）</p>
<p>因为最小循环节的倍数也是循环节</p>
<p>所以从<span class="math inline">\(len\)</span>开始试除每个质因子并判断（你可以理解为<span class="math inline">\(len\)</span>的因子分为循环节的因子和循环次数的因子，要把循环次数的因子除掉）</p>
<p>具体的看代码吧。。。</p>
<hr />
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; T k = <span class="number">1</span>; <span class="keyword">char</span> in = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(in)) &#123; <span class="keyword">if</span> (in == <span class="string">&#x27;-&#x27;</span>) k = <span class="number">-1</span>; in = getchar(); &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(in)) x = x * <span class="number">10</span> + in - <span class="string">&#x27;0&#x27;</span>, in = getchar();</span><br><span class="line">    x *= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ll g[N], hash[N], <span class="built_in">pow</span>[N];<span class="comment">// g记录最小质因子，pow存进制的整数次幂</span></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; pri;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线性筛</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">euler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            pri.push_back(i), g[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pri.size() &amp;&amp; pri[j] * i &lt;= n; ++j) &#123;</span><br><span class="line">            vis[pri[j]*i] = <span class="literal">true</span>, g[pri[j]*i] = pri[j];</span><br><span class="line">            <span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取hash值</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((hash[r] - hash[l<span class="number">-1</span>] * <span class="built_in">pow</span>[r-l+<span class="number">1</span>]) % MOD + MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    euler();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// hash</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        hash[i] = (hash[i<span class="number">-1</span>] * <span class="number">29</span> + s[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>) % MOD;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 预处理整数次幂</span></span><br><span class="line">    <span class="built_in">pow</span>[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">pow</span>[i] = (<span class="built_in">pow</span>[i<span class="number">-1</span>] * <span class="number">29</span>) % MOD;</span><br><span class="line"></span><br><span class="line">    read(m);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r, len, ans;</span><br><span class="line">        read(l), read(r), ans = len = r - l + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 一点点常数优化</span></span><br><span class="line">        <span class="keyword">if</span> (calc(l+<span class="number">1</span>, r) == calc(l, r<span class="number">-1</span>)) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重点</span></span><br><span class="line">        <span class="keyword">while</span> (len &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (calc(l+ans/g[len], r) == calc(l, r-ans/g[len]))<span class="comment">// 判断</span></span><br><span class="line">                ans /= g[len];<span class="comment">// 除掉循环次数的因子</span></span><br><span class="line">            len /= g[len];<span class="comment">//分解</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>字符串</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P4167 [Violet]樱花</title>
    <url>/2019/12/25/%E9%A2%98%E8%A7%A3-P4167-Violet-%E6%A8%B1%E8%8A%B1/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.luogu.org/problem/P4167">题目</a></p>
<p>求不定方程</p>
<p><span class="math display">\[\frac{1}{x} + \frac{1}{y} = \frac{1}{n!}\]</span></p>
<p>的正整数解(x,y)的数目。</p>
</blockquote>
<a id="more"></a>
<hr />
<p>先开始<del>万恶的</del>推式子。。。</p>
<p>原式：</p>
<p><span class="math display">\[\frac{1}{x} + \frac{1}{y} = \frac{1}{n!}\]</span></p>
<p>通个分：</p>
<p><span class="math display">\[xy - n!x - n!y= 0\]</span></p>
<p>补点东西：</p>
<p><span class="math display">\[xy - n!x - n!y + (n!)^2= (n!)^2\]</span></p>
<p><span class="math display">\[(n! - x)(n! - y) = (n!)^2\]</span></p>
<p>此时答案就是<span class="math inline">\((n!)^2\)</span>的约数个数</p>
<hr />
<p>统计<span class="math inline">\(n!\)</span>的约数个数：</p>
<p>把1~n质因数分解，统计各质因子的幂数和即可</p>
<p>再用唯一分解定理统计</p>
<p>注意线性筛素数时记录每一个数的最小质因子，分解就具体看代码</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; T k = <span class="number">1</span>; <span class="keyword">char</span> in = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(in)) &#123; <span class="keyword">if</span> (in == <span class="string">&#x27;-&#x27;</span>) k = <span class="number">-1</span>; in = getchar(); &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(in)) x = x * <span class="number">10</span> + in - <span class="string">&#x27;0&#x27;</span>, in = getchar();</span><br><span class="line">    x *= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll n, ans;</span><br><span class="line"><span class="keyword">int</span> cnt[N], g[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pri;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">make_prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            pri.push_back(i), g[i] = pri.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pri.size() &amp;&amp; i * pri[j] &lt;= n; ++j) &#123;</span><br><span class="line">            vis[i*pri[j]] = <span class="literal">true</span>;</span><br><span class="line">            g[i*pri[j]] = j;</span><br><span class="line">            <span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    make_prime();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = i;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">1</span>)</span><br><span class="line">            cnt[g[x]]++, x /= pri[g[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= pri.size(); ++i)</span><br><span class="line">        <span class="keyword">if</span> (cnt[i])</span><br><span class="line">            ans = (ans * (cnt[i] * <span class="number">2</span> + <span class="number">1</span>)) % MOD;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Math</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P5492 [PKUWC2018]随机算法</title>
    <url>/2020/07/24/%E9%A2%98%E8%A7%A3-P5492-PKUWC2018%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P5492">题目</a></p>
<p>数据范围 <span class="math inline">\(n\le20\)</span>，集合/图上问题，考虑状压 DP</p>
<a id="more"></a>
<h2 id="思路">思路</h2>
<p>对于集合的最大独立集 <span class="math inline">\(S\)</span> 的各个点，有 <span class="math inline">\(|S|!\)</span> 种放进独立集的顺序</p>
<blockquote>
<p><strong>生成点集</strong>：<span class="math inline">\(S\)</span> 一个最大的点集 <span class="math inline">\(T\)</span>，满足 <span class="math inline">\(S\subseteq T\)</span> 且不存在 <span class="math inline">\(T\)</span> 的一个独立子集 <span class="math inline">\(U\)</span> 满足<span class="math inline">\(S\subsetneq U\)</span></p>
<p>我的理解：最大独立集为 <span class="math inline">\(S\)</span> 的最大的集合 <span class="math inline">\(T\)</span>，是 <span class="math inline">\(S\)</span> 的生成点集</p>
</blockquote>
<p>对于每一个最大独立集的顺序 <span class="math inline">\(u_1, u_2,...u_{|S|}\)</span></p>
<p><span class="math inline">\(u_1\)</span> 必须第一个加入独立集，接下来所有 <span class="math inline">\(u_1\)</span> 的邻点 <span class="math inline">\(to_{u_1}\)</span> 安排的位置就随便了</p>
<p><span class="math inline">\(\{u_1\}\)</span> 的生成点集 <span class="math inline">\(gs(\{ u_1\} )\)</span>（即 <span class="math inline">\(u_1\)</span> 及其邻点）便处理完了</p>
<p>在剩余的点中，<span class="math inline">\(u_2\)</span> 也必须第一个加入独立集</p>
<p>以此类推</p>
<p>形成独立集顺序为 <span class="math inline">\(u_1, u_2,...u_{|S|}\)</span> 的概率为： <span class="math display">\[
\prod_i^{|S|} \frac{1}{n-|gs(S_{i-1})|}
\]</span> 接下来可以 DP 了</p>
<p>设 <span class="math inline">\(f_S\)</span> 表示集合 <span class="math inline">\(S\)</span> 用该算法形成最大独立集的概率 <span class="math display">\[
\large f_S=\sum_{i\in S}\frac{f_{S-\{ i\} }}{n-|gs(S-\{ i\} )|}
\]</span> 初值 <span class="math inline">\(f_{\varnothing}=1\)</span></p>
<h2 id="code">code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = (<span class="number">1</span> &lt;&lt; <span class="number">20</span>) + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, maxn, maxis, ans;</span><br><span class="line"><span class="keyword">int</span> to[N], <span class="built_in">map</span>[M], size[M], gs[M], f[M], inv[N];</span><br><span class="line"><span class="comment">// to邻点，map见下，size集合大小，gs生成点集</span></span><br><span class="line"><span class="keyword">bool</span> is[M];<span class="comment">// 是否是独立集</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(m);</span><br><span class="line">    maxn = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; ++i)</span><br><span class="line">        read(u), read(v), to[u] |= <span class="number">1</span>&lt;&lt;(v<span class="number">-1</span>), to[v] |= <span class="number">1</span>&lt;&lt;(u<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">map</span>[<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>)] = i;</span><br><span class="line">    is[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; maxn; ++s) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = s &amp; -s, t = s ^ x;</span><br><span class="line">        x = <span class="built_in">map</span>[x], gs[s] = size[s] = size[t] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (is[t] &amp;&amp; !(t &amp; to[x]))</span><br><span class="line">            is[s] = <span class="literal">true</span>, maxis = max(maxis, size[s]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (s &amp; to[i])</span><br><span class="line">                gs[s]++;</span><br><span class="line">    &#125;</span><br><span class="line">    inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        inv[i] = <span class="number">1l</span>l * (MOD - MOD / i) * inv[MOD%i] % MOD;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; maxn; ++s)</span><br><span class="line">        <span class="keyword">if</span> (is[s]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, t; i &lt; maxn; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> (s &amp; i) &#123;</span><br><span class="line">                    t = s ^ i;</span><br><span class="line">                    f[s] = (<span class="number">1l</span>l * f[t] * inv[n - gs[t]] % MOD + f[s]) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span> (size[s] == maxis)</span><br><span class="line">                ans = (ans + f[s]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>状压DP</tag>
        <tag>最大独立集</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P6564 「POI2007」堆积木KLO</title>
    <url>/2020/11/03/%E9%A2%98%E8%A7%A3-P6564-%E3%80%8CPOI2007%E3%80%8D%E5%A0%86%E7%A7%AF%E6%9C%A8KLO/</url>
    <content><![CDATA[<blockquote>
<p>给出长为 n 的序列 a，求一个 a 的子序列 b，最大化 <span class="math inline">\(\sum_{i}^{k}[b_i=i]\)</span>。</p>
</blockquote>
<a id="more"></a>
<h2 id="思路">思路</h2>
<p>DP 时，如果点 i 能从点 j 转移过来，满足条件： <span class="math display">\[
\begin{align}
i&amp;&gt;j\\
a_i&amp;&gt; a_j\\
a_i-a_j&amp;\le i-j
\end{align}
\]</span> 满足后两个条件时一定满足第一个条件。</p>
<p>转化为 <span class="math inline">\(a_i&gt;a_j,i-a_i\ge j-a_j\)</span>，二维偏序直接上 CDQ。</p>
<p>懒得归并，复杂度 <span class="math inline">\(O(n\log^2n)\)</span>。</p>
<p>因为一个 <span class="math inline">\(&gt;\)</span> 一个 <span class="math inline">\(\ge\)</span>，所以 <span class="math inline">\(i-a_i\)</span> 属性要作第一维。</p>
<h2 id="代码">代码</h2>
<p>记得加个 0 点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">Data a[N];</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpx</span><span class="params">(<span class="keyword">const</span> Data &amp;x, <span class="keyword">const</span> Data &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x.x == y.x) <span class="keyword">return</span> x.y &lt; y.y;</span><br><span class="line">    <span class="keyword">return</span> x.x &lt; y.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpy</span><span class="params">(<span class="keyword">const</span> Data &amp;x, <span class="keyword">const</span> Data &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x.y == y.y) <span class="keyword">return</span> x.x &lt; y.x;</span><br><span class="line">    <span class="keyword">return</span> x.y &lt; y.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">CDQ</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    sort(a+l, a+mid+<span class="number">1</span>, cmpy);</span><br><span class="line">    CDQ(l, mid);</span><br><span class="line">    sort(a+l, a+mid+<span class="number">1</span>, cmpx), sort(a+mid+<span class="number">1</span>, a+r+<span class="number">1</span>, cmpx);</span><br><span class="line">    <span class="keyword">int</span> pl = l, pr = mid + <span class="number">1</span>, ma = -INF;</span><br><span class="line">    <span class="keyword">while</span> (pr &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">while</span> (pl &lt;= mid &amp;&amp; a[pl].x &lt; a[pr].x)</span><br><span class="line">            ma = max(ma, f[a[pl].id]), pl++;</span><br><span class="line">        <span class="comment">// 当 i - a[i] &lt; 0 时，该点一定不满足</span></span><br><span class="line">        <span class="keyword">if</span> (a[pr].y &gt;= <span class="number">0</span>) f[a[pr].id] = max(f[a[pr].id], ma + <span class="number">1</span>);</span><br><span class="line">        pr++;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+mid+<span class="number">1</span>, a+r+<span class="number">1</span>, cmpy);</span><br><span class="line">    CDQ(mid+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        read(a[i].x), a[i].y = i - a[i].x, a[i].id = i;</span><br><span class="line">    a[++n] = (Data)&#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    sort(a+<span class="number">1</span>, a+n+<span class="number">1</span>, cmpy);</span><br><span class="line">    CDQ(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        ans = max(ans, f[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P7078 贪吃蛇</title>
    <url>/2020/11/17/%E9%A2%98%E8%A7%A3-P7078-%E8%B4%AA%E5%90%83%E8%9B%87/</url>
    <content><![CDATA[<blockquote>
<p>给出 n 条蛇，最大的蛇可以选择吃或不吃最小蛇，若某一轮中只剩一条蛇或者最大蛇不吃时停止，每条蛇都想活着并吃最多的蛇，求最后剩下的条数。</p>
<p><span class="math inline">\(n\le 10^6,T\le 10\)</span>。</p>
</blockquote>
<p>博弈论+单调性优化。</p>
<a id="more"></a>
<p>CSP2020 T4，考场上压根没看。</p>
<h2 id="思路">思路</h2>
<p>这题有 20 分白给，即 3 条蛇的情况，如果最大蛇吃完之后不是最小蛇肯定要吃。（博主这个煞笔 20 分都没有。）</p>
<p>推广到 n 条蛇，也是同样的道理，这样吃一直下去，直到最大蛇吃完后会变为最小蛇：</p>
<p>这种情况下，最大蛇吃了是有风险的，变成最小蛇时能不能活着要看下一条最大蛇，这种有风险的情况可能会递归下去。</p>
<p>于是现在有三种情况：</p>
<ul>
<li>Case 1：最大蛇吃完之后不是最小蛇；</li>
<li>Case 2：最大蛇吃完之后是最小蛇；</li>
<li>Case 3：只剩 2 条蛇。</li>
</ul>
<p>模拟整个过程：</p>
<p>第一个阶段是 Case 1，最大蛇会放心的吃；</p>
<p>第二个阶段是 Case 2，最大蛇吃后<strong>有风险</strong>，那么就先假定她吃，<strong>递归</strong>下去，会有两个边界：遇到 Case 1 或者 Case 3，这两种情况中最大蛇都肯定会吃，那么上一轮的最大蛇（此时为最小蛇）也就挂了，上一轮的最大蛇也就不会选择吃。</p>
<p>再往回退一层，上上轮的最大蛇知道会在下一轮停止，那么她也就会放心去吃。</p>
<p>可以发现 Case 2 吃不吃取决于递归层数的<strong>奇偶性</strong>。</p>
<p>如果没有经过 Case 2 就到了第三个阶段，最后就会只剩 1 条。</p>
<h2 id="分实现">70 分实现</h2>
<p>我们可以直接模拟，用 set 维护蛇，注意记录进入第二个阶段时的条数，这样 <span class="math inline">\(\mathcal O(Tn\log n)\)</span> 可以拿到 70 分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Snake</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val, id;</span><br><span class="line">    Snake() &#123;&#125;</span><br><span class="line">    Snake(<span class="keyword">int</span> _val, <span class="keyword">int</span> _id) : val(_val), id(_id) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Snake &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> val == t.val ? id &gt; t.id : val &gt; t.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, k;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="built_in">set</span>&lt;Snake&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt;= T; ++c) &#123;</span><br><span class="line">        s.clear();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">1</span>) &#123;</span><br><span class="line">            read(n);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; ++i)</span><br><span class="line">                read(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            read(k);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= k; ++i)</span><br><span class="line">                read(x), read(y), a[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            s.insert(Snake(a[i], i));</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.size() == <span class="number">2</span>) &#123;</span><br><span class="line">                s.erase(--s.end());</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((flag - s.size()) % <span class="number">2</span>) ans = flag + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> ans = flag;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> ans = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">set</span>&lt;Snake&gt;::iterator ma = s.begin(), mi = --s.end();</span><br><span class="line">            <span class="keyword">int</span> val = ma -&gt; val - mi -&gt; val, id = ma -&gt; id;</span><br><span class="line">            s.erase(ma), s.erase(mi);</span><br><span class="line">            s.insert(Snake(val, id));</span><br><span class="line">            <span class="keyword">if</span> ((--s.end()) -&gt; id == id) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!flag) flag = s.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((flag - s.size()) % <span class="number">2</span>) ans = flag + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> ans = flag;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优化">优化</h2>
<p>怎么搞到 <span class="math inline">\(\mathcal O(n)\)</span> 啊，还能吃出个单调性？</p>
<p>联系到往届 NOIP 真题 <a href="https://www.luogu.com.cn/problem/P2827">蚯蚓</a>，并观察发现，新加入的蛇是单调不升的。</p>
<p>因为后一轮的最大蛇比前一轮最大蛇小，后一轮最小蛇比前一轮最小蛇大。</p>
<p>那么 set 就不必了，开两个双端队列即可，一个维护原来的蛇，一个维护新加入的蛇。</p>
<h2 id="分实现-1">100 分实现</h2>
<p>复杂度 <span class="math inline">\(\mathcal O(Tn)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Snake</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val, id;</span><br><span class="line">    Snake() &#123;&#125;</span><br><span class="line">    Snake(<span class="keyword">int</span> _val, <span class="keyword">int</span> _id) : val(_val), id(_id) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Snake &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> val == t.val ? id &lt; t.id : val &lt; t.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, k;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="built_in">deque</span>&lt;Snake&gt; q1, q2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Snake <span class="title">get_max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Snake res;</span><br><span class="line">    <span class="keyword">if</span> (q1.empty()) res = q2.back(), q2.pop_back();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (q2.empty()) res = q1.back(), q1.pop_back();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (q1.back() &lt; q2.back()) res = q2.back(), q2.pop_back();</span><br><span class="line">        <span class="keyword">else</span> res = q1.back(), q1.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Snake <span class="title">get_min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Snake res;</span><br><span class="line">    <span class="keyword">if</span> (q1.empty()) res = q2.front(), q2.pop_front();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (q2.empty()) res = q1.front(), q1.pop_front();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (q1.front() &lt; q2.front()) res = q1.front(), q1.pop_front();</span><br><span class="line">        <span class="keyword">else</span> res = q2.front(), q2.pop_front();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt;= T; ++c) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">1</span>) &#123;</span><br><span class="line">            read(n);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; ++i)</span><br><span class="line">                read(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            read(k);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= k; ++i)</span><br><span class="line">                read(x), read(y), a[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">        q1.clear(), q2.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            q1.push_back(Snake(a[i], i));</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q1.size() + q2.size() == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((flag - <span class="number">1</span>) % <span class="number">2</span>) ans = flag + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> ans = flag;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> ans = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Snake ma = get_max(), mi = get_min(), u(ma.val - mi.val, ma.id);</span><br><span class="line">            <span class="keyword">if</span> ((q1.empty() || u &lt; q1.front()) &amp;&amp; (q2.empty() || u &lt; q2.front())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!flag) flag = q1.size() + q2.size() + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((flag - (q1.size() + q2.size() + <span class="number">1</span>)) % <span class="number">2</span>) ans = flag + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> ans = flag;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            q2.push_front(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>单调性优化</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>20年11月 刷题记录</title>
    <url>/2020/11/14/20%E5%B9%B411%E6%9C%88%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>做题好慢啊。</p>
<a id="more"></a>
<h1 id="日">2日</h1>
<h2 id="p3354-ioi2005riv-河流">P3354 [IOI2005]Riv 河流</h2>
<p><a href="https://www.luogu.com.cn/problem/P3354">题目</a></p>
<p>树形背包 DP。</p>
<p>设 <span class="math inline">\(f_{u,f,k},g_{u,f,k}\)</span> 表示 u 为根的子树以 f 为关键点、强制 / 不强制 u 为关键点、使用了 k 个关键点的最小花费。</p>
<p><span class="math display">\[\begin{aligned} f_{u,f,k}&amp;\leftarrow f_{v,f,l}+f{u,f,k-l}\\g_{u,f,k}&amp;\leftarrow f_{v,u,l}+g_{u,f,k-l} \end{aligned}\]</span></p>
<p>复杂度 <span class="math inline">\(\mathcal O(n^4)\)</span>。</p>
<h1 id="日-1">3日</h1>
<h2 id="acwing277-饼干">AcWing277 饼干</h2>
<p><a href="https://www.acwing.com/problem/content/description/279">题目</a></p>
<p>简单 DP。</p>
<p>先贪心地让怨气值大的在前，则分配饼干个数单调不增，设 <span class="math inline">\(f_{i,j}\)</span> 表示前 i 个人分 j 个饼干最优答案。</p>
<p>简化状态，强制让最后一个人只得到 1 个，其他状态 <span class="math inline">\(f_{i,j}\Leftarrow f_{i,j-i}\)</span>。</p>
<p>接下来只要考虑最后有多少个人同样分到 1 个就行。</p>
<p>复杂度 <span class="math inline">\(\mathcal O(n^2m)\)</span>。</p>
<h2 id="p6564-poi2007-堆积木klo">P6564 [POI2007] 堆积木KLO</h2>
<p><a href="https://www.luogu.com.cn/problem/P6564">题目</a></p>
<p>CDQ，BIT，LIS 等均可。</p>
<p><span class="math display">\[\begin{aligned} i&amp;&gt;j,\\ a_i&amp;&gt; a_j,\\ a_i-a_j&amp;\le i-j \end{aligned}\]</span></p>
<p>满足后两个条件时一定满足第一个条件，转化为二维偏序直接上 CDQ。</p>
<p>因为一个 <span class="math inline">\(&gt;\)</span> 一个 <span class="math inline">\(\ge\)</span>，所以 <span class="math inline">\(i-a_i\)</span> 属性要作第一维。</p>
<h2 id="p2175-小z的游戏分队">P2175 小Z的游戏分队</h2>
<p><a href="https://www.luogu.com.cn/problem/P2175">题目</a></p>
<p>每个人向不信任的人连边，形成若干个二分图。</p>
<p>以每个二分图两边人数差为权值，背包 DP 某个答案是否能出现。</p>
<h1 id="日-2">4日</h1>
<h2 id="p1800-software">P1800 software</h2>
<p><a href="https://www.luogu.com.cn/problem/P1800">题目</a></p>
<p>二分 + 背包 DP。</p>
<p>明显答案是单调的，考虑怎么判定合法。</p>
<p>在时间限制内，每个人固定了任务一的量，就能确定任务二的量，于是将一个人拆成 m 个物品。</p>
<p>背包 DP 出 n 个人完成任务一时最多能够完成的任务二的量即可。</p>
<h2 id="u139384-异或和">U139384 异或和</h2>
<p><a href="https://www.luogu.com.cn/problem/U139384">题目</a></p>
<p>FWT。</p>
<p>设 <span class="math inline">\(f^i(x)\)</span> 表示选 <span class="math inline">\(i\)</span> 个数，异或和能否为 <span class="math inline">\(x\)</span>，容易得到 <span class="math inline">\(f^1(x)\)</span>，通过 FWT 自卷即可转移。</p>
<p>将选取最多的，转化为删去最少的使得异或和为零（前者）。</p>
<p>设所有数异或和为 <span class="math inline">\(s\)</span>，异或和能够为 <span class="math inline">\(s\)</span> 的个数只有 <span class="math inline">\(\log_2n\)</span> 级别（线性基）。</p>
<p>那么只要处理前 <span class="math inline">\(\log_2n\)</span> 的 <span class="math inline">\(f^i(x)\)</span> 即可，每次暴力 FWT 和 iFWT 可以做到 <span class="math inline">\(\mathcal O(n\log^2n)\)</span>。</p>
<p>丧心病狂的出题人 <a href="https://www.luogu.com.cn/user/96912">AzusaCat</a> 竟然卡掉两个 log 的做法！！！</p>
<p>考虑优化 iFWT，因为每次只需要 <span class="math inline">\(f^i(s)\)</span> 的值，单点的话从 FWT 的原理逆推：</p>
<p><span class="math display">\[\begin{aligned} \hat{F}*S&amp;=\sum*{T\subseteq U}(-1)^{|S\cap T|}F_T \\ F_S&amp;=\frac{1}{2^n}\sum_{T\subseteq U}(-1)^{|S\cap T|}\hat F_T \end{aligned}\]</span></p>
<p>每次只要 <span class="math inline">\(\mathcal O(n)\)</span> 即可得到单点的值，总复杂度降至 <span class="math inline">\(\mathcal O(n\log n)\)</span>。</p>
<h2 id="p3047-usaco12febnearby-cows-g">P3047 [USACO12FEB]Nearby Cows G</h2>
<p><a href="https://www.luogu.com.cn/problem/P3047">题目</a></p>
<p>换根 DP。</p>
<p>先处理出 <span class="math inline">\(f_{u,i}\)</span> 表示以 u 为根的子树深度为 i 的点权和，<span class="math inline">\(\mathcal O(k)\)</span> 转移。此时 1 的 DP 值为答案。</p>
<p>换根，每次将 u 的一个子树 v 贡献减去，分成两个独立的树，再由 u 转移到 v 即可。</p>
<blockquote>
<p>换根 DP 的特点是能够快速地将子树分离、改变父子关系后合并</p>
</blockquote>
<h1 id="日-3">5日</h1>
<h2 id="p4161-scoi2009游戏">P4161 [SCOI2009]游戏</h2>
<p><a href="https://www.luogu.com.cn/problem/P4161">题目</a></p>
<p>数论，背包 DP。</p>
<p>容易发现一个排列可以看成几个环，而变换回来的步数是这些环的 <span class="math inline">\(\operatorname{lcm}\)</span>。</p>
<p>问题转化成：n 拆成若干个数的和，这些数的 <span class="math inline">\(\operatorname{lcm}\)</span> 的种数。</p>
<p>将 <span class="math inline">\(\operatorname{lcm}\)</span> 唯一分解，每个质因子的指数为所有数该质因子的最大指数。</p>
<p>那么 DP 每个质数不同质数的情况下的方案数，转化成完全背包。</p>
<p>设 <span class="math inline">\(f_{i,j}\)</span> 表示到第 i 个质数，将 j 拆开的 <span class="math inline">\(\operatorname{lcm}\)</span> 种数，则 <span class="math inline">\(f_{i,j}\leftarrow f_{i-1,j}+f_{i-1,j-p_i^k}\)</span>。</p>
<p>因为无法处理 1，而 1 不影响 <span class="math inline">\(\operatorname{lcm}\)</span>，所以拆开的数的和不一定为 n，剩下的用 1 填满，最后答案为 <span class="math inline">\(\sum_{i=0}^n f_{cnt_p,i}\)</span>。</p>
<h2 id="p6280-usaco20openexercise-g">P6280 [USACO20OPEN]Exercise G</h2>
<p><a href="https://www.luogu.com.cn/problem/P6280">题目</a></p>
<p>和上题一样，只不过是求 <span class="math inline">\(\operatorname{lcm}\)</span> 的和。</p>
<p>每次 DP 时是一个新的素数，所以直接乘以上一个状态，<span class="math inline">\(f_{i,j}\leftarrow f_{i-1,j}+f_{i-1,j-p_i^k}\times p_i^k\)</span>。</p>
<h2 id="p4342-ioi1998polygon">P4342 [IOI1998]Polygon</h2>
<p><a href="https://www.luogu.com.cn/problem/P4342">题目</a></p>
<p>区间 DP。</p>
<p>题目唬人，但是容易看出来每次断成链后是个区间 DP，枚举断点后直接做，<span class="math inline">\(\mathcal O(n^4)\)</span> 可过。</p>
<p>然后就 80 分 qwq。因为有乘法，而每个数可能为负，负负得正。</p>
<p>于是同时维护最大值和最小值。</p>
<h2 id="p4158-scoi2009粉刷匠">P4158 [SCOI2009]粉刷匠</h2>
<p><a href="https://www.luogu.com.cn/problem/P4158">题目</a></p>
<p>简单 DP + 背包 DP。</p>
<p>问题在于如何分配粉刷次数，先对于每一行单独处理，将不同粉刷次数的答案化为物品。</p>
<p>设 <span class="math inline">\(f_{i,k}\)</span> 表示前 <span class="math inline">\(i\)</span> 位粉刷 <span class="math inline">\(k\)</span> 次最多正确个数，<span class="math inline">\(f_{i,k}\leftarrow f_{j,k-1}+\max\{s_0(j+1,i),s_1(j+1,i)\}\)</span>。</p>
<p>然后对于 <span class="math inline">\(n\times m\)</span> 个物品进行背包即可。</p>
<h2 id="p1092-虫食算">P1092 虫食算</h2>
<p><a href="https://www.luogu.com.cn/problem/P1092">题目</a></p>
<p>搜索。</p>
<p>正解好像是高斯消元，不会。</p>
<p>从低位到高位开始搜，当三位中有两个确定时就可以推出第三个。</p>
<p>还有一个剪枝，每确定一列，就扫一遍后面没搜的列，看在进不进位的情况下是否都矛盾。</p>
<h2 id="p3951-小凯的疑惑">P3951 小凯的疑惑</h2>
<p><a href="https://www.luogu.com.cn/problem/P3951">题目</a></p>
<p>数论。</p>
<p>打表，发现 <span class="math inline">\(a&lt;b\)</span> 时答案是 <span class="math inline">\((a-1)\times b - a\)</span>。</p>
<p>证明：设无法表示出来的为 x。</p>
<p><span class="math display">\[\begin{aligned} x&amp;\equiv ma\pmod b \quad&amp;(1&lt;m&lt;b)\\ x&amp;=ma+nb\quad&amp;(1&lt;m&lt;b,n&lt;0) \end{aligned}\]</span></p>
<p>当 x 最大时，<span class="math inline">\(m=b-1,n=-1\)</span>，证毕。</p>
<h2 id="p5092-usaco04opencube-stacking">P5092 [USACO04OPEN]Cube Stacking</h2>
<p><a href="https://www.luogu.com.cn/record/41327125">题目</a></p>
<p>并查集。</p>
<p>在 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(fa\)</span> 的边之间维护压缩的边数，路径压缩优化，再维护每个并查集的 size。</p>
<h2 id="p2894-usaco08febhotel-g">P2894 [USACO08FEB]Hotel G</h2>
<p><a href="https://www.luogu.com.cn/problem/P2894">题目</a></p>
<p>线段树。</p>
<p>维护每个区间的最长连续区间和左端开头、右端开头的最长连续区间。</p>
<p>二分最早的 r 使得 <span class="math inline">\([1,r]\)</span> 的最长连续区间长度大于 x，<span class="math inline">\(\mathcal O(n\log^2n)\)</span>。</p>
<p>query 时直接左区间优先即可，<span class="math inline">\(\mathcal O(n\log n)\)</span>。</p>
<h1 id="日-4">11日</h1>
<h2 id="p7076-动物园">P7076 动物园</h2>
<p><a href="https://www.luogu.com.cn/problem/P7076">题目</a></p>
<p>贪心（？），CSP2020 T2。</p>
<p>将所有动物或起来，对于每一位，没有饲料或者有饲料并且已经购买，该位可以选或不选；有饲料且未购买，只能不选。</p>
<p>把每一位的答案乘一下，坑点是开了 unsigned long long 也见祖宗，需要特判 <span class="math inline">\(2^{64}\)</span> 的情况。</p>
<h1 id="日-5">12日</h1>
<h2 id="p7077-函数调用">P7077 函数调用</h2>
<p><a href="https://www.luogu.com.cn/problem/P7077">题目</a></p>
<p>拓扑 DP，CSP2020 T3。</p>
<p>考场上写的线段树暴力，<del>好歹也是个不小的数据结构啊怎么才给 30 分！</del>其实是不错的题。</p>
<p>可以发现单点加值，整体乘值，所有操作形成若干个 DAG，只要求最终序列，于是方向转向图论。</p>
<p>设所有乘法之积为 <span class="math inline">\(mul\)</span>，每个点初始值的贡献一定是 <span class="math inline">\(a_i\times mul\)</span>。</p>
<p>接下来考虑单点加和其之后的变化。每个单点加的贡献是后面所有乘法之积。</p>
<p>那么先预处理每个点的及后面乘法的积 <span class="math inline">\(m_i\)</span>，然后按照操作序列倒着 DP 每个DAG 的贡献次数。</p>
<p>再在 DAG 里倒着 DP，<span class="math inline">\(f_v\leftarrow f_v + f_u, f_u\leftarrow f_u\times m_v\)</span>，对于单点加的贡献就有 <span class="math inline">\(f_u\times val_u\)</span>。</p>
<h1 id="日-6">17日</h1>
<h2 id="p7078-贪吃蛇">P7078 贪吃蛇</h2>
<p><a href="https://www.luogu.com.cn/problem/P7078">题目</a></p>
<p>博弈论+单调性优化，CSP2020 T4。</p>
<p>见<a href="https://renamoe.github.io/2020/11/17/题解-P7078-贪吃蛇">博客题解</a>。</p>
<h1 id="日-7">20日</h1>
<h2 id="cf455d-serega-and-fun">CF455D Serega and Fun</h2>
<p><a href="https://www.luogu.com.cn/problem/CF455D">题目</a></p>
<p>平衡树或者分块。</p>
<p>对于第一个操作可以用一棵 splay 轻松维护，称其为序列树。</p>
<p>因为值域 <span class="math inline">\(\mathcal O(n)\)</span>，第二个操作考虑每个值维护一棵 splay，节点存其对应的序列树的编号。</p>
<p>每次询问一个区间要求在某一棵 splay 里寻找区间内最靠左和最靠右的点，可以通过在序列树上查 rank 来二分，单次 <span class="math inline">\(\mathcal O(\log^2n)\)</span>。</p>
<h2 id="s2oj41-新斯诺克">S2OJ#41 新斯诺克</h2>
<p><a href="http://sjzezoj.com:9280/problem/41">题目</a></p>
<p>归并排序就够了。</p>
<p>可以让所有数减去 m，然后做前缀和，满足 <span class="math inline">\(j&lt;i, s_j&lt;s_i\)</span> 的一对点构成一个合法区间。</p>
<p>二维偏序，可以做到 <span class="math inline">\(\mathcal O(n\log n)\)</span>。这个煞笔又写了个比别多个 <span class="math inline">\(\log\)</span> 的 CDQ 分治。</p>
<h1 id="日-8">21日</h1>
<h2 id="s2oj42-方舟连接">S2OJ#42 方舟连接</h2>
<p><a href="http://sjzezoj.com:9280/problem/59">题目</a></p>
<p>区间 DP + 四边形不等式优化。</p>
<p>把路径看成一棵树，然后发现这是两两相邻子树合并，转化成一个序列就是区间 DP。</p>
<p><span class="math inline">\(\mathcal O(n^3)\)</span> 过不去，简单证明一下 DP 为凸，套上经典的四边形不等式优化，降到 <span class="math inline">\(\mathcal O(n^2)\)</span>。</p>
<h2 id="s2oj60-a-simple-math-problem-vi">S2OJ#60 A Simple Math Problem VI</h2>
<p><a href="http://sjzezoj.com:9280/problem/60">题目</a></p>
<p>小数据裸完全背包。大数据特殊性质 <span class="math inline">\(a_i=1\)</span>，组合数问题 <a href="https://oi-wiki.org/math/combination/#1">见 OI wiki</a>。</p>
<h1 id="日-9">22日</h1>
<h2 id="p4093-heoi2016tjoi2016序列">P4093 [HEOI2016/TJOI2016]序列</h2>
<p><a href="https://www.luogu.com.cn/problem/P4093">题目</a></p>
<p>CDQ 分治。</p>
<p>设 <span class="math inline">\(mi_i=\min\{val_i,w_i\},ma_i=\max\{val_i,w_i\}\)</span>，求 LIS 的时候转移的条件为：</p>
<p><span class="math inline">\(\begin{aligned} j&amp;&lt;i\\ val_j&amp;\le mi_i\\ ma_j&amp;\le val_i \end{aligned}\)</span></p>
<p>CDQ 分治，左右分别按上边对应的属性排序；优先递归处理左区间。复杂度 <span class="math inline">\(\mathcal O(n\log^2 n)\)</span>。</p>
<h1 id="日-10">26日</h1>
<h2 id="cf571d-campus">CF571D Campus</h2>
<p><a href="https://www.luogu.com.cn/problem/CF571D">题目</a></p>
<p>转化成树上问题 + 树状数组上二分技巧。</p>
<p><a href="http://localhost:4000/2020/11/26/题解-CF571D-Campus/">见博客</a></p>
<h1 id="日-11">27日</h1>
<h2 id="gym102331b-bitwise-xor">GYM102331B Bitwise Xor</h2>
<p><a href="https://codeforces.com/gym/102331/problem/B">题目</a></p>
<p>简单 DP + 01-trie。</p>
<p><a href="https://renamoe.github.io/2020/11/27/题解-GYM102331B-Bitwise-Xor/">见博客</a></p>
<h1 id="日-12">2日</h1>
<h2 id="p3354-ioi2005riv-河流-1">P3354 [IOI2005]Riv 河流</h2>
<p><a href="https://www.luogu.com.cn/problem/P3354">题目</a></p>
<p>树形背包 DP。</p>
<p>设 <span class="math inline">\(f_{u,f,k},g_{u,f,k}\)</span> 表示 u 为根的子树以 f 为关键点、强制 / 不强制 u 为关键点、使用了 k 个关键点的最小花费。</p>
<p><span class="math display">\[\begin{aligned} f_{u,f,k}&amp;\leftarrow f_{v,f,l}+f{u,f,k-l}\\g_{u,f,k}&amp;\leftarrow f_{v,u,l}+g_{u,f,k-l} \end{aligned}\]</span></p>
<p>复杂度 <span class="math inline">\(\mathcal O(n^4)\)</span>。</p>
<h1 id="日-13">3日</h1>
<h2 id="acwing277-饼干-1">AcWing277 饼干</h2>
<p><a href="https://www.acwing.com/problem/content/description/279">题目</a></p>
<p>简单 DP。</p>
<p>先贪心地让怨气值大的在前，则分配饼干个数单调不增，设 <span class="math inline">\(f_{i,j}\)</span> 表示前 i 个人分 j 个饼干最优答案。</p>
<p>简化状态，强制让最后一个人只得到 1 个，其他状态 <span class="math inline">\(f_{i,j}\Leftarrow f_{i,j-i}\)</span>。</p>
<p>接下来只要考虑最后有多少个人同样分到 1 个就行。</p>
<p>复杂度 <span class="math inline">\(\mathcal O(n^2m)\)</span>。</p>
<h2 id="p6564-poi2007-堆积木klo-1">P6564 [POI2007] 堆积木KLO</h2>
<p><a href="https://www.luogu.com.cn/problem/P6564">题目</a></p>
<p>CDQ，BIT，LIS 等均可。</p>
<p><span class="math display">\[\begin{aligned} i&amp;&gt;j,\\ a_i&amp;&gt; a_j,\\ a_i-a_j&amp;\le i-j \end{aligned}\]</span></p>
<p>满足后两个条件时一定满足第一个条件，转化为二维偏序直接上 CDQ。</p>
<p>因为一个 <span class="math inline">\(&gt;\)</span> 一个 <span class="math inline">\(\ge\)</span>，所以 <span class="math inline">\(i-a_i\)</span> 属性要作第一维。</p>
<h2 id="p2175-小z的游戏分队-1">P2175 小Z的游戏分队</h2>
<p><a href="https://www.luogu.com.cn/problem/P2175">题目</a></p>
<p>每个人向不信任的人连边，形成若干个二分图。</p>
<p>以每个二分图两边人数差为权值，背包 DP 某个答案是否能出现。</p>
<h1 id="日-14">4日</h1>
<h2 id="p1800-software-1">P1800 software</h2>
<p><a href="https://www.luogu.com.cn/problem/P1800">题目</a></p>
<p>二分 + 背包 DP。</p>
<p>明显答案是单调的，考虑怎么判定合法。</p>
<p>在时间限制内，每个人固定了任务一的量，就能确定任务二的量，于是将一个人拆成 m 个物品。</p>
<p>背包 DP 出 n 个人完成任务一时最多能够完成的任务二的量即可。</p>
<h2 id="u139384-异或和-1">U139384 异或和</h2>
<p><a href="https://www.luogu.com.cn/problem/U139384">题目</a></p>
<p>FWT。</p>
<p>设 <span class="math inline">\(f^i(x)\)</span> 表示选 <span class="math inline">\(i\)</span> 个数，异或和能否为 <span class="math inline">\(x\)</span>，容易得到 <span class="math inline">\(f^1(x)\)</span>，通过 FWT 自卷即可转移。</p>
<p>将选取最多的，转化为删去最少的使得异或和为零（前者）。</p>
<p>设所有数异或和为 <span class="math inline">\(s\)</span>，异或和能够为 <span class="math inline">\(s\)</span> 的个数只有 <span class="math inline">\(\log_2n\)</span> 级别（线性基）。</p>
<p>那么只要处理前 <span class="math inline">\(\log_2n\)</span> 的 <span class="math inline">\(f^i(x)\)</span> 即可，每次暴力 FWT 和 iFWT 可以做到 <span class="math inline">\(\mathcal O(n\log^2n)\)</span>。</p>
<p>丧心病狂的出题人 <span class="math inline">\(\rm \color{black}{A}\color{red}{zusaCat}\)</span> 竟然卡掉两个 log 的做法！！！</p>
<p>考虑优化 iFWT，因为每次只需要 <span class="math inline">\(f^i(s)\)</span> 的值，单点的话从 FWT 的原理逆推：</p>
<p><span class="math display">\[\begin{aligned} \hat{F}*S&amp;=\sum*{T\subseteq U}(-1)^{|S\cap T|}F_T \\ F_S&amp;=\frac{1}{2^n}\sum_{T\subseteq U}(-1)^{|S\cap T|}\hat F_T \end{aligned}\]</span></p>
<p>每次只要 <span class="math inline">\(\mathcal O(n)\)</span> 即可得到单点的值，总复杂度降至 <span class="math inline">\(\mathcal O(n\log n)\)</span>。</p>
<h2 id="p3047-usaco12febnearby-cows-g-1">P3047 [USACO12FEB]Nearby Cows G</h2>
<p><a href="https://www.luogu.com.cn/problem/P3047">题目</a></p>
<p>换根 DP。</p>
<p>先处理出 <span class="math inline">\(f_{u,i}\)</span> 表示以 u 为根的子树深度为 i 的点权和，<span class="math inline">\(\mathcal O(k)\)</span> 转移。此时 1 的 DP 值为答案。</p>
<p>换根，每次将 u 的一个子树 v 贡献减去，分成两个独立的树，再由 u 转移到 v 即可。</p>
<blockquote>
<p>换根 DP 的特点是能够快速地将子树分离、改变父子关系后合并</p>
</blockquote>
<h1 id="日-15">5日</h1>
<h2 id="p4161-scoi2009游戏-1">P4161 [SCOI2009]游戏</h2>
<p><a href="https://www.luogu.com.cn/problem/P4161">题目</a></p>
<p>数论，背包 DP。</p>
<p>容易发现一个排列可以看成几个环，而变换回来的步数是这些环的 <span class="math inline">\(\operatorname{lcm}\)</span>。</p>
<p>问题转化成：n 拆成若干个数的和，这些数的 <span class="math inline">\(\operatorname{lcm}\)</span> 的种数。</p>
<p>将 <span class="math inline">\(\operatorname{lcm}\)</span> 唯一分解，每个质因子的指数为所有数该质因子的最大指数。</p>
<p>那么 DP 每个质数不同质数的情况下的方案数，转化成完全背包。</p>
<p>设 <span class="math inline">\(f_{i,j}\)</span> 表示到第 i 个质数，将 j 拆开的 <span class="math inline">\(\operatorname{lcm}\)</span> 种数，则 <span class="math inline">\(f_{i,j}\leftarrow f_{i-1,j}+f_{i-1,j-p_i^k}\)</span>。</p>
<p>因为无法处理 1，而 1 不影响 <span class="math inline">\(\operatorname{lcm}\)</span>，所以拆开的数的和不一定为 n，剩下的用 1 填满，最后答案为 <span class="math inline">\(\sum_{i=0}^n f_{cnt_p,i}\)</span>。</p>
<h2 id="p6280-usaco20openexercise-g-1">P6280 [USACO20OPEN]Exercise G</h2>
<p><a href="https://www.luogu.com.cn/problem/P6280">题目</a></p>
<p>和上题一样，只不过是求 <span class="math inline">\(\operatorname{lcm}\)</span> 的和。</p>
<p>每次 DP 时是一个新的素数，所以直接乘以上一个状态，<span class="math inline">\(f_{i,j}\leftarrow f_{i-1,j}+f_{i-1,j-p_i^k}\times p_i^k\)</span>。</p>
<h2 id="p4342-ioi1998polygon-1">P4342 [IOI1998]Polygon</h2>
<p><a href="https://www.luogu.com.cn/problem/P4342">题目</a></p>
<p>区间 DP。</p>
<p>题目唬人，但是容易看出来每次断成链后是个区间 DP，枚举断点后直接做，<span class="math inline">\(\mathcal O(n^4)\)</span> 可过。</p>
<p>然后就 80 分 qwq。因为有乘法，而每个数可能为负，负负得正。</p>
<p>于是同时维护最大值和最小值。</p>
<h2 id="p4158-scoi2009粉刷匠-1">P4158 [SCOI2009]粉刷匠</h2>
<p><a href="https://www.luogu.com.cn/problem/P4158">题目</a></p>
<p>简单 DP + 背包 DP。</p>
<p>问题在于如何分配粉刷次数，先对于每一行单独处理，将不同粉刷次数的答案化为物品。</p>
<p>设 <span class="math inline">\(f_{i,k}\)</span> 表示前 <span class="math inline">\(i\)</span> 位粉刷 <span class="math inline">\(k\)</span> 次最多正确个数，<span class="math inline">\(f_{i,k}\leftarrow f_{j,k-1}+\max\{s_0(j+1,i),s_1(j+1,i)\}\)</span>。</p>
<p>然后对于 <span class="math inline">\(n\times m\)</span> 个物品进行背包即可。</p>
<h2 id="p1092-虫食算-1">P1092 虫食算</h2>
<p><a href="https://www.luogu.com.cn/problem/P1092">题目</a></p>
<p>搜索。</p>
<p>正解好像是高斯消元，不会。</p>
<p>从低位到高位开始搜，当三位中有两个确定时就可以推出第三个。</p>
<p>还有一个剪枝，每确定一列，就扫一遍后面没搜的列，看在进不进位的情况下是否都矛盾。</p>
<h2 id="p3951-小凯的疑惑-1">P3951 小凯的疑惑</h2>
<p><a href="https://www.luogu.com.cn/problem/P3951">题目</a></p>
<p>数论。</p>
<p>打表，发现 <span class="math inline">\(a&lt;b\)</span> 时答案是 <span class="math inline">\((a-1)\times b - a\)</span>。</p>
<p>证明：设无法表示出来的为 x。</p>
<p><span class="math display">\[\begin{aligned} x&amp;\equiv ma\pmod b \quad&amp;(1&lt;m&lt;b)\\ x&amp;=ma+nb\quad&amp;(1&lt;m&lt;b,n&lt;0) \end{aligned}\]</span></p>
<p>当 x 最大时，<span class="math inline">\(m=b-1,n=-1\)</span>，证毕。</p>
<h2 id="p5092-usaco04opencube-stacking-1">P5092 [USACO04OPEN]Cube Stacking</h2>
<p><a href="https://www.luogu.com.cn/record/41327125">题目</a></p>
<p>并查集。</p>
<p>在 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(fa\)</span> 的边之间维护压缩的边数，路径压缩优化，再维护每个并查集的 size。</p>
<h2 id="p2894-usaco08febhotel-g-1">P2894 [USACO08FEB]Hotel G</h2>
<p><a href="https://www.luogu.com.cn/problem/P2894">题目</a></p>
<p>线段树。</p>
<p>维护每个区间的最长连续区间和左端开头、右端开头的最长连续区间。</p>
<p>二分最早的 r 使得 <span class="math inline">\([1,r]\)</span> 的最长连续区间长度大于 x，<span class="math inline">\(\mathcal O(n\log^2n)\)</span>。</p>
<p>query 时直接左区间优先即可，<span class="math inline">\(\mathcal O(n\log n)\)</span>。</p>
<h1 id="日-16">11日</h1>
<h2 id="p7076-动物园-1">P7076 动物园</h2>
<p><a href="https://www.luogu.com.cn/problem/P7076">题目</a></p>
<p>贪心（？），CSP2020 T2。</p>
<p>将所有动物或起来，对于每一位，没有饲料或者有饲料并且已经购买，该位可以选或不选；有饲料且未购买，只能不选。</p>
<p>把每一位的答案乘一下，坑点是开了 unsigned long long 也见祖宗，需要特判 <span class="math inline">\(2^{64}\)</span> 的情况。</p>
<h1 id="日-17">12日</h1>
<h2 id="p7077-函数调用-1">P7077 函数调用</h2>
<p><a href="https://www.luogu.com.cn/problem/P7077">题目</a></p>
<p>拓扑 DP，CSP2020 T3。</p>
<p>考场上写的线段树暴力，<del>好歹也是个不小的数据结构啊怎么才给 30 分！</del>其实是不错的题。</p>
<p>可以发现单点加值，整体乘值，所有操作形成若干个 DAG，只要求最终序列，于是方向转向图论。</p>
<p>设所有乘法之积为 <span class="math inline">\(mul\)</span>，每个点初始值的贡献一定是 <span class="math inline">\(a_i\times mul\)</span>。</p>
<p>接下来考虑单点加和其之后的变化。每个单点加的贡献是后面所有乘法之积。</p>
<p>那么先预处理每个点的及后面乘法的积 <span class="math inline">\(m_i\)</span>，然后按照操作序列倒着 DP 每个DAG 的贡献次数。</p>
<p>再在 DAG 里倒着 DP，<span class="math inline">\(f_v\leftarrow f_v + f_u, f_u\leftarrow f_u\times m_v\)</span>，对于单点加的贡献就有 <span class="math inline">\(f_u\times val_u\)</span>。</p>
<h1 id="日-18">17日</h1>
<h2 id="p7078-贪吃蛇-1">P7078 贪吃蛇</h2>
<p><a href="https://www.luogu.com.cn/problem/P7078">题目</a></p>
<p>博弈论+单调性优化，CSP2020 T4。</p>
<p>见<a href="https://renamoe.github.io/2020/11/17/题解-P7078-贪吃蛇">博客题解</a>。</p>
<h1 id="日-19">20日</h1>
<h2 id="cf455d-serega-and-fun-1">CF455D Serega and Fun</h2>
<p><a href="https://www.luogu.com.cn/problem/CF455D">题目</a></p>
<p>平衡树或者分块。</p>
<p>对于第一个操作可以用一棵 splay 轻松维护，称其为序列树。</p>
<p>因为值域 <span class="math inline">\(\mathcal O(n)\)</span>，第二个操作考虑每个值维护一棵 splay，节点存其对应的序列树的编号。</p>
<p>每次询问一个区间要求在某一棵 splay 里寻找区间内最靠左和最靠右的点，可以通过在序列树上查 rank 来二分，单次 <span class="math inline">\(\mathcal O(\log^2n)\)</span>。</p>
<h2 id="s2oj41-新斯诺克-1">S2OJ#41 新斯诺克</h2>
<p><a href="http://sjzezoj.com:9280/problem/41">题目</a></p>
<p>归并排序就够了。</p>
<p>可以让所有数减去 m，然后做前缀和，满足 <span class="math inline">\(j&lt;i, s_j&lt;s_i\)</span> 的一对点构成一个合法区间。</p>
<p>二维偏序，可以做到 <span class="math inline">\(\mathcal O(n\log n)\)</span>。这个煞笔又写了个比别多个 <span class="math inline">\(\log\)</span> 的 CDQ 分治。</p>
<h1 id="日-20">21日</h1>
<h2 id="s2oj42-方舟连接-1">S2OJ#42 方舟连接</h2>
<p><a href="http://sjzezoj.com:9280/problem/59">题目</a></p>
<p>区间 DP + 四边形不等式优化。</p>
<p>把路径看成一棵树，然后发现这是两两相邻子树合并，转化成一个序列就是区间 DP。</p>
<p><span class="math inline">\(\mathcal O(n^3)\)</span> 过不去，简单证明一下 DP 为凸，套上经典的四边形不等式优化，降到 <span class="math inline">\(\mathcal O(n^2)\)</span>。</p>
<h2 id="s2oj60-a-simple-math-problem-vi-1">S2OJ#60 A Simple Math Problem VI</h2>
<p><a href="http://sjzezoj.com:9280/problem/60">题目</a></p>
<p>小数据裸完全背包。大数据特殊性质 <span class="math inline">\(a_i=1\)</span>，组合数问题 <a href="https://oi-wiki.org/math/combination/#1">见 OI wiki</a>。</p>
<h1 id="日-21">22日</h1>
<h2 id="p4093-heoi2016tjoi2016序列-1">P4093 [HEOI2016/TJOI2016]序列</h2>
<p><a href="https://www.luogu.com.cn/problem/P4093">题目</a></p>
<p>CDQ 分治。</p>
<p>设 <span class="math inline">\(mi_i=\min\{val_i,w_i\},ma_i=\max\{val_i,w_i\}\)</span>，求 LIS 的时候转移的条件为：</p>
<p><span class="math inline">\(\begin{aligned} j&amp;&lt;i\\ val_j&amp;\le mi_i\\ ma_j&amp;\le val_i \end{aligned}\)</span></p>
<p>CDQ 分治，左右分别按上边对应的属性排序；优先递归处理左区间。复杂度 <span class="math inline">\(\mathcal O(n\log^2 n)\)</span>。</p>
<h1 id="日-22">26日</h1>
<h2 id="cf571d-campus-1">CF571D Campus</h2>
<p><a href="https://www.luogu.com.cn/problem/CF571D">题目</a></p>
<p>转化成树上问题 + 树状数组上二分技巧。</p>
<p><a href="http://localhost:4000/2020/11/26/题解-CF571D-Campus/">见博客</a></p>
<h1 id="日-23">27日</h1>
<h2 id="gym102331b-bitwise-xor-1">GYM102331B Bitwise Xor</h2>
<p><a href="https://codeforces.com/gym/102331/problem/B">题目</a></p>
<p>简单 DP + 01-trie。</p>
<p><a href="https://renamoe.github.io/2020/11/27/题解-GYM102331B-Bitwise-Xor/">见博客</a></p>
<h1 id="日-24">28日</h1>
<h2 id="s2oj61-连续段的期望">S2OJ#61 连续段的期望</h2>
<p><a href="https://sjzezoj.com/problem/61">题目</a></p>
<p>二进制优化。</p>
<p><span class="math inline">\(\operatorname{xor,or,and}\)</span> 操作每一位互不影响，可以把每一位分开做（常规套路），其实也是其中 <span class="math inline">\(30\)</span> 分部分分的意义。</p>
<p>对于一个 01 串：</p>
<ul>
<li><span class="math inline">\(\operatorname{xor}\)</span>，每个和为奇数的区间贡献为 <span class="math inline">\(1\)</span>，通过类似差分的技巧扫一遍即可；</li>
<li><span class="math inline">\(\operatorname{and}\)</span>，区间内全为 <span class="math inline">\(1\)</span> 贡献为 <span class="math inline">\(1\)</span>，所有每个连续为 <span class="math inline">\(1\)</span> 的段贡献为 <span class="math inline">\(len^2\)</span>；</li>
<li><span class="math inline">\(\operatorname{or}\)</span>，反过来想，区间全为 <span class="math inline">\(0\)</span> 的没有贡献。</li>
</ul>
<p>记得每一位的答案乘上 <span class="math inline">\(2^i\)</span>。</p>
<h1 id="日-25">29日</h1>
<h2 id="s2oj52-练习曲">S2OJ#52 练习曲</h2>
<p><a href="https://sjzezoj.com/problem/52">题目</a></p>
<p>简单 DP。</p>
<p>不修改的话 DP 方程： <span class="math display">\[
\begin{aligned}
f_i&amp;=\min_{i-L\le j&lt;i}\{f_j\}+w(j+1,i)\\
w(j,i)&amp;=\max\{\max_{j\le k&lt;i}\{a_k\},\ a_i-1\} + 1
\end{aligned}
\]</span></p>
<p>修改的话，发现一个点只影响 <span class="math inline">\(2L\)</span> 个 DP 值，那么预处理正着和倒着分别 DP 一遍，处理影响的一段后拼接得到答案。</p>
<p>可以发现 <span class="math inline">\(f_i\)</span> 是单调不降的。从 <span class="math inline">\((x-L,x]\)</span> 中固定一个起点，当 <span class="math inline">\(x\)</span> 所在段权值一定时，这一段越长越好。</p>
<p>所以每次只要 <span class="math inline">\(\mathcal O(L)\)</span> 处理即可，复杂度 <span class="math inline">\(\mathcal O((n+q)L)\)</span>。其实觉得过不了的。</p>
<h1 id="日-26">30日</h1>
<h2 id="cf1175e-minimal-segment-cover">CF1175E Minimal Segment Cover</h2>
<p><a href="https://www.luogu.com.cn/problem/CF1175E">题目</a></p>
<p>倍增。</p>
<p>设 <span class="math inline">\(f_{i,j}\)</span> 表示从 <span class="math inline">\(i\)</span> 点走 <span class="math inline">\(j\)</span> 条线段能够到达最远的点，每次询问 <span class="math inline">\(\mathcal O(\log n)\)</span> 跳到最远的不超过区间右端，再跳一条线段就是答案。</p>
]]></content>
      <categories>
        <category>刷题记录</category>
      </categories>
  </entry>
</search>
