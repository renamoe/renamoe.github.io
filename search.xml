<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>总结 CDQ分治</title>
    <url>/2020/01/17/2020-01-17-%E6%80%BB%E7%BB%93-CDQ%E5%88%86%E6%B2%BB/</url>
    <content><![CDATA[<p>咕了几个月的玩意。。。</p>
<p>先贴几个板子，总结后面补</p>
<a id="more"></a>
<hr />
<p>P1908 逆序对</p>
<p><a href="https://www.luogu.com.cn/problem/P3374">P2274 树状数组1</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    ll id, val, type;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Node &amp;x) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id == x.id ? type &lt; x.type : id &lt; x.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    CDQ(l, mid), CDQ(mid+<span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">int</span> x = l, y = mid+<span class="number">1</span>, k = l;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= mid &amp;&amp; y &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[x] &lt; a[y]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[x].type == <span class="number">1</span>)</span><br><span class="line">                sum += a[x].val;</span><br><span class="line">            t[k++] = a[x++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[y].type == <span class="number">2</span>)</span><br><span class="line">                ans[a[y].val] -= sum;</span><br><span class="line">            <span class="keyword">if</span> (a[y].type == <span class="number">3</span>)</span><br><span class="line">                ans[a[y].val] += sum;</span><br><span class="line">            t[k++] = a[y++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= mid)</span><br><span class="line">        t[k++] = a[x++];</span><br><span class="line">    <span class="keyword">while</span> (y &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[y].type == <span class="number">2</span>)</span><br><span class="line">            ans[a[y].val] -= sum;</span><br><span class="line">        <span class="keyword">if</span> (a[y].type == <span class="number">3</span>)</span><br><span class="line">            ans[a[y].val] += sum;</span><br><span class="line">        t[k++] = a[y++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">        a[i] = t[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, t; i &lt;= n; i++)</span><br><span class="line">    t = read(), a[++cnta] = (Node)&#123;i, t, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    ll c = read(), x = read(), y = read();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">1</span>)</span><br><span class="line">        a[++cnta] = (Node)&#123;x, y, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        a[++cnta] = (Node)&#123;x<span class="number">-1</span>, ++cntq, <span class="number">2</span>&#125;;</span><br><span class="line">        a[++cnta] = (Node)&#123;y, cntq, <span class="number">3</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.luogu.com.cn/problem/P3810">P3810 陌上花开</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c, cnt, ans;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> ==(<span class="keyword">const</span> Node &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a == t.a &amp;&amp; b == t.b &amp;&amp; c == t.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, bn, maxk;</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line">Node a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp1d</span><span class="params">(Node x, Node y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x.a == y.a)</span><br><span class="line">        <span class="keyword">return</span> x.b == y.b ? x.c &lt; y.c : x.b &lt; y.b;</span><br><span class="line">    <span class="keyword">return</span> x.a &lt; y.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp2d</span><span class="params">(Node x, Node y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.b == y.b ? x.c &lt; y.c : x.b &lt; y.b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bit_tree</span> &#123;</span>...&#125; tr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    CDQ(l, mid), CDQ(mid+<span class="number">1</span>, r);</span><br><span class="line">    sort(a+l, a+mid+<span class="number">1</span>, cmp2d);</span><br><span class="line">    sort(a+mid+<span class="number">1</span>, a+r+<span class="number">1</span>, cmp2d);</span><br><span class="line">    <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>, k = l;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; a[i].b &lt;= a[j].b)</span><br><span class="line">            tr.add(a[i].c, a[i].cnt), i++;</span><br><span class="line">        a[j].ans += tr.query(a[j].c), j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = l; j &lt; i; ++j)</span><br><span class="line">        tr.add(a[j].c, -a[j].cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(bn), read(maxk);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= bn; ++i)</span><br><span class="line">        read(b[i].a), read(b[i].b), read(b[i].c);</span><br><span class="line">    sort(b+<span class="number">1</span>, b+bn+<span class="number">1</span>, cmp1d);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= bn; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[i] == b[i<span class="number">-1</span>])</span><br><span class="line">            a[n].cnt++;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            a[++n] = b[i], a[n].cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    CDQ(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cnt[a[i].ans + a[i].cnt - <span class="number">1</span>] += a[i].cnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bn; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title>总结 点分治</title>
    <url>/2020/01/17/2020-01-17-%E6%80%BB%E7%BB%93-%E7%82%B9%E5%88%86%E6%B2%BB/</url>
    <content><![CDATA[<p>用于某些统计树上路径的题</p>
<p>每次找树的重心为根（<span class="math inline">\(O(n)\)</span>）</p>
<a id="more"></a>
<p>处理每个点到根的距离等信息（<span class="math inline">\(O(n)\)</span>）</p>
<p>统计答案（<span class="math inline">\(O(n)\)</span>或<span class="math inline">\(O(nlogn)\)</span>等）</p>
<p>划分根的各个子树，分治下去（总共分治<span class="math inline">\(logn\)</span>层）</p>
<hr />
<h2 id="模板部分">模板部分</h2>
<p>getroot() 找树的重心</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span>, maxs[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt) </span><br><span class="line">        <span class="keyword">if</span> (!vis[e[i].to] &amp;&amp; e[i].to != fa) &#123;</span><br><span class="line">            v = e[i].to;</span><br><span class="line">            getroot(v, u, size);</span><br><span class="line">            sz[u] += sz[v];</span><br><span class="line">            maxs[u] = max(maxs[u], sz[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    maxs[u] = max(maxs[u], size - sz[u]);</span><br><span class="line">    <span class="keyword">if</span> (!root || maxs[u] &lt; maxs[root])</span><br><span class="line">        root = u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getdis() 处理各点的距离</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 带染色</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getdis</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> dis, <span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">    t[++tot] = u;</span><br><span class="line">    d[u] = dis, col[u] = color;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != fa &amp;&amp; !vis[e[i].to])</span><br><span class="line">            v = e[i].to, getdis(v, u, d[u] + e[i].val, color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>统计答案时会重复，同一子树中的两个点是不能成点对的</p>
<p>有两种方式，将各个子树染色，或是通过容斥原理减去子树的一部分答案</p>
<p>solve() 分治</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    ans += calc(u, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt) </span><br><span class="line">        <span class="keyword">if</span> (!vis[e[i].to]) &#123;</span><br><span class="line">            v = e[i].to, root = <span class="number">0</span>;</span><br><span class="line">            ans -= calc(v, e[i].val);<span class="comment">// 染色的话不加这句话</span></span><br><span class="line">            getroot(v, <span class="number">0</span>, sz[v]);</span><br><span class="line">            solve(root);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="统计答案">统计答案</h2>
<p>calc() 每道题是不同的</p>
<p>以<a href="https://www.luogu.com.cn/problem/P3806">模板题</a>为例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一棵有n个点的树，询问树上距离为k的点对是否存在</span><br></pre></td></tr></table></figure>
<p>将每个点的深度处理出来后，按深度排序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tot = <span class="number">0</span>;</span><br><span class="line">t[++tot] = u;</span><br><span class="line">d[u] = dis, col[u] = u;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt)</span><br><span class="line">    <span class="keyword">if</span> (!vis[e[i].to])</span><br><span class="line">        v = e[i].to, getdis(v, u, d[u]+e[i].val, v);</span><br><span class="line">sort(t+<span class="number">1</span>, t+tot+<span class="number">1</span>, cmp);</span><br></pre></td></tr></table></figure>
<p>此时又有两种方法：</p>
<ul>
<li>双指针扫</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r = tot;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d[t[l]] + d[t[r]] &gt; k)</span><br><span class="line">        r--;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (d[t[l]] + d[t[r]] &lt; k)</span><br><span class="line">        l++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (col[t[l]] == col[t[r]])</span><br><span class="line">        d[t[r]] == d[t[r<span class="number">-1</span>]] ? r-- : l++;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ans = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>二分查找</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r;</span><br><span class="line"><span class="keyword">while</span> (l &lt; tot &amp;&amp; d[t[l]] + d[t[tot]] &lt; k)</span><br><span class="line">    l++;</span><br><span class="line"><span class="keyword">while</span> (l &lt; tot) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d[t[l]] &gt; k - d[t[l]])</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    d[<span class="number">0</span>] = k - d[t[l]];</span><br><span class="line">    r = lower_bound(t+<span class="number">1</span>, t+tot+<span class="number">1</span>, <span class="number">0</span>, cmp) - t;</span><br><span class="line">    <span class="keyword">while</span> (r &lt;= tot &amp;&amp; d[t[l]] + d[t[r]] == k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (col[t[l]] != col[t[r]])</span><br><span class="line">            ans = <span class="literal">true</span>;</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    l++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度上限在于排序（<span class="math inline">\(O(nlogn)\)</span>）</p>
<p>如果可以的话，可以桶排，降到（<span class="math inline">\(O(n)\)</span>）</p>
<hr />
<h2 id="一些题目">一些题目</h2>
<p><a href="https://www.luogu.com.cn/problem/P4178">P4178</a>树上长度小于等于k的路径</p>
<p><a href="https://www.luogu.com.cn/problem/P4149">P4149</a>长度为k的路径最小边数</p>
<p>我菜，好多还没做过。。。</p>
]]></content>
      <categories>
        <category>总结</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title>总结 网络流</title>
    <url>/2020/01/17/2020-01-17-%E6%80%BB%E7%BB%93-%E7%BD%91%E7%BB%9C%E6%B5%81/</url>
    <content><![CDATA[<p>网络最大流以及最小费用最大流板子，以及一点网络流的总结。</p>
<a id="more"></a>
<p>非常好的博客：<a href="https://www.xht37.com/%E4%BA%8C%E5%88%86%E5%9B%BE%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%B5%81-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">xht37's blog</a>。</p>
<h2 id="dinic-算法">Dinic 算法</h2>
<h3 id="网络最大流">网络最大流</h3>
<p>记得加当前弧优化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, cnt = <span class="number">1</span>, s, t;</span><br><span class="line"><span class="keyword">int</span> head[N], deep[N], cur[N];</span><br><span class="line">Edge e[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">bool</span> inq[N];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cur[i] = head[i];</span><br><span class="line">    <span class="built_in">memset</span>(deep, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> deep);</span><br><span class="line">    q.push(s), inq[s] = <span class="literal">true</span>;</span><br><span class="line">    deep[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        inq[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (deep[v] &gt; deep[u] + <span class="number">1</span> &amp;&amp; e[i].flow) &#123;</span><br><span class="line">                deep[v] = deep[u] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (!inq[v])</span><br><span class="line">                    q.push(v), inq[v] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deep[t] != INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> flow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == t || !flow)</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="keyword">int</span> rlow, v, re = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">        v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (deep[v] == deep[u] + <span class="number">1</span> &amp;&amp; e[i].val &amp;&amp; (rlow = dfs(v, min(flow, e[i].val)))) &#123;</span><br><span class="line">            e[i].val -= rlow, e[i^<span class="number">1</span>].val += rlow;</span><br><span class="line">            flow -= rlow, re += rlow;</span><br><span class="line">            <span class="keyword">if</span> (!flow) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!re) deep[u] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxflow = <span class="number">0</span>, now;</span><br><span class="line">    <span class="keyword">while</span> (bfs()) &#123;</span><br><span class="line">        <span class="keyword">while</span> ((now = dfs(s, INF))</span><br><span class="line">        	maxflow += now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="费用流">费用流</h3>
<p>需要注意加边时反向边费用取负。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">int</span> head[N], cur[N], nxt[M], to[M], flow[M], cost[N];</span><br><span class="line">    Graph() &#123; cnt = <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        ++cnt, nxt[cnt] = head[u], to[cnt] = v, flow[cnt] = w, cost[cnt] = c, head[u] = cnt;</span><br><span class="line">        ++cnt, nxt[cnt] = head[v], to[cnt] = u, flow[cnt] = <span class="number">0</span>, cost[cnt] = -c, head[v] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; G;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, S, T, maxflow, mincost;</span><br><span class="line"><span class="keyword">int</span> dis[N], flow[N];</span><br><span class="line"><span class="keyword">bool</span> inq[N], vis[N];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dis[i] = INF, inq[i] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) G.cur[i] = G.head[i];</span><br><span class="line">    dis[S] = <span class="number">0</span>;</span><br><span class="line">    q.push(S), inq[S] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        inq[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = G.head[u]; i; i = G.nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G.to[i];</span><br><span class="line">            <span class="keyword">if</span> (G.flow[i] &gt; <span class="number">0</span> &amp;&amp; dis[v] &gt; dis[u] + G.cost[i]) &#123;</span><br><span class="line">                dis[v] = dis[u] + G.cost[i];</span><br><span class="line">                <span class="keyword">if</span> (!inq[v]) q.push(v), inq[v] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[T] &lt; INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == T || !limit) <span class="keyword">return</span> limit;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> rest = limit;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = G.cur[u]; i; i = G.nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = G.to[i];</span><br><span class="line">        <span class="keyword">if</span> (vis[v] || dis[v] != dis[u] + G.cost[i] || !G.flow[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> rlow = dfs(v, min(G.flow[i], rest));</span><br><span class="line">        <span class="keyword">if</span> (!rlow) dis[v] = <span class="number">-1</span>;</span><br><span class="line">        mincost += rlow * G.cost[i];</span><br><span class="line">        G.flow[i] -= rlow, G.flow[i ^ <span class="number">1</span>] += rlow;</span><br><span class="line">        rest -= rlow;</span><br><span class="line">        <span class="keyword">if</span> (!rest) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[u] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> limit - rest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rlow;</span><br><span class="line">    <span class="keyword">while</span> (bfs()) &#123;</span><br><span class="line">        <span class="keyword">while</span> ((now = dfs(S, INF))) maxflow += now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>附 <a href="https://www.luogu.com.cn/paste/i5jvgql3">EK 费用流（弃）</a>。</p>
<h2 id="上下界网络流">上下界网络流</h2>
<h3 id="无源汇上下界可行流">无源汇上下界可行流</h3>
<blockquote>
<p>每条边 <span class="math inline">\(i\)</span> 流量限制范围 <span class="math inline">\(l_i,r_i\)</span>。</p>
</blockquote>
<p>先满足所有 <span class="math inline">\(l_i\)</span>，这样会导致点的出入流量不守恒，所以建出超级源汇点 <span class="math inline">\(S,T\)</span>。</p>
<p>设 <span class="math inline">\(d_u=\sum in_u-\sum out_u\)</span>，若 <span class="math inline">\(d_u&gt;0\)</span> 则 <span class="math inline">\(S\)</span> 向 <span class="math inline">\(u\)</span> 连边，若 <span class="math inline">\(d_u&lt;0\)</span> 则 <span class="math inline">\(u\)</span> 向 <span class="math inline">\(T\)</span> 连边。</p>
<p>然后每条边的流量设为 <span class="math inline">\(r_i-l_i\)</span>，就去掉了下界。</p>
<p>跑最大流，设 <span class="math inline">\(s=\sum out_S=\sum in_T\)</span>，若最大流等于 <span class="math inline">\(s\)</span> 则存在可行解。</p>
<p>若有解，每条边的流量 + 下界即为一组可行解。</p>
<h3 id="有源汇上下界可行流">有源汇上下界可行流</h3>
<p>从 <span class="math inline">\(T\)</span> 到 <span class="math inline">\(S\)</span> 连一条 <span class="math inline">\([0,+\infty)\)</span> 的边，转化为无源汇上下界可行流。</p>
<h3 id="有源汇上下界最大流">有源汇上下界最大流</h3>
<p>先从 <span class="math inline">\(T\)</span> 到 <span class="math inline">\(S\)</span> 连一条 <span class="math inline">\([0,+\infty)\)</span> 的边，从虚拟源点到虚拟汇点跑最大流判断是否有解。</p>
<p>若有解的话，断掉 <span class="math inline">\(T\)</span> 到 <span class="math inline">\(S\)</span> 的边，在残量网络上从 <span class="math inline">\(S\)</span> 到 <span class="math inline">\(T\)</span> 跑最大流，加上上一次的最大流即为答案。</p>
<p><del>感性理解</del>，不会证。</p>
]]></content>
      <categories>
        <category>总结</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>网络最大流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 AC自动机</title>
    <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-AC%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<p>匹配多个模式串</p>
<p>本质上是trie tree + kmp</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AC_automaton</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">int</span> tr[N][<span class="number">26</span>], fail[N], end[N], tot[M];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(tr, <span class="number">0</span>, <span class="keyword">sizeof</span> tr);</span><br><span class="line">        <span class="built_in">memset</span>(fail, <span class="number">0</span>, <span class="keyword">sizeof</span> fail);</span><br><span class="line">        <span class="built_in">memset</span>(end, <span class="number">0</span>, <span class="keyword">sizeof</span> end);</span><br><span class="line">        <span class="built_in">memset</span>(tot, <span class="number">0</span>, <span class="keyword">sizeof</span> tot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!tr[p][s[i]-<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">                tr[p][s[i]-<span class="string">&#x27;a&#x27;</span>] = ++cnt;</span><br><span class="line">            p = tr[p][s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        end[p] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">            <span class="keyword">if</span> (tr[<span class="number">0</span>][i])</span><br><span class="line">                q.push(tr[<span class="number">0</span>][i]);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tr[x][i])</span><br><span class="line">                    fail[tr[x][i]] = tr[fail[x]][i], q.push(tr[x][i]);</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    tr[x][i] = tr[fail[x]][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            p = tr[p][s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = p; j; j = fail[j])</span><br><span class="line">                tot[end[j]]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>先这样，有时间再补充</p>
]]></content>
      <categories>
        <category>总结</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 Dijkstra / SPFA / Floyd</title>
    <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-Dijkstra--SPFA--Floyd/</url>
    <content><![CDATA[<p>3 种最短路算法。</p>
<a id="more"></a>
<h2 id="dijkstra堆优化">Dijkstra（堆优化）</h2>
<ul>
<li><p>取没有访问过的堆顶</p></li>
<li><p>标记为访问过</p></li>
<li><p>松弛各边</p></li>
<li><p>将未访问过的邻点塞进堆里</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> d, p;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Node &amp;x) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x.d &lt; d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;Node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        d[i] = INF;</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    q.push((Node)&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        Node x = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span> (v[x.p])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        v[x.p] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x.p]; i; i = e[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (d[y] &gt; d[x.p] + e[i].w) &#123;</span><br><span class="line">                d[y] = d[x.p] + e[i].w;</span><br><span class="line">                <span class="keyword">if</span> (!v[y])</span><br><span class="line">                    q.push((Node)&#123;d[y], y&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="spfa">SPFA</h2>
<ul>
<li>取队头</li>
<li>标记为出队</li>
<li>松弛各边</li>
<li>将队外的邻点怼进队里，标记为入队</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        d[i] = INF;</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    q.push(s);</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].next) &#123;</span><br><span class="line">            v = e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (d[v] &gt; d[u] + e[i].val) &#123;</span><br><span class="line">                d[v] = d[u] + e[i].val;</span><br><span class="line">                <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                    vis[v] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="floyd">Floyd</h2>
<p><span class="math inline">\(k,i,j\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 LCA</title>
    <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-LCA/</url>
    <content><![CDATA[<p>倍增法、重链剖分、ST 表求树上公共祖先。</p>
<a id="more"></a>
<h2 id="倍增法">倍增法</h2>
<p>时间复杂度：预处理 <span class="math inline">\(\mathcal O(n\log n)\)</span>，单次查询 <span class="math inline">\(\mathcal O(\log n)\)</span>；</p>
<p>空间复杂度：<span class="math inline">\(\mathcal O(n\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> deep[N], fa[N][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    deep[x] = deep[pre] + <span class="number">1</span>;</span><br><span class="line">    fa[u][<span class="number">0</span>] = pre;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">19</span>; ++i)</span><br><span class="line">        fa[u][i] = fa[fa[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = G.head[u]; i; i = G.nxt[i]) &#123;</span><br><span class="line">    	<span class="keyword">int</span> v = G.to[i];</span><br><span class="line">        <span class="keyword">if</span> (v == pre) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deep[a] &lt; deep[b]) swap(a, b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> (deep[fa[a][i]] &gt;= deep[b])</span><br><span class="line">            a = fa[a][i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> (fa[a][i] != fa[b][i])</span><br><span class="line">            a = fa[a][i], b = fa[b][i];</span><br><span class="line">    <span class="keyword">return</span> a == b ? a : fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重链剖分">重链剖分</h2>
<p>时间复杂度：预处理 <span class="math inline">\(\mathcal O(n)\)</span>，单次查询 <span class="math inline">\(\mathcal O(\log n)\)</span>；</p>
<p>空间复杂度：<span class="math inline">\(\mathcal O(n)\)</span>。</p>
<p>很多时候比倍增快一点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> deep[N], fa[N], top[N], size[N], son[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    fa[u] = pre;</span><br><span class="line">    deep[u] = deep[pre] + <span class="number">1</span>;</span><br><span class="line">    size[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = G.head[u]; i; i = G.nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = G.to[i];</span><br><span class="line">        <span class="keyword">if</span> (v == pre) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(v, u);</span><br><span class="line">        size[u] += size[v];</span><br><span class="line">        <span class="keyword">if</span> (!son[u] || size[v] &gt; size[son[u]]) son[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tp)</span> </span>&#123;</span><br><span class="line">    top[u] = tp;</span><br><span class="line">    <span class="keyword">if</span> (!son[u]) <span class="keyword">return</span>;</span><br><span class="line">    dfs2(son[u], tp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = G.head[u]; i; i = G.nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = G.to[i];</span><br><span class="line">        <span class="keyword">if</span> (v == fa[u] || v == son[u]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs2(v, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deep[top[x]] &lt; deep[top[y]]) swap(x, y);</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deep[x] &lt; deep[y] ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="st-表">ST 表</h2>
<p>时间复杂度：预处理 <span class="math inline">\(\mathcal O(n\log n)\)</span>，单次查询 <span class="math inline">\(\mathcal O(1)\)</span>；</p>
<p>空间复杂度：<span class="math inline">\(\mathcal O(n\log n)\)</span>。</p>
<p>注意 <span class="math inline">\(tot\)</span> 为 <span class="math inline">\(n\)</span> 的两倍。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="keyword">int</span> st[N * <span class="number">4</span>][<span class="number">20</span>], <span class="built_in">log</span>[N * <span class="number">2</span>], deep[N], aa[N * <span class="number">2</span>], fir[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    deep[u] = deep[fa] + <span class="number">1</span>;</span><br><span class="line">    aa[++tot] = u;</span><br><span class="line">    fir[u] = tot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = G.head[u]; i; i = G.nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = G.to[i];</span><br><span class="line">        <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v, u);</span><br><span class="line">        aa[++tot] = u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">log</span>[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) <span class="built_in">log</span>[i] = <span class="built_in">log</span>[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) st[i][<span class="number">0</span>] = aa[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">19</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= tot; ++u) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = st[u][i - <span class="number">1</span>], y = st[u + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))][i - <span class="number">1</span>];</span><br><span class="line">            st[u][i] = deep[x] &lt; deep[y] ? x : y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = fir[x], r = fir[y];</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) swap(l, r);</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="built_in">log</span>[r - l + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> t1 = st[l][lo], t2 = st[r - (<span class="number">1</span> &lt;&lt; lo) + <span class="number">1</span>][lo];</span><br><span class="line">    <span class="keyword">return</span> deep[t1] &lt; deep[t2] ? t1 : t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 Link-Cut Tree</title>
    <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-Link-Cut-Tree/</url>
    <content><![CDATA[<p>发现还是不要包装每个节点的好，好看还常数小</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Link_Cut_Tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fa[N], ch[N][<span class="number">2</span>], sum[N], val[N], rev[N];</span><br><span class="line">    <span class="keyword">int</span> stk[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">which</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>] == x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">not_root</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ch[fa[x]][<span class="number">0</span>] == x || ch[fa[x]][<span class="number">1</span>] == x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        sum[x] = sum[ch[x][<span class="number">0</span>]] ^ sum[ch[x][<span class="number">1</span>]] ^ val[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        swap(ch[x][<span class="number">0</span>], ch[x][<span class="number">1</span>]), rev[x] ^= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rev[x]) &#123;</span><br><span class="line">            rev[x] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (ch[x][<span class="number">0</span>])</span><br><span class="line">                reverse(ch[x][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span> (ch[x][<span class="number">1</span>])</span><br><span class="line">                reverse(ch[x][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f = fa[x], gf = fa[f], w = which(x), y = ch[x][w^<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (not_root(f))</span><br><span class="line">            ch[gf][which(f)] = x;</span><br><span class="line">        ch[x][w^<span class="number">1</span>] = f, ch[f][w] = y;</span><br><span class="line">        <span class="keyword">if</span> (y)</span><br><span class="line">            fa[y] = f;</span><br><span class="line">        fa[f] = x, fa[x] = gf;</span><br><span class="line">        push_up(f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>, f = x;</span><br><span class="line">        stk[++top] = x;</span><br><span class="line">        <span class="keyword">while</span> (not_root(f))</span><br><span class="line">            stk[++top] = f = fa[f];</span><br><span class="line">        <span class="keyword">while</span> (top)</span><br><span class="line">            push_down(stk[top--]);</span><br><span class="line">        <span class="keyword">while</span> (not_root(x)) &#123;</span><br><span class="line">            f = fa[x];</span><br><span class="line">            <span class="keyword">if</span> (not_root(f))</span><br><span class="line">                which(x) == which(f) ? rotate(f) : rotate(x);</span><br><span class="line">            rotate(x);</span><br><span class="line">        &#125;</span><br><span class="line">        push_up(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; x; y = x, x = fa[x])</span><br><span class="line">            splay(x), ch[x][<span class="number">1</span>] = y, push_up(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">make_root</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        access(x), splay(x), reverse(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        access(x), splay(x);</span><br><span class="line">        <span class="keyword">while</span> (ch[x][<span class="number">0</span>])</span><br><span class="line">            push_down(x), x = ch[x][<span class="number">0</span>];</span><br><span class="line">        splay(x);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        make_root(x), access(y), splay(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        make_root(x);</span><br><span class="line">        <span class="keyword">if</span> (find_root(y) != x)</span><br><span class="line">            fa[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        make_root(x);</span><br><span class="line">        <span class="keyword">if</span> (find_root(y) == x &amp;&amp; fa[y] == x &amp;&amp; !ch[y][<span class="number">0</span>])</span><br><span class="line">            fa[y] = ch[x][<span class="number">1</span>] = <span class="number">0</span>, push_up(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; lct;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
        <category>数据结构</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 Tarjan</title>
    <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-Tarjan/</url>
    <content><![CDATA[<p>Tarjan是个好东西</p>
<p>求强连通分量，可以用来缩点等等</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[N], dfn[N], low[N], col[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++tot;</span><br><span class="line">    <span class="built_in">stack</span>[++top] = u;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">        v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[v])</span><br><span class="line">            Tarjan(v), low[u] = min(low[u], low[v]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vis[v])</span><br><span class="line">            low[u] = min(low[u], low[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfn[u] == low[u]) &#123;</span><br><span class="line">        scc++;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            v = <span class="built_in">stack</span>[top--];</span><br><span class="line">            vis[v] = <span class="literal">false</span>;</span><br><span class="line">            col[v] = scc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (v != u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="缩点"><a href="https://www.luogu.org/record/20159280">缩点</a></h3>
<p>搞出强连通分量后，重新建图，该干啥干啥</p>
<p><a href="https://www.luogu.org/problem/P2515">P2515</a></p>
<p><a href="https://www.luogu.org/problem/T103252?contestId=22368">T103252</a></p>
<p><a href="https://www.luogu.com.cn/problem/P2746">P2746</a></p>
<h2 id="割点">割点</h2>
<p>和求强连通分量不太一样</p>
<p><code>low[x]</code>表示 <span class="math inline">\(dfs\)</span> 下去最早遇到的割点</p>
<p>当 <span class="math inline">\(v\)</span> 已经访问过时，用 <span class="math inline">\(dfn[v]\)</span> 更新 <span class="math inline">\(low[u]\)</span> （为什么？画两个连环就知道了）</p>
<p>当 <span class="math inline">\(u\)</span> 为根时只要统计子树个数即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++tot;</span><br><span class="line">    <span class="keyword">int</span> v, ch = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">        v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">            Tarjan(v, rt), low[u] = min(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span> (u != rt &amp;&amp; low[v] &gt;= dfn[u])<span class="comment">// 环在u的子树里，u为割点</span></span><br><span class="line">                cut[u] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (u == rt)</span><br><span class="line">                ch++;</span><br><span class="line">        &#125;</span><br><span class="line">        low[u] = min(low[u], dfn[v]);<span class="comment">// 注意这里	</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u == rt &amp;&amp; ch &gt;= <span class="number">2</span>)</span><br><span class="line">        cut[u] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缩它</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">if</span> (!dfn[i])</span><br><span class="line">        Tarjan(i, i);<span class="comment">// i = rt</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 kmp</title>
    <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-kmp/</url>
    <content><![CDATA[<p>利用 nxt 数组使字符串匹配降到 <span class="math inline">\(O(n)\)</span>。</p>
<a id="more"></a>
<h2 id="next">next</h2>
<p>i从2开始，j从0开始</p>
<p>i和j+1匹配不上，j跳nxt</p>
<p>匹配就<code>j++</code></p>
<p><code>nxt[i] = j</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= blen; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; b[j+<span class="number">1</span>] != b[i])</span><br><span class="line">        j = nxt[j];</span><br><span class="line">    <span class="keyword">if</span> (b[j+<span class="number">1</span>] == b[i])</span><br><span class="line">        ++j;</span><br><span class="line">    nxt[i] = j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匹配">匹配</h2>
<p>i从a的1-len，j从0开始</p>
<p><code>a[i]</code>和<code>b[j+1]</code>匹配不上就j跳nxt</p>
<p>否则<code>j++</code></p>
<p>j到blen则匹配完一次，跳nxt</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= alen; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; b[j+<span class="number">1</span>] != a[i])</span><br><span class="line">        j = nxt[j];</span><br><span class="line">    <span class="keyword">if</span> (b[j+<span class="number">1</span>] == a[i])</span><br><span class="line">        ++j;</span><br><span class="line">    <span class="keyword">if</span> (j == blen) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i - blen + <span class="number">1</span>);</span><br><span class="line">        ans++;</span><br><span class="line">        j = nxt[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<p>以上为远古文章。</p>
<h2 id="扩展-kmp">扩展 kmp</h2>
<p><a href="https://www.luogu.com.cn/problem/P5410">板子题</a></p>
<blockquote>
<p>给出长为 <span class="math inline">\(n\)</span> 的字符串 <span class="math inline">\(s\)</span>。</p>
<p><span class="math inline">\(\mathcal O(n)\)</span> 处理 <span class="math inline">\(z\)</span> 函数：<span class="math inline">\(z_i=|\operatorname{LCP}(s,s[i:])|\)</span>。</p>
</blockquote>
<p>记录 <span class="math inline">\(r\)</span> 最大的一对 <span class="math inline">\(l,r\)</span> 满足 <span class="math inline">\(r=l+z_l-1\)</span>。</p>
<p>设从前到后处理到 <span class="math inline">\(i\)</span>，当 <span class="math inline">\(i\le r\)</span> 时，初始化 <span class="math inline">\(z_i=\min\{z_{i-l+1},-i+1\}\)</span>，否则为 <span class="math inline">\(0\)</span>。</p>
<p>然后暴力匹配 <span class="math inline">\(s[i+z_i]\)</span> 和 <span class="math inline">\(z[z_i+1]\)</span>。</p>
<p>每个字符最多被暴力匹配 <span class="math inline">\(1\)</span> 次，复杂度 <span class="math inline">\(\mathcal O(n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">z[<span class="number">1</span>] = n;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= r) z[i] = min(z[i - l + <span class="number">1</span>], r - i + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (i + z[i] &lt;= n &amp;&amp; s[z[i] + <span class="number">1</span>] == s[i + z[i]]) ++z[i];</span><br><span class="line">    <span class="keyword">if</span> (i + z[i] - <span class="number">1</span> &gt; r) l = i, r = i + z[i] - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>kmp匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 左偏树</title>
    <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-%E5%B7%A6%E5%81%8F%E6%A0%91/</url>
    <content><![CDATA[<p>左偏树本质是堆，在满足父亲比两个儿子的<span class="math inline">\(val\)</span>都大（小）的时候保证</p>
<p><span class="math display">\[dist[ls] &gt;= dist[rs]\]</span></p>
<p><span class="math display">\[dist[x] = dist[rs] + 1\]</span></p>
<a id="more"></a>
<p>于是就支持<span class="math inline">\(merge\)</span>快速合并</p>
<p><span class="math inline">\(pop\)</span>就乱搞，合并两子树就行</p>
<p>可以用并查集维护所在堆</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ch[N][<span class="number">2</span>], dist[N], fa[N], val[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y)</span><br><span class="line">        <span class="keyword">return</span> x | y;</span><br><span class="line">    <span class="keyword">if</span> (val[x] &gt; val[y])</span><br><span class="line">        swap(x, y);</span><br><span class="line">    ch[x][<span class="number">1</span>] = merge(ch[x][<span class="number">1</span>], y);</span><br><span class="line">    <span class="keyword">if</span> (dist[ch[x][<span class="number">0</span>]] &lt; dist[ch[x][<span class="number">1</span>]])</span><br><span class="line">        swap(ch[x][<span class="number">0</span>], ch[x][<span class="number">1</span>]);</span><br><span class="line">    dist[x] = dist[ch[x][<span class="number">1</span>]] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    val[x] = <span class="number">-1</span>, fa[ch[x][<span class="number">0</span>]] = fa[ch[x][<span class="number">1</span>]] = fa[x] = merge(ch[x][<span class="number">0</span>], ch[x][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    fa[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// merge</span></span><br><span class="line"><span class="keyword">int</span> fx = find(x), fy = find(y);</span><br><span class="line">fa[fx] = fa[fy] = merge(fx, fy);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左偏树</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 平衡树</title>
    <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-%E5%B9%B3%E8%A1%A1%E6%A0%91/</url>
    <content><![CDATA[<p>包括 Splay、WBLT、替罪羊树.。</p>
<a id="more"></a>
<h2 id="splay">Splay</h2>
<blockquote>
<p>update 2020.11.23</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Splay</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> tot, root;</span><br><span class="line">    <span class="keyword">int</span> fa[N], ch[N][<span class="number">2</span>], size[N], cnt[N], val[N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        size[x] = size[ch[x][<span class="number">0</span>]] + size[ch[x][<span class="number">1</span>]] + cnt[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">which</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x == ch[fa[x]][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        fa[x] = ch[x][<span class="number">0</span>] = ch[x][<span class="number">1</span>] = size[x] = val[x] = cnt[x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">new_node</span><span class="params">(<span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> f = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        tot++;</span><br><span class="line">        val[tot] = v, fa[tot] = f;</span><br><span class="line">        size[tot] = cnt[tot] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f = fa[x], gf = fa[f], w = which(x), y = ch[x][w^<span class="number">1</span>];</span><br><span class="line">        ch[gf][which(f)] = x, ch[x][w^<span class="number">1</span>] = f, ch[f][w] = y;</span><br><span class="line">        fa[x] = gf, fa[f] = x, fa[y] = f;</span><br><span class="line">        clear(<span class="number">0</span>), push_up(f), push_up(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> goal = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (fa[x] != goal) &#123;</span><br><span class="line">            <span class="keyword">int</span> f = fa[x];</span><br><span class="line">            <span class="keyword">if</span> (fa[f] != goal)</span><br><span class="line">                which(f) == which(x) ? rotate(f) : rotate(x);</span><br><span class="line">            rotate(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!goal) root = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> root = new_node(k), <span class="keyword">void</span>();</span><br><span class="line">        <span class="keyword">int</span> x = find(k);</span><br><span class="line">        <span class="keyword">if</span> (val[x] == k) cnt[x]++, push_up(x);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ch[x][k &gt; val[x]] = new_node(k, x);</span><br><span class="line">            x = ch[x][k &gt; val[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        splay(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = find(k);</span><br><span class="line">        splay(x);</span><br><span class="line">        <span class="keyword">if</span> (cnt[x] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            cnt[x]--, push_up(x);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ch[x][<span class="number">0</span>] || !ch[x][<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = ch[x][<span class="number">0</span>] | ch[x][<span class="number">1</span>];</span><br><span class="line">            clear(x), fa[y] = <span class="number">0</span>, root = y;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = pre(val[x]), r = ch[x][<span class="number">1</span>];</span><br><span class="line">        splay(l, x);</span><br><span class="line">        clear(x), ch[l][<span class="number">1</span>] = r, fa[r] = l;</span><br><span class="line">        fa[l] = <span class="number">0</span>, root = l, push_up(l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = root, f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &amp;&amp; val[x] != k)</span><br><span class="line">            f = x, x = ch[x][k &gt; val[x]];</span><br><span class="line">        <span class="keyword">return</span> x ? x : f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = find(k), rk = rank_id(x);</span><br><span class="line">        <span class="keyword">return</span> rk + (k &gt; val[x]) * cnt[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rank_id</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        splay(x);</span><br><span class="line">        <span class="keyword">return</span> size[ch[x][<span class="number">0</span>]] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = root;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k &lt;= size[ch[x][<span class="number">0</span>]]) x = ch[x][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; size[ch[x][<span class="number">0</span>]] + cnt[x]) &#123;</span><br><span class="line">                k -= size[ch[x][<span class="number">0</span>]] + cnt[x];</span><br><span class="line">                x = ch[x][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> kth(rank(k) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">nxt</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> kth(rank(k + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; tr;</span><br></pre></td></tr></table></figure>
<h2 id="替罪羊树">替罪羊树</h2>
<blockquote>
<p>update on 2020.1.29</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Alpha = <span class="number">0.75</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SGT</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> tot, root, cnt_tmp;</span><br><span class="line">    <span class="keyword">int</span> val[N], cnt[N], sz[N], rsz[N], ls[N], rs[N], tmp[N];</span><br><span class="line">    <span class="comment">// sz：节点数量</span></span><br><span class="line">    <span class="comment">// rsz：真实数量</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; trash;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">new_node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (trash.empty()) <span class="keyword">return</span> ++tot;</span><br><span class="line">        <span class="keyword">int</span> x = trash.front();</span><br><span class="line">        trash.pop();</span><br><span class="line">        cnt[x] = val[x] = ls[x] = rs[x] = sz[x] = rsz[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        sz[x] = sz[ls[x]] + sz[rs[x]] + <span class="number">1</span>;</span><br><span class="line">        rsz[x] = rsz[ls[x]] + rsz[rs[x]] + cnt[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pia</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!x) <span class="keyword">return</span>;</span><br><span class="line">        pia(ls[x]);</span><br><span class="line">        <span class="keyword">if</span> (cnt[x]) tmp[++cnt_tmp] = x;</span><br><span class="line">        <span class="keyword">else</span> trash.push(x);</span><br><span class="line">        pia(rs[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rebuild</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, x = tmp[mid];</span><br><span class="line">        ls[x] = rebuild(l, mid - <span class="number">1</span>), rs[x] = rebuild(mid + <span class="number">1</span>, r);</span><br><span class="line">        push_up(x); <span class="comment">// bug</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt[x] &amp;&amp; (<span class="keyword">double</span>)max(sz[ls[x]], sz[rs[x]]) &gt;= Alpha * sz[x]) &#123;</span><br><span class="line">            cnt_tmp = <span class="number">0</span>, pia(x);</span><br><span class="line">            x = rebuild(<span class="number">1</span>, cnt_tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!x) &#123;</span><br><span class="line">            x = new_node();</span><br><span class="line">            val[x] = k, cnt[x] = sz[x] = rsz[x] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (val[x] == k) &#123;</span><br><span class="line">            ++cnt[x], push_up(x); <span class="comment">// bug</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        insert(k &gt; val[x] ? rs[x] : ls[x], k);</span><br><span class="line">        push_up(x), maintain(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (val[x] == k) &#123;</span><br><span class="line">            --cnt[x], push_up(x); <span class="comment">// bug</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        erase(k &gt; val[x] ? rs[x] : ls[x], k);</span><br><span class="line">        push_up(x), maintain(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rank</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!x) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnt[x] &amp;&amp; val[x] == k) <span class="keyword">return</span> rsz[ls[x]] + <span class="number">1</span>; <span class="comment">// bug</span></span><br><span class="line">        <span class="keyword">if</span> (k &gt; val[x]) <span class="keyword">return</span> rsz[ls[x]] + cnt[x] + rank(rs[x], k);</span><br><span class="line">        <span class="keyword">return</span> rank(ls[x], k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= rsz[ls[x]]) <span class="keyword">return</span> kth(ls[x], k);</span><br><span class="line">        <span class="keyword">if</span> (k &gt; rsz[ls[x]] + cnt[x]) <span class="keyword">return</span> kth(rs[x], k - rsz[ls[x]] - cnt[x]);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> kth(root, rank(root, k) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">nxt</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> kth(root, rank(root, k + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; T;</span><br></pre></td></tr></table></figure>
<h2 id="wblt">WBLT</h2>
<blockquote>
<p>update on 2020.2.19</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WBLT</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> cnt, root;</span><br><span class="line">    <span class="keyword">int</span> val[M], sz[M], ls[M], rs[M];</span><br><span class="line">    </span><br><span class="line">    WBLT() &#123;</span><br><span class="line">    	new_node(root, <span class="number">1e9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_leaf</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !(ls[x] || rs[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (is_leaf(x)) <span class="keyword">return</span>;</span><br><span class="line">        val[x] = max(val[ls[x]], val[rs[x]]);</span><br><span class="line">        sz[x] = sz[ls[x]] + sz[rs[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">new_node</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        x = ++cnt;</span><br><span class="line">        val[x] = k, sz[x] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">bool</span> opt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!opt) &#123;</span><br><span class="line">            <span class="keyword">int</span> rson = rs[x];</span><br><span class="line">            rs[x] = ls[x], ls[x] = ls[rs[x]];</span><br><span class="line">            ls[rs[x]] = rs[rs[x]], rs[rs[x]] = rson;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> lson = ls[x];</span><br><span class="line">            ls[x] = rs[x], rs[x] = rs[ls[x]];</span><br><span class="line">            rs[ls[x]] = ls[ls[x]], ls[ls[x]] = lson;</span><br><span class="line">        &#125;</span><br><span class="line">        push_up(ls[x]), push_up(rs[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (is_leaf(x)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (sz[ls[x]] &gt;= sz[rs[x]] * <span class="number">4</span>) rotate(x, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sz[rs[x]] &gt;= sz[ls[x]] * <span class="number">4</span>) rotate(x, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (is_leaf(x)) &#123;</span><br><span class="line">            new_node(ls[x], min(val[x], k));</span><br><span class="line">            new_node(rs[x], max(val[x], k));</span><br><span class="line">            push_up(x);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= val[ls[x]]) insert(ls[x], k);</span><br><span class="line">        <span class="keyword">else</span> insert(rs[x], k);</span><br><span class="line">        push_up(x), maintain(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (is_leaf(x)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!fa) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">int</span> son = ls[fa] == x ? rs[fa] : ls[fa];</span><br><span class="line">            val[fa] = val[son], sz[fa] = sz[son];</span><br><span class="line">            ls[fa] = ls[son], rs[fa] = rs[son];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= val[ls[x]]) erase(ls[x], x, k);</span><br><span class="line">        <span class="keyword">else</span> erase(rs[x], x, k);</span><br><span class="line">        push_up(x), maintain(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rank</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (is_leaf(x))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + (k &gt; val[x]);</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= val[ls[x]]) <span class="keyword">return</span> rank(ls[x], k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> sz[ls[x]] + rank(rs[x], k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">k_th</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (is_leaf(x)) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= sz[ls[x]]) <span class="keyword">return</span> k_th(ls[x], k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> k_th(rs[x], k - sz[ls[x]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> k, <span class="keyword">bool</span> opt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rk = rank(rt, k), rk2 = rank(rt, k+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!opt &amp;&amp; rk == <span class="number">1</span>) <span class="keyword">return</span> -INF;</span><br><span class="line">        <span class="keyword">if</span> (opt &amp;&amp; rk2 &gt; sz[rt]) <span class="keyword">return</span> INF;</span><br><span class="line">        <span class="keyword">return</span> val[k_th(rt, opt ? rk2 : rk - <span class="number">1</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>总结 并查集</title>
    <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<p>并查集用于处理一些不交集的 <strong>合并</strong> 及 <strong>查询</strong> 问题。</p>
<a id="more"></a>
<h2 id="简易版">简易版</h2>
<p>注意提前把father赋为自己！！！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    fa[i] = i;</span><br></pre></td></tr></table></figure>
<p>含路径压缩的查找函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = find(fa[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>合并函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x = find(x), y = find(y);</span><br><span class="line">    <span class="keyword">if</span> (x != y) fa[x] = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="路径压缩-按秩合并">路径压缩× 按秩合并√</h2>
<p>某些题无法使用路径压缩，那就维护点数或者深度，按秩合并。</p>
<p>每次查询复杂度 <span class="math inline">\(O(logn)\)</span>，不会证。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x = find(x), y = find(y);</span><br><span class="line">    <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (size[x] &gt; size[y]) swap(x, y);</span><br><span class="line">        fa[x] = y, size[y] += size[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="带权并查集">带权并查集</h2>
<p>当两个元素之间的关系可以量化，并且关系可以合并时，可以使用带权并查集来维护元素之间的关系。</p>
<p>每个节点维护某种权值，在查找时合并根到其路径上的权值。</p>
<p>例题：<a href="https://www.luogu.com.cn/problem/P2024">P2024 [NOI2001]食物链</a></p>
<p>权值实际上是建立在边上的，我们可以用 0,1,2 分别代表同类、天敌和猎物。</p>
<p>查找时在模3意义下累加节点祖先的权值，可以推出节点和根和关系。</p>
<p>权值相减可以得到两个节点的关系。</p>
<h2 id="扩展域并查集">扩展域并查集</h2>
<p>将每个点拆成多个点来维护多组关系，种类并查集似乎属于扩展域并查集。</p>
<p>例题：<a href="https://www.luogu.com.cn/problem/P1525">P1525 关押罪犯</a></p>
<p>将每个点拆成罪犯的朋友和罪犯的敌人，分别形成集合，就可以判断矛盾关系了。</p>
<p>食物链也可以用扩展域并查集做，需要维护三个种类。</p>
]]></content>
      <categories>
        <category>总结</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 欧拉线性筛</title>
    <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-%E6%AC%A7%E6%8B%89%E7%BA%BF%E6%80%A7%E7%AD%9B/</url>
    <content><![CDATA[<p>欧拉线性筛可以 <span class="math inline">\(O(n)\)</span> 筛出质数和积性函数。</p>
<a id="more"></a>
<h2 id="筛质数">筛质数</h2>
<p>未访问的是质数</p>
<p>之后从质数表开始</p>
<p>把<span class="math inline">\(i*pri[j]\)</span>标为访问过</p>
<p>如果<span class="math inline">\(i\)</span>是<span class="math inline">\(pri[j]\)</span>的倍数就跳出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pri;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[i])</span><br><span class="line">        pri.push_back(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pri.size() &amp;&amp; pri[j] * i &lt;= n; ++j) &#123;</span><br><span class="line">        vis[pri[j]*i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>)</span><br><span class="line">        	<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="筛varphix">筛<span class="math inline">\(\varphi(x)\)</span></h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tag[i])</span><br><span class="line">        pri[++tot] = i, phi[i] = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, k; j &lt;= tot &amp;&amp; (k = pri[j] * i) &lt;= n; ++j) &#123;</span><br><span class="line">        tag[k] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (i % pri[j])</span><br><span class="line">            phi[k] = phi[i] * phi[pri[j]];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            phi[k] = phi[i] * pri[j];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="筛dx">筛<span class="math inline">\(d(x)\)</span></h2>
<p><del>粘过来的</del>线性筛 <span class="math inline">\(d(x)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vis[i] = d[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) </span><br><span class="line">        pri.push_back(i), d[i] = <span class="number">2</span>, a[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pri.size() &amp;&amp; i * pri[j] &lt;= n; ++j) &#123;</span><br><span class="line">        vis[i*pri[j]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i % pri[j]) </span><br><span class="line">            d[i*pri[j]] = d[i] * d[pri[j]], a[i*pri[j]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            d[i*pri[j]] = d[i] / (a[i] + <span class="number">1</span>) * (a[i] + <span class="number">2</span>);</span><br><span class="line">            a[i*pri[j]] = a[i]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
        <category>Math</category>
      </categories>
      <tags>
        <tag>欧拉线性筛</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 高斯消元</title>
    <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/</url>
    <content><![CDATA[<p>我选择的是简单好写的高斯-约旦消法</p>
<a id="more"></a>
<blockquote>
<p>1.选择一个尚未被选过的未知数作为主元，选择一个包含这个主元的方程。</p>
<p>2.将这个方程主元的系数化为1。</p>
<p>3.通过加减消元，消掉其它方程中的这个未知数。</p>
<p>4.重复以上步骤，直到把所有式子变成形如: a*1+b*0+c*0……=d</p>
</blockquote>
<p>code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Gauss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 找到该列的最大值</span></span><br><span class="line">        <span class="keyword">int</span> mx = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(a[j][i]) &gt; <span class="built_in">abs</span>(a[mx][i]))</span><br><span class="line">                mx = j;</span><br><span class="line">        <span class="keyword">if</span> (a[mx][i] == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">// 返回无解</span></span><br><span class="line">        <span class="comment">// 交换行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n + <span class="number">1</span>; ++j)</span><br><span class="line">            swap(a[i][j], a[mx][j]);</span><br><span class="line">        <span class="comment">// 加减消元</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)<span class="comment">// 注意是1~n</span></span><br><span class="line">            <span class="keyword">if</span> (j != i) &#123;</span><br><span class="line">                <span class="keyword">double</span> d = a[j][i] / a[i][i];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt;= n + <span class="number">1</span>; ++k)</span><br><span class="line">                    a[j][k] -= a[i][k] * d;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出解</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, a[i][n+<span class="number">1</span>] / a[i][i]);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
        <category>Math</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>蒟蒻的zz码风</title>
    <url>/2020/01/17/2020-01-17-%E8%92%9F%E8%92%BB%E7%9A%84zz%E7%A0%81%E9%A3%8E/</url>
    <content><![CDATA[<p>自认为码风就像代码的脸，无论是调试还是写题解都极其重要</p>
<p>下面是我的码风，莫喷</p>
<a id="more"></a>
<h2 id="空格-tab">空格 &amp; tab</h2>
<p><strong>松散胜于紧凑</strong></p>
<ul>
<li>tab宽度4</li>
<li>运算符前后加空格</li>
<li><code>,</code> 后加空格</li>
<li>嫌挤的地方加空格</li>
<li>大括号不换行（少说这个，引起战争）</li>
</ul>
<p>大概一个 a+b 写成这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码块分布">代码块分布</h2>
<p>意思相近的语句、函数写到一块</p>
<p>大块数据结构包装起来</p>
<p>各个代码块间加空行（我乱加空行的怪癖改不掉）</p>
<p>顺序嘛：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快读</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TT&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(TT &amp;x)</span> </span>&#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏定义/结构体定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ... ...</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量定义</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量定义</span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数/包装用的结构体</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Splay</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>当然我喜欢总体套一个 namespace ，看<a href="https://banana.blog.luogu.org/tong-guo-namespace-fang-zhi-ming-ming-chong-tu">这里</a></p>
<h2 id="压行">压行</h2>
<p>曾经我是痛恨压行的，如今自己成为了曾经讨厌的人。。。</p>
<p><strong>代码还是简洁的好</strong></p>
<p>不过自认为压行并不是凑到一块那么简单</p>
<p>我曾见过这样的压行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n+k+<span class="number">1</span>;++i)cur[i]=head[i];</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(deep,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(deep));<span class="built_in">memset</span>(inq,<span class="number">0</span>,<span class="keyword">sizeof</span>(inq));</span><br><span class="line">    q.push(s);inq[s]=<span class="literal">true</span>;deep[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front(),v;q.pop();inq[u]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=e[i].nxt)&#123;v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(deep[v]&gt;deep[u]+<span class="number">1</span>&amp;&amp;e[i].flow)&#123;</span><br><span class="line">                deep[v]=deep[u]+<span class="number">1</span>;<span class="keyword">if</span>(!inq[v])&#123;q.push(v);inq[v]=<span class="literal">true</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deep[t]!=INF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>不是我想针对谁，这样压行太拙劣了</del></p>
<p>压行要有原则和规范</p>
<ul>
<li><p>一行内尽量不出现多个<code>;</code></p></li>
<li><p><code>&#123;</code> 后不要写东西， <code>&#125;</code>另起一行（大括号一般使用时）</p></li>
<li><p>不好理解或过于复杂的代码不压行</p></li>
<li><p><strong>熟练运用 C++ 语言特性来缩减语句</strong></p>
<ul>
<li><code>for/while</code> 等里面只有一句时不加大括号</li>
<li>用<code>,</code>连接较短语句，作为一句（有时候还能少个大括号呢）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= n; ++i)</span><br><span class="line">   	read(u), read(v), add(u, v);</span><br></pre></td></tr></table></figure>
<ul>
<li>多用三目运算符代替简单的 <code>if/else</code> 判断</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">get(fa) == get(x) ? rotate(fa) : rotate(x);</span><br><span class="line">(tag ? a1 : a2)[i] = x;<span class="comment">// 雾</span></span><br></pre></td></tr></table></figure>
<ul>
<li>多使用结构体的整体赋值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">e[++cnt] = (Edge)&#123;head[u], v&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>运用<code>&amp;&amp;</code> <code>||</code>的短路特性</li>
<li>部分<code>()</code> <code>[]</code>中嵌套一些简单赋值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt)</span><br><span class="line">    <span class="keyword">if</span> ((v = e[i].to) != fa)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></li>
</ul>
<p><del>显然我的压行优越得多</del></p>
<hr />
<p>总之敲代码要心情愉悦~</p>
<p>最后附上我美轮美奂的 vscode</p>
<blockquote>
<p>update 2020.1.18</p>
<p>有人说“美轮美奂”不应该在这用，好吧我语文不好，<del>只好说把我的VSCODE比喻为华丽的建筑</del></p>
</blockquote>
<p><img src="https://s2.ax1x.com/2019/12/15/QfFSPJ.jpg" /></p>
<p>欢迎交流互鉴</p>
<hr />
<p><del>平写题解都没见你bb这么多</del></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>题解 P1373 【小a和uim之大逃离】</title>
    <url>/2020/01/17/2020-01-17-%E9%A2%98%E8%A7%A3-P1373-%E3%80%90%E5%B0%8Fa%E5%92%8Cuim%E4%B9%8B%E5%A4%A7%E9%80%83%E7%A6%BB%E3%80%91/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P1373">题目</a></p>
<p>奇怪的递推（DP），居然没有自己做出来QAQ</p>
<a id="more"></a>
<hr />
<h2 id="初始思路">初始思路</h2>
<p>用<code>f[i][j][x][y]</code>表示取到 点<span class="math inline">\(i,j\)</span>时，小a有<span class="math inline">\(x\)</span>魔液，uim有<span class="math inline">\(y\)</span>魔液，的方案数</p>
<p>显然MLE，且复杂度不优秀，<span class="math inline">\(O(nmk^2)\)</span></p>
<h2 id="优化表示方式">优化表示方式</h2>
<p>答案要求两人差为零的方案数，所以只考虑两者魔液之差</p>
<p>用<code>f[i][j][x][p]</code>表示表示取到 点<span class="math inline">\(i,j\)</span>时，两人之差为<span class="math inline">\(x\)</span>，由<span class="math inline">\(p\)</span>（小a或uim）取最后一堆的方案数</p>
<h2 id="转移方程">转移方程</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 小a</span><br><span class="line">f[i][j][x][0] +&#x3D; f[i-1][j][x-a[i][j]][1]&#x2F;&#x2F; 上边</span><br><span class="line">f[i][j][x][0] +&#x3D; f[i][j-1][x-a[i][j]][1]&#x2F;&#x2F; 左边</span><br><span class="line">&#x2F;&#x2F; uim</span><br><span class="line">f[i][j][x][1] +&#x3D; f[i-1][j][x+a[i][j]][0]</span><br><span class="line">f[i][j][x][1] +&#x3D; f[i][j-1][x+a[i][j]][0]</span><br></pre></td></tr></table></figure>
<h2 id="细节">细节</h2>
<p>注意模的是<code>k+1</code>，所以我一开始<code>k++</code></p>
<p>因为只能由小a取第一堆，初始值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f[i][j][a[i][j]][0] &#x3D; 1</span><br></pre></td></tr></table></figure>
<p>只能由uim取最后一堆，答案为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ans +&#x3D; f[i][j][0][1]</span><br></pre></td></tr></table></figure>
<p>空间开到<code>f[805][805][20][2]</code>左右，不然容易MLE</p>
<h2 id="完整代码">完整代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BANANA &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; T k = <span class="number">1</span>; <span class="keyword">char</span> in = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(in)) &#123; <span class="keyword">if</span> (in == <span class="string">&#x27;-&#x27;</span>) k = <span class="number">-1</span>; in = getchar(); &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(in)) x = x * <span class="number">10</span> + in - <span class="string">&#x27;0&#x27;</span>, in = getchar();</span><br><span class="line">    x *= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">805</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="keyword">int</span> a[N][N], f[N][N][<span class="number">20</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mod</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x + k) % k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(m), read(k);</span><br><span class="line">    k++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            read(a[i][j]), a[i][j] %= k;</span><br><span class="line">            f[i][j][a[i][j]][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; k; ++x) &#123;</span><br><span class="line">                f[i][j][x][<span class="number">0</span>] = (f[i][j][x][<span class="number">0</span>] + f[i<span class="number">-1</span>][j][mod(x-a[i][j])][<span class="number">1</span>] + f[i][j<span class="number">-1</span>][mod(x-a[i][j])][<span class="number">1</span>]) % MOD;</span><br><span class="line">                f[i][j][x][<span class="number">1</span>] = (f[i][j][x][<span class="number">1</span>] + f[i<span class="number">-1</span>][j][mod(x+a[i][j])][<span class="number">0</span>] + f[i][j<span class="number">-1</span>][mod(x+a[i][j])][<span class="number">0</span>]) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            (ans += f[i][j][<span class="number">0</span>][<span class="number">1</span>]) %= MOD;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BANANA::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>递推DP</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P1967 【货车运输】</title>
    <url>/2020/01/17/2020-01-17-%E9%A2%98%E8%A7%A3-P1967-%E3%80%90%E8%B4%A7%E8%BD%A6%E8%BF%90%E8%BE%93%E3%80%91/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P1967">题面</a></p>
<a id="more"></a>
<h2 id="思路">思路</h2>
<p>因为一些容量小的边不会被经过，考虑先建出<strong>最大生成树</strong></p>
<p>题目转化成在树上求两点间路径最小权值</p>
<p>利用<span class="math inline">\(LCA\)</span>求最短路径</p>
<p>另外搞一个倍增数组<span class="math inline">\(minn[x][i]\)</span>，表示x到第<span class="math inline">\(2^i\)</span>个祖先之间路径最小权值</p>
<p>转移：<code>minn[x][i] = min(minn[x][i-1], minn[fa[x][i-1]][i-1]);</code></p>
<hr />
<h2 id="code">code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BANANA &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; T k = <span class="number">1</span>; <span class="keyword">char</span> in = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(in)) &#123; <span class="keyword">if</span> (in == <span class="string">&#x27;-&#x27;</span>) k = <span class="number">-1</span>; in = getchar(); &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(in)) x = x * <span class="number">10</span> + in - <span class="string">&#x27;0&#x27;</span>, in = getchar();</span><br><span class="line">    x *= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">5e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge_</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Edge_ &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> w &gt; t.w;<span class="comment">// 从大到小排</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> nxt, to, w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q, cnt;</span><br><span class="line"><span class="keyword">int</span> head[N], col[N], fa[N][<span class="number">30</span>], <span class="built_in">log</span>[N], deep[N], minn[N][<span class="number">30</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line">Edge_ e_[M];</span><br><span class="line">Edge e[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[++cnt] = (Edge)&#123;head[u], v, w&#125;, head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = a;</span><br><span class="line">    a = b, b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集找father</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> col[x] == x ? x : col[x] = find(col[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大生成树</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        col[i] = i;</span><br><span class="line">    sort(e_+<span class="number">1</span>, e_+m+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="keyword">if</span> (find(e_[i].x) != find(e_[i].y)) &#123;</span><br><span class="line">            col[find(e_[i].x)] = e_[i].y;</span><br><span class="line">            add(e_[i].x, e_[i].y, e_[i].w), add(e_[i].y, e_[i].x, e_[i].w);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LCA预处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    vis[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">log</span>[deep[x]]; ++i)</span><br><span class="line">        fa[x][i] = fa[fa[x][i<span class="number">-1</span>]][i<span class="number">-1</span>], minn[x][i] = min(minn[fa[x][i<span class="number">-1</span>]][i<span class="number">-1</span>], minn[x][i<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x], y; i; i = e[i].nxt) &#123;</span><br><span class="line">        y = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (!vis[y]) &#123;</span><br><span class="line">            deep[y] = deep[x] + <span class="number">1</span>, fa[y][<span class="number">0</span>] = x, minn[y][<span class="number">0</span>] = e[i].w;</span><br><span class="line">            dfs(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (find(x) != find(y))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = INF;</span><br><span class="line">    <span class="keyword">if</span> (deep[x] &lt; deep[y])</span><br><span class="line">        swap(x, y);</span><br><span class="line">    <span class="keyword">while</span> (deep[x] &gt; deep[y]) &#123;</span><br><span class="line">        ans = min(ans, minn[x][<span class="built_in">log</span>[deep[x]-deep[y]]<span class="number">-1</span>]);</span><br><span class="line">        x = fa[x][<span class="built_in">log</span>[deep[x]-deep[y]]<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == y)</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">log</span>[deep[x]]; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> (fa[x][i] != fa[y][i]) &#123;</span><br><span class="line">            ans = min(ans, min(minn[x][i], minn[y][i]));</span><br><span class="line">            x = fa[x][i], y = fa[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    ans = min(ans, min(minn[x][<span class="number">0</span>], minn[y][<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">return</span> ans;<span class="comment">// 返回路径上最小值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        read(e_[i].x), read(e_[i].y), read(e_[i].w);</span><br><span class="line"></span><br><span class="line">    Kruskal();</span><br><span class="line">    <span class="comment">// 递推log数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">log</span>[i] = <span class="built_in">log</span>[i<span class="number">-1</span>] + ((<span class="number">1</span> &lt;&lt; <span class="built_in">log</span>[i<span class="number">-1</span>]) == i);</span><br><span class="line">    <span class="comment">// 注意图不一定联通</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            deep[i] = <span class="number">1</span>;</span><br><span class="line">            fa[i][<span class="number">0</span>] = i;</span><br><span class="line">            minn[i][<span class="number">0</span>] = INF;</span><br><span class="line">            dfs(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    read(q);</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        read(x), read(y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, LCA(x, y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BANANA::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图论</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>LCA</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2279 【[HNOI2003]消防局的设立】</title>
    <url>/2020/01/17/2020-01-17-%E9%A2%98%E8%A7%A3-P2279-%E3%80%90HNOI2003%E6%B6%88%E9%98%B2%E5%B1%80%E7%9A%84%E8%AE%BE%E7%AB%8B%E3%80%91/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P2279">题目</a></p>
<p>第一道连状态都不会表示的<span class="math inline">\(dp\)</span></p>
<p>转移方程推到吐。。。</p>
<a id="more"></a>
<h2 id="状态表示">状态表示</h2>
<p>每一个点<span class="math inline">\(x\)</span>都有五个状态：</p>
<blockquote>
<p><code>f[x][0]</code>：覆盖到x的爷爷和x整棵子树（向上2层），最少个数</p>
</blockquote>
<blockquote>
<p><code>f[x][1]</code>：覆盖到x的父亲和x整棵子树（向上1层），最少个数</p>
</blockquote>
<blockquote>
<p><code>f[x][2]</code>：覆盖x整棵子树（向上0层），最少个数</p>
</blockquote>
<blockquote>
<p><code>f[x][3]</code>：覆盖所有x的儿子及其子树（向上-1层），最少个数</p>
</blockquote>
<blockquote>
<p><code>f[x][4]</code>：覆盖所有x的孙子及其子树（向上-2层），最少个数</p>
</blockquote>
<hr />
<ul>
<li><code>f[x][0]</code>：覆盖到x的爷爷和x整棵子树（向上2层），最少个数</li>
</ul>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/83nui5b4.png" /></p>
<ul>
<li><code>f[x][1]</code>：覆盖到x的父亲和x整棵子树（向上1层），最少个数</li>
</ul>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/6lhd8icf.png" /></p>
<ul>
<li><code>f[x][2]</code>：覆盖x整棵子树（向上0层），最少个数</li>
</ul>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/sxrk7lgi.png" /></p>
<ul>
<li><code>f[x][3]</code>：覆盖所有x的儿子及其子树（向上-1层），最少个数</li>
</ul>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/zdnxa2p1.png" /></p>
<ul>
<li><code>f[x][4]</code>：覆盖所有x的孙子及其子树（向上-2层），最少个数</li>
</ul>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/djsdjzke.png" /></p>
<h2 id="转移方程">转移方程</h2>
<p>y，z是x的儿子</p>
<p><span class="math inline">\(f[x][0] = 1 + \sum{f[y][4]}\)</span> <span class="math inline">\(f[x][1] = min(f[y][0] + \sum{(y!=z)f[z][3]})\)</span> <span class="math inline">\(f[x][2] = min(f[y][1] + \sum{(y!=z)f[z][2]})\)</span> <span class="math inline">\(f[x][3] = \sum{f[y][2]}\)</span> <span class="math inline">\(f[x][4] = \sum{f[y][3]}\)</span></p>
<p>显然<code>f[x][i]</code>一定包含<code>f[x][i+1]</code></p>
<p>易得<code>f[x][0] &gt;= f[x][1] &gt;= f[x][2] &gt;= f[x][3] &gt;= f[x][4]</code></p>
<p>所以转移时保证满足条件的前提下尽量选最低层的状态</p>
<hr />
<ul>
<li><span class="math inline">\(f[x][0] = 1 + \sum{f[y][4]}\)</span></li>
</ul>
<p>要覆盖到爷爷的话必须选x，并贪心地选y的第五种状态</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ogxjicaf.png" /></p>
<ul>
<li><span class="math inline">\(f[x][1] = min(f[y][0] + \sum{(y!=z)f[z][3]})\)</span></li>
</ul>
<p>x的儿子中有一个一定覆盖的爷爷，同时覆盖到兄弟（因为y一定是选了），其他的儿子只需要覆盖的自己的儿子即可</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/86y5d7hh.png" /></p>
<ul>
<li><span class="math inline">\(f[x][2] = min(f[y][1] + \sum{(y!=z)f[z][2]})\)</span></li>
</ul>
<p>同理，有一个儿子覆盖到父亲，但无法覆盖到y的兄弟，所以其他儿子要覆盖到自己</p>
<ul>
<li><span class="math inline">\(f[x][3] = \sum{f[y][2]}\)</span></li>
</ul>
<p>让每个儿子覆盖到自己即可</p>
<ul>
<li><span class="math inline">\(f[x][4] = \sum{f[y][3]}\)</span></li>
</ul>
<p>让每个儿子覆盖到自己的儿子</p>
<hr />
<p>注意：</p>
<p><strong><code>f[x][i]</code>包含<code>f[x][i+1]</code>，若<code>f[x][i]</code>比<code>f[x][i+1]</code>更优，<code>f[x][i+1]</code>应更新</strong></p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; T k = <span class="number">1</span>; <span class="keyword">char</span> in = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(in)) &#123; <span class="keyword">if</span> (in == <span class="string">&#x27;-&#x27;</span>) k = <span class="number">-1</span>; in = getchar(); &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(in)) x = x * <span class="number">10</span> + in - <span class="string">&#x27;0&#x27;</span>, in = getchar();</span><br><span class="line">    x *= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> nxt, to;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, cnt;</span><br><span class="line"><span class="keyword">int</span> head[N], f[N][<span class="number">5</span>];</span><br><span class="line">Edge e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[++cnt] = (Edge)&#123;head[u], v&#125;, head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录f[y][2], f[y][3]的总和，后面容斥即可</span></span><br><span class="line">    <span class="keyword">int</span> sum2 = <span class="number">0</span>, sum3 = <span class="number">0</span>, y, tot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != fa) &#123;</span><br><span class="line">            y = e[i].to;</span><br><span class="line">            dfs(y, x);</span><br><span class="line">            sum2 += f[y][<span class="number">2</span>], sum3 += f[y][<span class="number">3</span>];</span><br><span class="line">            tot++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 没有儿子特判</span></span><br><span class="line">    <span class="keyword">if</span> (!tot) &#123;</span><br><span class="line">        f[x][<span class="number">0</span>] = f[x][<span class="number">1</span>] = f[x][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[x][<span class="number">0</span>] = <span class="number">1</span>, f[x][<span class="number">1</span>] = f[x][<span class="number">2</span>] = N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != fa) &#123;</span><br><span class="line">            y = e[i].to;</span><br><span class="line">            f[x][<span class="number">0</span>] += f[y][<span class="number">4</span>];</span><br><span class="line">            f[x][<span class="number">1</span>] = min(f[x][<span class="number">1</span>], f[y][<span class="number">0</span>] + sum3 - f[y][<span class="number">3</span>]);</span><br><span class="line">            f[x][<span class="number">2</span>] = min(f[x][<span class="number">2</span>], f[y][<span class="number">1</span>] + sum2 - f[y][<span class="number">2</span>]);</span><br><span class="line">            f[x][<span class="number">3</span>] += f[y][<span class="number">2</span>];</span><br><span class="line">            f[x][<span class="number">4</span>] += f[y][<span class="number">3</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 检查最小值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">        f[x][i] = min(f[x][i], f[x][i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, x; i &lt;= n; ++i)</span><br><span class="line">        read(x), add(x, i), add(i, x);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P5662 【纪念品】</title>
    <url>/2020/01/17/2020-01-17-%E9%A2%98%E8%A7%A3-P5662-%E3%80%90%E7%BA%AA%E5%BF%B5%E5%93%81%E3%80%91/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P5662">题面</a></p>
<p>最后一次考pj了，居然炸了</p>
<p>s组day1把我心态考崩了，下午j组写了200分就开始颓废，<del>估计要被学弟们嘲笑了QAQ</del></p>
<a id="more"></a>
<hr />
<p>好了，开始<em>事后诸葛</em></p>
<h2 id="思路">思路</h2>
<p>n个物品，t天价格，数据范围不大，但是直接推转移方程不太可行</p>
<p>想到<strong>背包</strong>（考场上脑子里“背包”两字都没出现）</p>
<hr />
<p>先考虑<span class="math inline">\(n=1\)</span>的情况：</p>
<p>可以把t天的价格中，相邻两天的价格差当作一个物品（<span class="math inline">\(price=a[i],value=a[i+1]-a[i]\)</span>）</p>
<p><code>f[i]</code>表示花费i金币的最大收益（不包括本金）</p>
<p>可以自己手玩一下，同时选物品<span class="math inline">\(i\)</span>和<span class="math inline">\(i+1\)</span>收益就是<span class="math inline">\(a[i+2]-a[i]\)</span>，可以连续起来</p>
<p>每一天可以买卖多个，所以是完全背包</p>
<p>注意每天结束之后更新m，毕竟收益也可以用</p>
<hr />
<p>现在拓展到多个纪念品：</p>
<p>每一天都有n个物品，每个物品的价格还是本身，收益是下一天的减这一天的价格</p>
<p>每一天把n个物品做完全背包，之后更新m</p>
<p>最后得到的m就是答案</p>
<p>坑点是每天背包之前清空f数组</p>
<hr />
<h2 id="code">code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n, m;</span><br><span class="line"><span class="keyword">int</span> a[N][N], f[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(t), read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            read(a[i][j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = a[i][j]; k &lt;= m; ++k)</span><br><span class="line">                f[k] = max(f[k], f[k - a[i][j]] + a[i+<span class="number">1</span>][j] - a[i][j]);</span><br><span class="line">        m = max(m, f[m] + m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<p>话说今年pj比去年水的多，比tg良心</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2467 [SDOI2010]地精部落</title>
    <url>/2020/01/19/2020-01-19-%E9%A2%98%E8%A7%A3-P2467-SDOI2010%E5%9C%B0%E7%B2%BE%E9%83%A8%E8%90%BD/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.luogu.com.cn/problem/P2467">题面</a></p>
<p>求长度 <span class="math inline">\(n\)</span> 的交错序列的方案数。</p>
</blockquote>
<a id="more"></a>
<h2 id="思路">思路</h2>
<p>长度为 <span class="math inline">\(i\)</span> 的序列对于长度为 <span class="math inline">\(i-1\)</span> 的序列来说多了<strong>最大值</strong> <span class="math inline">\(i\)</span> ，所有我们可以枚举这个最大值的位置</p>
<p>为保证是交错序列，那么最大值位置的前驱和后继都必须是“山谷”</p>
<p>从最大值的位置 <span class="math inline">\(j\)</span> 劈开，问题该状态便可以转化成两个子状态：</p>
<p>长度为 <span class="math inline">\(j\)</span> 的结尾下降的序列方案数和长度为 <span class="math inline">\(i-1-j\)</span> 的开头上升的序列方案数</p>
<p>结尾下降和开头上升本质相同</p>
<p>最后方案数要乘上组合 <span class="math inline">\(C_{i-1}^j\)</span> （从 1 至 <span class="math inline">\(i-1\)</span> 中选出 <span class="math inline">\(j\)</span> 个数组成最大值前面的序列，离散化后方案数相同）</p>
<h2 id="状态表示-转移方程">状态表示 &amp; 转移方程</h2>
<p>设 <code>f[i]</code>表示长度为 <span class="math inline">\(i\)</span> 的交错序列的方案数</p>
<p>显然，开头上升和开头下降的方案一样多，开头上升的方案数就是总方案数的一半</p>
<p><span class="math display">\[
\large f[i] = \sum_{j=0}^{i-1}\frac{f[j]}{2}\cdot\frac{f[i-1-j]}{2}\cdot C_{i-1}^{j}
\]</span></p>
<h2 id="细节">细节</h2>
<h3 id="边界">边界</h3>
<p><code>f[1] = 1</code>，除以2不就。。。</p>
<p>其实长度为1的序列可以看成两种情况（“山谷”或“山峰”）</p>
<p>至于<code>f[0]</code>，当序列最大值置于最左侧（<span class="math inline">\(j=0\)</span>）时方案数不能乘0啊</p>
<p>所以<code>f[0] = f[1] = 2</code></p>
<h3 id="取模">取模</h3>
<p>问题来了，<span class="math inline">\(p\)</span> 不为质数，不能求2的逆元，且 <span class="math inline">\(a=b\ (mod\ p)\)</span> 不等价于 <span class="math inline">\(\frac{a}{2}=\frac{b}{2}\ (mod\ p)\)</span></p>
<p>怎样除以 2 ？</p>
<p>因为 <span class="math inline">\(x\ mod\ p=(x\ mod\ 2p)\ mod\ p\)</span> （ <span class="math inline">\(x\)</span> 为 <span class="math inline">\(mod\ 2p\)</span> 意义下的偶数）</p>
<p>所以 <span class="math inline">\(\frac{x}{2}\ mod\ p=(\frac{x\ mod\ 2p}{2})\ mod\ p\)</span></p>
<p>过程中模 <span class="math inline">\(2p\)</span> 的意义下随便除以2，最后再模 <span class="math inline">\(p\)</span> 输出即可</p>
<h3 id="空间">空间</h3>
<p><del>似乎、听说、大概</del>递推组合数的数组空间开不下，滚呗</p>
<h2 id="code">code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">read(n), read(p);</span><br><span class="line">c[<span class="number">0</span>][<span class="number">0</span>] = c[<span class="number">1</span>][<span class="number">0</span>] = c[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">ll p2 = p * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">        c[i&amp;<span class="number">1</span>][j] = (c[i&amp;<span class="number">1</span>^<span class="number">1</span>][j] + c[i&amp;<span class="number">1</span>^<span class="number">1</span>][j<span class="number">-1</span>]) % p2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i - <span class="number">1</span>; ++j)</span><br><span class="line">        f[i] = (<span class="number">1l</span>l * c[i&amp;<span class="number">1</span>^<span class="number">1</span>][j] * f[j] / <span class="number">2</span> % p2 * f[i<span class="number">-1</span>-j] / <span class="number">2</span> + f[i]) % p2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, f[n] % p);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>递推DP</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 K-D Tree</title>
    <url>/2020/01/20/2020-01-20-%E6%9D%BF%E5%AD%90-K-D-Tree/</url>
    <content><![CDATA[<p>用于处理高维空间组织点</p>
<p>大概就是在某个维度下从坐标中位数二分，最后形成一棵二叉树</p>
<a id="more"></a>
<p>插入删除会导致树不平衡，需要类似替罪羊树的拍扁重建</p>
<p>这里先放个 2-D 的吧，针对<a href="https://www.luogu.com.cn/problem/P4169">模板题P4169</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Alph = <span class="number">0.75</span>;<span class="comment">// 平衡因子</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维下的坐标及树节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pos</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> minx[<span class="number">2</span>], maxx[<span class="number">2</span>], ls, rs, sz;<span class="comment">// minx，maxx存坐标范围</span></span><br><span class="line">    Pos p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, ans, root, cnt, nd;<span class="comment">// nd为此时维度</span></span><br><span class="line">Pos a[N];</span><br><span class="line">Node tr[N];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; trash;<span class="comment">// 垃圾回收</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照某个维度排序用cmp</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(Pos A, Pos B) &#123;</span><br><span class="line">    <span class="keyword">return</span> A.x[nd] &lt; B.x[nd];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建节点</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">new_node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">if</span> (trash.empty())</span><br><span class="line">        x = ++cnt;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x = trash.front(), trash.pop();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新信息</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ls = tr[x].ls, rs = tr[x].rs;</span><br><span class="line">    <span class="comment">// 范围</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        tr[x].minx[i] = tr[x].maxx[i] = tr[x].p.x[i];</span><br><span class="line">        <span class="keyword">if</span> (ls)</span><br><span class="line">            tr[x].minx[i] = min(tr[x].minx[i], tr[ls].minx[i]), tr[x].maxx[i] = max(tr[x].maxx[i], tr[ls].maxx[i]);</span><br><span class="line">        <span class="keyword">if</span> (rs)</span><br><span class="line">            tr[x].minx[i] = min(tr[x].minx[i], tr[rs].minx[i]), tr[x].maxx[i] = max(tr[x].maxx[i], tr[rs].maxx[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    tr[x].sz = tr[ls].sz + tr[rs].sz + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建树（包括重建）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> x = new_node(), mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    nd = d, nth_element(a+l, a+mid, a+r+<span class="number">1</span>), tr[x].p = a[mid];<span class="comment">// 找中位数</span></span><br><span class="line">    tr[x].ls = build(l, mid<span class="number">-1</span>, d^<span class="number">1</span>), tr[x].rs = build(mid+<span class="number">1</span>, r, d^<span class="number">1</span>);</span><br><span class="line">    push_up(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拍扁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pia</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[x].ls)</span><br><span class="line">        pia(tr[x].ls, num);</span><br><span class="line">    a[num+tr[tr[x].ls].sz+<span class="number">1</span>] = tr[x].p, trash.push(x);<span class="comment">// 把点放入a数组便于建树</span></span><br><span class="line">    <span class="keyword">if</span> (tr[x].rs)</span><br><span class="line">        pia(tr[x].rs, num + tr[tr[x].ls].sz + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查平衡</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Alph * tr[x].sz &lt; tr[tr[x].ls].sz || Alph * tr[x].sz &lt; tr[tr[x].rs].sz)</span><br><span class="line">        pia(x, <span class="number">0</span>), x = build(<span class="number">1</span>, tr[x].sz, d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Pos tp, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) &#123;</span><br><span class="line">        x = new_node(), tr[x].p = tp, tr[x].ls = tr[x].rs = <span class="number">0</span>, push_up(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tp.x[d] &lt;= tr[x].p.x[d])</span><br><span class="line">        insert(tp, tr[x].ls, d^<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        insert(tp, tr[x].rs, d^<span class="number">1</span>);</span><br><span class="line">    push_up(x), check(x, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺便放一下 K-D Tree 在该题的运用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求曼哈顿距离</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dist</span><span class="params">(Pos A, Pos B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(A.x[<span class="number">0</span>] - B.x[<span class="number">0</span>]) + <span class="built_in">abs</span>(A.x[<span class="number">1</span>] - B.x[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求点到矩形（K-D Tree上一个子树）的曼哈顿距离</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getdis</span><span class="params">(Pos tp, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; ++i)</span><br><span class="line">        sum += max(<span class="number">0</span>, tp.x[i] - tr[x].maxx[i]) + max(<span class="number">0</span>, tr[x].minx[i] - tp.x[i]);<span class="comment">// 不理解就手玩一下</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(Pos tp, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ans = min(ans, dist(tp, tr[x].p));</span><br><span class="line">    <span class="keyword">int</span> dl = INF, dr = INF;</span><br><span class="line">    <span class="keyword">if</span> (tr[x].ls) </span><br><span class="line">        dl = getdis(tp, tr[x].ls);</span><br><span class="line">    <span class="keyword">if</span> (tr[x].rs)</span><br><span class="line">        dr = getdis(tp, tr[x].rs);</span><br><span class="line">    <span class="comment">// 爆搜，先搜最优的</span></span><br><span class="line">    <span class="keyword">if</span> (dl &lt; dr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dl &lt; ans)</span><br><span class="line">            query(tp, tr[x].ls);</span><br><span class="line">        <span class="keyword">if</span> (dr &lt; ans)</span><br><span class="line">            query(tp, tr[x].rs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dr &lt; ans)</span><br><span class="line">            query(tp, tr[x].rs);</span><br><span class="line">        <span class="keyword">if</span> (dl &lt; ans)</span><br><span class="line">            query(tp, tr[x].ls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// query</span></span><br><span class="line">ans = INF, query(tp, root), <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br></pre></td></tr></table></figure>
<p>我tcl，只会模板题</p>
]]></content>
      <categories>
        <category>总结</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>K-DTree</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 多项式全家桶</title>
    <url>/2020/12/25/2020-01-24-%E6%9D%BF%E5%AD%90-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%85%A8%E5%AE%B6%E6%A1%B6/</url>
    <content><![CDATA[<p>在所有集训中都是前置知识，快哭了。</p>
<p>记录一些又丑又慢的板子，顺便<del>抄</del>写一些推导过程。</p>
<a id="more"></a>
<p>非常推荐：<a href="https://www.luogu.com.cn/blog/command-block/ntt-yu-duo-xiang-shi-quan-jia-tong">command_block 的博客</a>。</p>
<h2 id="辅助">辅助</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">calc_rev</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) ? (n &gt;&gt; <span class="number">1</span>) : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc_len</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (len &lt; n) len &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for NTT：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) a[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) a[i] = b[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">px</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) a[i] = (LL)a[i] * b[i] % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init_inv</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        inv[i] = (LL)inv[P % i] * (P - P / i) % P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for FFT：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Complex(<span class="keyword">double</span> xx = <span class="number">0</span>, <span class="keyword">double</span> yy = <span class="number">0</span>) &#123;</span><br><span class="line">        x = xx, y = yy;</span><br><span class="line">    &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> +(<span class="keyword">const</span> Complex &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Complex(x + t.x, y + t.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> -(<span class="keyword">const</span> Complex &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Complex(x - t.x, y - t.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> *(<span class="keyword">const</span> Complex &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Complex(x * t.x - y * t.y, y * t.x + x * t.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Complex <span class="title">conj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Complex(x, -y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(Complex *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) a[i] = Complex(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(Complex *a, Complex *b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) a[i] = b[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">px</span><span class="params">(Complex *a, Complex *b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) a[i] = a[i] * b[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="fft-ntt">FFT &amp; NTT</h2>
<h3 id="fft">FFT</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex *f, <span class="keyword">int</span> n, <span class="keyword">int</span> opt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lim = calc_len(n);</span><br><span class="line">    calc_rev(lim);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; rev[i]) swap(f[i], f[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function">Complex <span class="title">wn</span><span class="params">(<span class="built_in">cos</span>(Pi / mid), opt * <span class="built_in">sin</span>(Pi / mid))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i += mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="function">Complex <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; ++j, w = w * wn) &#123;</span><br><span class="line">                Complex tx = f[i+j], ty = w * f[i+mid+j];</span><br><span class="line">                f[i+j] = tx + ty, f[i+mid+j] = tx - ty;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">-1</span>) &#123;</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i) f[i].x /= lim, f[i].y /= lim;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>三次变两次优化</strong>：</p>
<p>把 <span class="math inline">\(f_2\)</span> 放到 <span class="math inline">\(f_1\)</span> 的虚部上，DFT 一遍，平方，再把虚部取出来除以 2 即可。</p>
<h3 id="ntt">NTT</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> G = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> invG = <span class="number">332748118</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> n, <span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lim = calc_len(n);</span><br><span class="line">    calc_rev(lim);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; rev[i]) swap(f[i], f[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> wn = power(op == <span class="number">1</span> ? G : invG, (P - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i += mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> tx = f[i + j], ty = (LL)w * f[i + mid + j] % P;</span><br><span class="line">                f[i + j] = (tx + ty) % P;</span><br><span class="line">                f[i + mid + j] = (tx - ty + P) % P;</span><br><span class="line">                w = (LL)w * wn % P;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> invN = power(lim, P - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i) f[i] = (LL)f[i] * invN % P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多项式乘法">多项式乘法</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">poly_times</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> *g, <span class="keyword">int</span> n, <span class="keyword">int</span> lim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> t[N];</span><br><span class="line">    <span class="keyword">int</span> len = calc_len(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    clear(t, len), copy(t, g, n);</span><br><span class="line">    NTT(f, len, <span class="number">1</span>), NTT(t, len, <span class="number">1</span>);</span><br><span class="line">    px(f, t, len), NTT(f, len, <span class="number">-1</span>);</span><br><span class="line">    clear(f + lim, len - lim);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多项式求逆">多项式求逆</h2>
<blockquote>
<p>以下是不知道什么时候写的： 引用了 <a href="https://www.luogu.com.cn/user/37834">autoint</a> 的 <a href="https://www.luogu.com.cn/blog/autoint/solution-p4238">这篇博客</a>。 <span class="math display">\[
\begin{aligned}
A\times B&amp;\equiv 1 \pmod{x^n}\\
A\times B&#39;&amp;\equiv 1 \pmod{x^{\frac{n}{2}}}\\
A\times (B-B&#39;)&amp;\equiv 0\pmod{x^{\frac{n}{2}}}\\
B-B&#39;&amp;\equiv 0\pmod{x^{\frac{n}{2}}}\\
(B-B&#39;)^2&amp;\equiv 0\pmod{x^n}\\
A\times(B^2-2BB&#39;+B&#39;^2)&amp;\equiv 0\pmod{x^n}\\
B-2B&#39;+AB&#39;^2&amp;\equiv 0\pmod{x^n}\\
B&amp;\equiv 2B&#39;-AB&#39;^2\pmod{x^n}
\end{aligned}
\]</span> 据此可以倍增（可以把 B 数组滚动）。</p>
</blockquote>
<p>新笔记： <span class="math display">\[
A(x)B(x)-1\equiv 0\pmod{x^n}
\]</span> 设 <span class="math inline">\(G(B(x))=A(x)B(x)-1\)</span>，求导得 <span class="math inline">\(G&#39;(B(x))=A(x)\)</span>。</p>
<p>已知 <span class="math inline">\(B_*(x)\equiv A(x)^{-1}\pmod{x^{\frac{n}{2}}}\)</span>，牛顿迭代得 <span class="math display">\[
\begin{aligned}
B(x)&amp;\equiv B_*(x)-\frac{G(B_*(x))}{G&#39;(B_*(x))}\pmod{x^n}\\
&amp;\equiv B_*(x)-\frac{A(x)B_*(x)-1}{A(x)}\\
&amp;\equiv B_*(x)-B(x)(A(x)B_*(x)-1)
\end{aligned}
\]</span> <span class="math inline">\(A(x)B_*(x)-1\)</span> 在 <span class="math inline">\(\bmod x^n\)</span> 意义下只有次数大于等于 <span class="math inline">\(\frac{n}{2}\)</span> 的项（因为在 <span class="math inline">\(\bmod x^{\frac{n}{2}}\)</span> 意义下，<span class="math inline">\(A(x)B_*(x)-1\)</span> 次数小于 <span class="math inline">\(\frac{n}{2}\)</span> 的项都为 <span class="math inline">\(0\)</span>），所以 <span class="math inline">\(B(x)\)</span> 次数大于等于 <span class="math inline">\(\frac{n}{2}\)</span> 的项与其相乘后就会被模掉，只有次数小于 <span class="math inline">\(\frac{n}{2}\)</span> 的项有意义，便可以用 <span class="math inline">\(B_*(x)\)</span> 代替 <span class="math inline">\(B(x)\)</span>。 <span class="math display">\[
B(x)\equiv 2B_*(x)-A(x)B_*(x)^2\pmod{x^n}
\]</span> 然后倍增，复杂度 <span class="math inline">\(\mathcal O(n\log n)\)</span>，证明就是 <span class="math inline">\(\mathcal T(n)=\mathcal T(\frac{n}{2})+\mathcal O(n\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">poly_inv</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b1[N], b2[N], b3[N];</span><br><span class="line">    <span class="keyword">int</span> lim = calc_len(n);</span><br><span class="line">    clear(b1, lim &lt;&lt; <span class="number">1</span>), clear(b2, lim &lt;&lt; <span class="number">1</span>), clear(b3, lim &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    b1[<span class="number">0</span>] = power(f[<span class="number">0</span>], P - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= lim; len &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (len &gt;&gt; <span class="number">1</span>); ++i)</span><br><span class="line">            b2[i] = <span class="number">2l</span>l * b1[i] % P;</span><br><span class="line">        copy(b3, f, len);</span><br><span class="line">        NTT(b1, len &lt;&lt; <span class="number">1</span>, <span class="number">1</span>), NTT(b3, len &lt;&lt; <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        px(b1, b1, len &lt;&lt; <span class="number">1</span>), px(b1, b3, len &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        NTT(b1, len &lt;&lt; <span class="number">1</span>, <span class="number">-1</span>), clear(b1 + len, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">            b1[i] = (b2[i] - b1[i] + P) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    copy(f, b1, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多项式开根">多项式开根</h2>
<p><strong>要求 <span class="math inline">\(f[0] = 1\)</span>。</strong> <span class="math display">\[
B^2(x)-A(x)= 0
\]</span></p>
<p>设 <span class="math inline">\(G(B(x))=B^2(x)-A(x)\)</span>，则 <span class="math display">\[
G&#39;(B(x))=2B(x)
\]</span> 牛顿迭代 <span class="math display">\[
\begin{aligned}
B(x)&amp;=B_*(x)-\frac{G(B_*(x))}{G&#39;(B_*(x))}\\
&amp;=B_*(x)-\frac{B_*^2(x)-A(x)}{2B_*(x)}\\
&amp;=\frac{B_*^2(x)+A(x)}{2B_*(x)}
\end{aligned}
\]</span> 同样地倍增。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">poly_sqrt</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b1[N], b2[N];</span><br><span class="line">    <span class="keyword">int</span> lim = calc_len(n);</span><br><span class="line">    clear(b1, lim &lt;&lt; <span class="number">1</span>), clear(b2, lim &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    b1[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= lim; len &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (len &gt;&gt; <span class="number">1</span>); ++i) b2[i] = <span class="number">2l</span>l * b1[i] % P;</span><br><span class="line">        poly_inv(b2, len);</span><br><span class="line">        NTT(b1, len, <span class="number">1</span>), px(b1, b1, len), NTT(b1, len, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) b1[i] = (b1[i] + f[i]) % P;</span><br><span class="line">        poly_times(b1, b2, len, len);</span><br><span class="line">    &#125;</span><br><span class="line">    copy(f, b1, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多项式带余除法">多项式带余除法</h2>
<p><span class="math display">\[
F(x)=Q(x)\times G(x)+R(x)
\]</span></p>
<p>将多项式翻转，即设 <span class="math inline">\(F^T(x)=x^nF(x^{-1})\)</span>，则 <span class="math display">\[
F^T(x)=Q^T(x)\times G^T(x)+x^{n-m+1}R^T(x)
\]</span> 想办法消去余数 <span class="math inline">\(R(x)\)</span>，就对 <span class="math inline">\(x^{n-m+1}\)</span> 取模 <span class="math display">\[
\begin{aligned}
F^T(x)&amp;\equiv Q^T(x)\times G^T(x)&amp;\pmod{x^{n-m+1}}\\
Q^T(x)&amp;\equiv F^T(x)\times G^T(x)^{-1}&amp;\pmod{x^{n-m+1}}
\end{aligned}
\]</span></p>
<p>求出 <span class="math inline">\(Q^T(x)\)</span> 后再翻转即可。</p>
<p>那么余数 <span class="math inline">\(R(x)=F(x)-Q(x)\times G(x)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">poly_mod</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> *g, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a[N], b[N];</span><br><span class="line">    clear(a, n), clear(b, n);</span><br><span class="line">    <span class="keyword">int</span> L = n - m + <span class="number">1</span>;</span><br><span class="line">    reverse(f, f + n), copy(a, f, L), reverse(f, f + n);</span><br><span class="line">    reverse(g, g + m), copy(b, g, L), reverse(g, g + m);</span><br><span class="line">    poly_inv(b, L), poly_times(b, a, L, L), reverse(b, b + L);</span><br><span class="line">    poly_times(g, b, n, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; ++i) g[i] = (f[i] - g[i] + P) % P;</span><br><span class="line">    clear(g + m - <span class="number">1</span>, L);</span><br><span class="line">    copy(f, b, L), clear(f + L, n - L);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// f -&gt; Q(x), g -&gt; R(x)</span></span><br></pre></td></tr></table></figure>
<h2 id="多项式求导-积分">多项式求导 &amp; 积分</h2>
<h3 id="求导">求导</h3>
<p>单项式求导：<span class="math inline">\((ax^k)&#39;=akx^{k-1}\)</span>，推广一下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">poly_dev</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        f[i - <span class="number">1</span>] = (LL)f[i] * i % P;</span><br><span class="line">    f[n - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="积分">积分</h3>
<p>逆运算，记得预处理逆元。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">poly_int</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i)</span><br><span class="line">        f[i] = (LL)f[i - <span class="number">1</span>] * inv[i] % P;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多项式-ln">多项式 ln</h2>
<p><span class="math display">\[
\ln(A(x))=B(x)
\]</span></p>
<p>已知 <span class="math inline">\(\ln&#39; x=\frac{1}{x}\)</span>，所以两边分别对 <span class="math inline">\(x\)</span> 求导，并运用链式法则 <span class="math display">\[
\begin{aligned}
\frac{d}{dA(x)}\ln(A(x))\frac{dA(x)}{x}&amp;=B&#39;(x)\\
A(x)^{-1}A&#39;(x)&amp;=B&#39;(x)\\
B(x)&amp;=\int(A&#39;(x)A(x)^{-1})
\end{aligned}
\]</span> 要求常数项为 <span class="math inline">\(1\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">poly_ln</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> t[N];</span><br><span class="line">    copy(t, f, n);</span><br><span class="line">    poly_dev(t, n), poly_inv(f, n);</span><br><span class="line">    poly_times(f, t, n, n);</span><br><span class="line">    poly_int(f, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多项式-exp">多项式 exp</h2>
<h3 id="牛顿迭代">牛顿迭代</h3>
<p><span class="math display">\[
e^{A(x)}=B(x)
\]</span></p>
<p>设 <span class="math inline">\(G(B(x))=\ln(B(x))-A(x)\)</span>，就可以牛顿迭代了。</p>
<p>求导得 <span class="math inline">\(G&#39;(B(x))=B(x)^{-1}\)</span>，则 <span class="math display">\[
\begin{aligned}
B(x)&amp;=B_*(x)-\frac{G(B_*(x))}{G&#39;(B_*(x))}\\
&amp;=B_*(x)-\frac{\ln(B_*(x))-A(x)}{B_*(x)^{-1}}\\
&amp;=B_*(x)(1-\ln(B_*(x))+A(x))
\end{aligned}
\]</span> 倍增即可，不过常数很大，大概 <span class="math inline">\(\mathcal O(48\cdot n\log n)\)</span>。</p>
<p>要求常数项为 <span class="math inline">\(0\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">poly_exp</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b1[N], b2[N];</span><br><span class="line">    <span class="keyword">int</span> lim = calc_len(n);</span><br><span class="line">    clear(b1, lim), clear(b2, lim);</span><br><span class="line">    b1[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= lim; len &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        copy(b2, b1, len &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        poly_ln(b2, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) b2[i] = (f[i] - b2[i] + P) % P;</span><br><span class="line">        b2[<span class="number">0</span>] = (b2[<span class="number">0</span>] + <span class="number">1</span>) % P;</span><br><span class="line">        poly_times(b1, b2, len, len);</span><br><span class="line">    &#125;</span><br><span class="line">    copy(f, b1, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分治-fft">分治 FFT</h3>
<p>设 <span class="math inline">\(B(x)=e^{A(x)}\)</span>，两边求导得 <span class="math display">\[
B&#39;(x)=\frac{d}{dA(x)}e^{A(x)}\frac{dA(x)}{x}=B(x)A&#39;(x)
\]</span> 提取第 <span class="math inline">\(n\)</span> 项系数 <span class="math display">\[
(n+1)B[n+1]=\sum_{i=0}^n(i+1)A[i+1]B[n-i]
\]</span> 整理一下就是 <span class="math display">\[
B[n]=\frac{1}{n}\sum_{i=1}^n iA[i]B[n-i]
\]</span> 套上分治 FFT，复杂度 <span class="math inline">\(\mathcal O(n\log^2 n)\)</span>，但是比牛顿迭代跑的快！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> f[N], g[N], a[N], b[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r - l &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; <span class="number">0</span>) f[l] = (LL)f[l] * inv[l] % P;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = r - l, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    CDQ(l, mid);</span><br><span class="line">    copy(a, f + l, len &gt;&gt; <span class="number">1</span>), clear(a + (len &gt;&gt; <span class="number">1</span>), len &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    copy(b, g, len);</span><br><span class="line">    NTT(a, len, <span class="number">1</span>), NTT(b, len, <span class="number">1</span>);</span><br><span class="line">    px(a, b, len), NTT(a, len, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len &gt;&gt; <span class="number">1</span>; i &lt; len; ++i)</span><br><span class="line">        f[l + i] = (f[l + i] + a[i]) % P;</span><br><span class="line">    CDQ(mid, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main</span></span><br><span class="line">calc_inv(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) g[i] = (LL)g[i] * i % P;</span><br><span class="line"><span class="keyword">int</span> len = calc_len(n);</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">CDQ(<span class="number">0</span>, len);</span><br></pre></td></tr></table></figure>
<h2 id="多项式快速幂">多项式快速幂</h2>
<ul>
<li><strong>在保证 <span class="math inline">\(f[0]=1\)</span> 的情况下。</strong></li>
</ul>
<p>先 <span class="math inline">\(\ln\)</span> 再 <span class="math inline">\(\exp\)</span>，很好理解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">poly_pow</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    poly_ln(f, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) f[i] = (LL)f[i] * k % P;</span><br><span class="line">    poly_exp(f, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>在不保证 <span class="math inline">\(f[0]=1\)</span> 的情况下。</strong></li>
</ul>
<p><span class="math inline">\(f[0]\not=1\)</span> 时不能直接 <span class="math inline">\(\ln,\exp\)</span>，想办法让 <span class="math inline">\(f[0]=1\)</span>。</p>
<p>那就直接让所有项除以 <span class="math inline">\(f[0]\)</span>。</p>
<p>如果 <span class="math inline">\(f[0]=0\)</span>？那就找到最低次的非零项 <span class="math inline">\(x^p\)</span>，所有项提出个 <span class="math inline">\(x^p\)</span> 的公因子。</p>
<p>设 <span class="math inline">\(c=f[0]\)</span>，即 <span class="math display">\[
A^k(x)=(B(x)\times cx^p)^k=B^k(x)\times c^kx^{pk}
\]</span> 根据费马小定理，<span class="math inline">\(c^k\)</span> 的 <span class="math inline">\(k\)</span> 是在 <span class="math inline">\(\bmod \varphi(p)\)</span> 意义下的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">poly_pow2</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> n, <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>, k = <span class="number">0</span>, k2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!f[p]) ++p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; ++i) &#123;</span><br><span class="line">        k = (<span class="number">10l</span>l * k + str[i] - <span class="string">&#x27;0&#x27;</span>) % P;</span><br><span class="line">        k2 = (<span class="number">10l</span>l * k2 + str[i] - <span class="string">&#x27;0&#x27;</span>) % (P - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ((LL)p * k &gt; (LL)n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) f[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = n - p * k;</span><br><span class="line">    <span class="keyword">int</span> c = f[p], invc = power(c, P - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        f[i] = (LL)f[i + p] * invc % P;</span><br><span class="line">    clear(f + m, p * k);</span><br><span class="line">    poly_ln(f, m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        f[i] = (LL)f[i] * k % P;</span><br><span class="line">    poly_exp(f, m);</span><br><span class="line">    c = power(c, k2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= p * k; --i)</span><br><span class="line">        f[i] = (LL)f[i - p * k] * c % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p * k; ++i) f[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拆系数-fftmtt">拆系数 FFT（MTT）</h2>
<p><strong>4 次 FFT 的做法。</strong></p>
<p>先拆系数，<span class="math inline">\(f(x)=base\times A(x)+B(x)\)</span>，<span class="math inline">\(g(x)=base\times C(x)+D(x)\)</span>，一般 <span class="math inline">\(base=\sqrt{p}\)</span>，选择 <span class="math inline">\(2^{15}\)</span> 便于提取系数。</p>
<p>两个多项式拆成四个后直接 DFT 很浪费，发现虚部都是空的，两两打包一块 DFT，即 <span class="math display">\[
\begin{aligned}
P(x)&amp;=A(x)+iB(x)\\
Q(x)&amp;=A(x)-iB(x)
\end{aligned}
\]</span> <a href="https://www.luogu.com.cn/blog/_post/255275">AzusaCat 的博客</a> 证明了 <span class="math inline">\(P[k]\)</span> 和 <span class="math inline">\(Q[n-k]\)</span> 是共轭的，所以只需要 DFT <span class="math inline">\(P(x)\)</span>。</p>
<p>DFT 后解二元一次方程组即可得到 <span class="math inline">\(A(x),B(x)\)</span> 的点值。</p>
<p>iDFT 一样，将 <span class="math inline">\(A(x)C(x)\)</span>，<span class="math inline">\(A(x)D(x)+B(x)C(x)\)</span>，<span class="math inline">\(B(x)D(x)\)</span> 相乘后打包 iDFT 即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">MTT</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> *g, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Complex a[N], b[N], c[N], d[N];</span><br><span class="line">    <span class="keyword">int</span> lim = calc_len(n + m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i) &#123;</span><br><span class="line">        a[i].x = f[i] &gt;&gt; <span class="number">15</span>, a[i].y = f[i] &amp; <span class="number">32767</span>;</span><br><span class="line">        c[i].x = g[i] &gt;&gt; <span class="number">15</span>, c[i].y = g[i] &amp; <span class="number">32767</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    FFT(a, lim, <span class="number">1</span>), FFT(c, lim, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lim; ++i) b[i] = a[lim - i].conj();</span><br><span class="line">    b[<span class="number">0</span>] = a[<span class="number">0</span>].conj(); <span class="comment">/* 特判 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lim; ++i) d[i] = c[lim - i].conj();</span><br><span class="line">    d[<span class="number">0</span>] = c[<span class="number">0</span>].conj();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i) &#123;</span><br><span class="line">        Complex aa = (a[i] + b[i]) * Complex(<span class="number">0.5</span>, <span class="number">0</span>),</span><br><span class="line">            bb = (a[i] - b[i]) * Complex(<span class="number">0</span>, <span class="number">-0.5</span>),</span><br><span class="line">            cc = (c[i] + d[i]) * Complex(<span class="number">0.5</span>, <span class="number">0</span>),</span><br><span class="line">            dd = (c[i] - d[i]) * Complex(<span class="number">0</span>, <span class="number">-0.5</span>); <span class="comment">/* 乘(0,-0.5)就是除以2i */</span></span><br><span class="line">        a[i] = aa * cc + Complex(<span class="number">0</span>, <span class="number">1</span>) * (aa * dd + bb * cc);</span><br><span class="line">        b[i] = bb * dd;</span><br><span class="line">    &#125;</span><br><span class="line">    FFT(a, lim, <span class="number">-1</span>), FFT(b, lim, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n + m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> t1 = (LL)(a[i].x + <span class="number">0.5</span>) % P, </span><br><span class="line">            t2 = (LL)(a[i].y + <span class="number">0.5</span>) % P, </span><br><span class="line">            t3 = (LL)(b[i].x + <span class="number">0.5</span>) % P; <span class="comment">/* 注意精度T_T */</span></span><br><span class="line">        f[i] = (((<span class="number">1l</span>l &lt;&lt; <span class="number">30</span>) * t1 + (<span class="number">1l</span>l &lt;&lt; <span class="number">15</span>) * t2 + t3) % P + P) % P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分治-fft-1">分治 FFT</h2>
<p>给出 <span class="math inline">\(g[1]\dots g[n-1]\)</span>，求 <span class="math inline">\(f[0]\dots f[n-1]\)</span>。 <span class="math display">\[
f[i]=\sum_{j=1}^if[i-j]g[i]
\]</span> <span class="math inline">\(f\)</span> 每项会被比它小的项贡献，考虑 CDQ 分治，中序遍历处理左边对右边的贡献。</p>
<p>预先把长度补成 <span class="math inline">\(2\)</span> 的次幂，会好写些。（你这明明是分治 NTT 啊。）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> f[N], g[N], a[N], b[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r - l &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> len = r - l, mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    CDQ(l, mid);</span><br><span class="line">    copy(a, f + l, len &gt;&gt; <span class="number">1</span>), clear(a + (len &gt;&gt; <span class="number">1</span>), len &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    copy(b, g, len);</span><br><span class="line">    NTT(a, len, <span class="number">1</span>), NTT(b, len, <span class="number">1</span>);</span><br><span class="line">    px(a, b, len), NTT(a, len, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len &gt;&gt; <span class="number">1</span>; i &lt; len; ++i)</span><br><span class="line">        f[l + i] = (f[l + i] + a[i]) % P;</span><br><span class="line">    CDQ(mid, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="keyword">int</span> len = calc_len(n);</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">CDQ(<span class="number">1</span>, len);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
        <category>Math</category>
      </categories>
  </entry>
  <entry>
    <title>板子 FWT</title>
    <url>/2020/01/29/2020-01-29-%E6%9D%BF%E5%AD%90-FWT/</url>
    <content><![CDATA[<p>快速沃尔什变换，用于处理 <span class="math inline">\(C_k=\sum_{i\otimes j=k}A_i*B_j\)</span> （<span class="math inline">\(\otimes\)</span> 是集合运算符）几何卷积运算</p>
<p>对于 <span class="math inline">\(A\)</span> 求出 <span class="math inline">\(fwt[A]\)</span> ，使得 <span class="math inline">\(fwt[C]=fwt[A]*fwt[B]\)</span> ，于是就 <span class="math inline">\(O(n)\)</span> 了</p>
<a id="more"></a>
<p>我纯靠感性理解，更不会讲QAQ，这里只贴板子</p>
<p>几篇有帮助的博客：</p>
<ul>
<li><p><a href="https://www.cnblogs.com/ACMLCZH/p/8022502.html">ACMLCZH的blog</a></p></li>
<li><p><a href="https://www.luogu.com.cn/blog/xht37/solution-p4717">xht37的blog</a></p></li>
</ul>
<h2 id="or-或卷积"><span class="math inline">\(or\)</span> 或卷积</h2>
<p><span class="math inline">\(FWT\)</span>： <span class="math display">\[
fwt[a]=(fwt[a_0],\ fwt[a_0]+fwt[a_1])
\]</span> <span class="math inline">\(IFWT\)</span>：</p>
<p><span class="math display">\[
a=(a_0,\ a_0-a_1)
\]</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FWT_or</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> opt = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt;&lt; <span class="number">1</span> &lt;= n; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += mid &lt;&lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; ++j)</span><br><span class="line">                f[i+mid+j] = ((LL)f[i+j] * opt + f[i+mid+j] + MOD) % MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="and-与卷积"><span class="math inline">\(and\)</span> 与卷积</h2>
<p>非常相似呢，<del>只管粘过来一改就好</del></p>
<p><span class="math inline">\(FWT\)</span>： <span class="math display">\[
fwt[a]=(fwt[a_0]+fwt[a_1],\ fwt[a_1])
\]</span> <span class="math inline">\(IFWT\)</span>：</p>
<p><span class="math display">\[
a=(a_0-a_1,\ a_1)
\]</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FWT_and</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> opt = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt;&lt; <span class="number">1</span> &lt;= n; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += mid &lt;&lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; ++j)</span><br><span class="line">                f[i+j] = ((LL)f[i+j] + f[i+mid+j] * opt + MOD) % MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="xor-异或卷积"><span class="math inline">\(xor\)</span> 异或卷积</h2>
<p>最恶心的</p>
<p><span class="math inline">\(FWT\)</span>： <span class="math display">\[
fwt[a]=(fwt[a_0]+fwt[a_1],\ fwt[a_0]-fwt[a_1])
\]</span> <span class="math inline">\(IFWT\)</span>：</p>
<p><span class="math display">\[
a=(\frac{a_0+a_1}{2},\ \frac{a_0-a_1}{2})
\]</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FWT_xor</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> opt = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt;&lt; <span class="number">1</span> &lt;= n; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += mid &lt;&lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> fx = f[i+j], fy = f[i+mid+j];</span><br><span class="line">                f[i+j] = (LL)opt * (fx + fy) % MOD;</span><br><span class="line">                f[i+mid+j] = (LL)opt * (fx - fy + MOD) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（<span class="math inline">\(IFWT\)</span> 时，opt 应为 <span class="math inline">\(2^{-1}\)</span>）</p>
]]></content>
      <categories>
        <category>总结</category>
        <category>Math</category>
      </categories>
      <tags>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title>总结 BSGS</title>
    <url>/2020/02/06/2020-02-06-%E6%80%BB%E7%BB%93-BSGS/</url>
    <content><![CDATA[<p>求解关于 x 的 <span class="math inline">\(a^x\equiv b\pmod p\)</span> 同余方程的算法。</p>
<a id="more"></a>
<h2 id="用途">用途</h2>
<p>用于求这样的问题：</p>
<blockquote>
<p>给出 <span class="math inline">\(a, b, p\)</span> <span class="math display">\[
a^x\equiv b\pmod p
\]</span> 求 <span class="math inline">\(x\)</span> 的最小非负整数解</p>
</blockquote>
<p><a href="https://www.luogu.com.cn/problem/P2485">例题 Luogu P2485</a></p>
<h2 id="思想">思想</h2>
<p>先把 <span class="math inline">\(x\)</span> 拆分成 <span class="math inline">\(i*t-j\)</span> 的形式（<span class="math inline">\(t=\lceil\sqrt{p}\rceil\)</span>） <span class="math display">\[
a^{i*t-j}\equiv b\pmod p\\
a^{i*t}\equiv b*a^j\pmod p
\]</span> 枚举 <span class="math inline">\(j\in [0,t]\)</span> ，将 <span class="math inline">\(b*a^j\)</span> 放进哈希表（我这么懒肯定用 <span class="math inline">\(map\)</span> 水）</p>
<p>再枚举 <span class="math inline">\(i\in [0,t]\)</span> ，从哈希表中查找 <span class="math inline">\(a^{i\ast t}\)</span> ，找到即答案为 <span class="math inline">\(i\ast t-j\)</span></p>
<p>枚举 <span class="math inline">\(i,j\)</span> 都是 <span class="math inline">\(O(\sqrt{p})\)</span> 的</p>
<p><del>是不是很 easy</del></p>
<h2 id="code">code</h2>
<p>这里只好放 P2485 的代码了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;LL, LL&gt; m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">BSGS</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    m.clear();</span><br><span class="line">    b %= p;</span><br><span class="line">    <span class="keyword">if</span> (a % p == <span class="number">0</span>) &#123;<span class="comment">// 恶心的特判</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL t = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(p));</span><br><span class="line">    <span class="keyword">for</span> (LL i = <span class="number">0</span>, bn = b; i &lt;= t; ++i)</span><br><span class="line">        m[bn] = i, bn = bn * a % p;</span><br><span class="line">    a = power(a, t);</span><br><span class="line">    <span class="keyword">for</span> (LL i = <span class="number">0</span>, an = <span class="number">1</span>, j; i &lt;= t; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m.count(an)) &#123;</span><br><span class="line">            j = m[an];</span><br><span class="line">            <span class="keyword">if</span> (i * t - j &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> i * t - j;</span><br><span class="line">        &#125;</span><br><span class="line">        an = an * a % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<p>对于 p 不为质数的情况，我们需要 <a href="https://renamoe.gitee.io/2020/08/15/2020-08-15-总结-exBSGS/">exBSGS 算法</a> 求解。</p>
]]></content>
      <categories>
        <category>总结</category>
        <category>Math</category>
      </categories>
      <tags>
        <tag>BSGS</tag>
      </tags>
  </entry>
  <entry>
    <title>总结 OI中一些数学定理</title>
    <url>/2020/10/06/2020-02-06-%E6%80%BB%E7%BB%93-OI%E4%B8%AD%E4%B8%80%E4%BA%9B%E6%95%B0%E5%AD%A6%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p>这里放一些数学公式定理，防止健忘。</p>
<p>好吧现在已经是远古博客了，慎用。</p>
<a id="more"></a>
<h2 id="matrix-tree-定理">Matrix Tree 定理</h2>
<p>定义一个图 <span class="math inline">\(G\)</span> 的 <span class="math inline">\(\rm Kirchhoff\)</span> 矩阵 <span class="math inline">\(C=\text{度数矩阵}-\text{邻接矩阵}\)</span> <span class="math display">\[
C_{i,j}=
\begin{cases}
    degree_i&amp; (i=j)\\
    -1&amp; (i\not=j\ and\ (i,j)\in G(E))\\
    0&amp; (i\not=j\ and\ (i,j)\notin G(E))
\end{cases}
\]</span> 将矩阵 <span class="math inline">\(C\)</span> 去掉任意一行和一列，该矩阵的行列式即图 <span class="math inline">\(G\)</span> 的 生成树个数</p>
<h2 id="概率相关">概率相关</h2>
<p><span class="math inline">\(P(A)\)</span> ： <span class="math inline">\(A\)</span> 事件发生的概率</p>
<p><span class="math inline">\(E(X)\)</span>：随机变量 <span class="math inline">\(X\)</span> 的期望值，<span class="math inline">\(E(X)=\sum P(X=i)\times i\)</span></p>
<p><span class="math inline">\(P(A|B)\)</span>：<span class="math inline">\(A\)</span> 在 <span class="math inline">\(B\)</span> 发生的条件下发生的概率，<span class="math inline">\(P(A|B)=\frac{P(AB)}{P(B)}\)</span></p>
<p>全概率公式：<span class="math inline">\(P(B)=\sum_{i=1}^n{P(A_i)P(B|A_i)}\)</span></p>
<p>贝叶斯公式：<span class="math inline">\(P(A_i|B)=\frac{P(B|A_i)P(A_i)}{\sum_{j=1}^n{P(B|A_j)P(A_j)} }\)</span> （不会，不知道有没有用）</p>
<p>期望的性质：</p>
<p><span class="math inline">\(E(X+Y)=E(X)+E(Y)\)</span></p>
<p><span class="math inline">\(E(aX+b)=aE(X)+b\)</span></p>
<p><span class="math inline">\(E(XY)=E(X)+E(Y)\)</span> （ <span class="math inline">\(x,y\)</span> 相互独立）</p>
<h2 id="辛普森积分">辛普森积分</h2>
<p><span class="math display">\[
\frac{b-a}{6}[f(a)+4f(\frac{a+b}{2})+f(b)]
\]</span></p>
<p>自适应辛普森，分成左右分别套辛普森法则，不断拟合：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">simpson</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> (f(l) + <span class="number">4</span> * f(mid) + f(r)) * (r - l) / <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r, <span class="keyword">double</span> last, <span class="keyword">double</span> eps)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">double</span> ln = simpson(l, mid), rn = simpson(mid, r);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(ln + rn - last) &lt;= eps)</span><br><span class="line">    <span class="keyword">return</span> ln + rn + (ln + rn - last);</span><br><span class="line">    <span class="keyword">return</span> solve(l, mid, ln, eps/<span class="number">2</span>) + solve(mid, r, rn, eps/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>## 模性质</p>
<p>模意义下加、减、乘随便做，除要转换成逆元</p>
<p><span class="math inline">\(a\equiv b\pmod p\nRightarrow \frac{a}{2}\equiv \frac{b}{2}\pmod p\)</span></p>
<h2 id="裴蜀定理">裴蜀定理</h2>
<p>对于不定方程：<span class="math inline">\(ax+by=c\)</span></p>
<p>有（整数）解的充要条件为 <span class="math inline">\(\gcd⁡(a,b) | c\)</span></p>
<p>即一定存在 <span class="math inline">\(x,y\)</span> 满足 <span class="math inline">\(ax+by=\gcd(a,b)\)</span></p>
<p>推论：<span class="math inline">\(a,b\)</span> 互素等价于 <span class="math inline">\(ax+by=1\)</span> 有解</p>
<h2 id="欧几里得算法">欧几里得算法</h2>
<h3 id="gcd">gcd</h3>
<p><span class="math display">\[
\gcd(a,b)=\gcd(a-b,b)
\]</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非递归</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">        t = a, a = b, b = t % a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="exgcd">exgcd</h3>
<p><span class="math display">\[
ax+by=\gcd(a,b)\\
bx&#39;+(a\%b)y&#39;=\gcd(b,a\%b)
\]</span></p>
<p>将 <span class="math inline">\(a\ mod\ b\)</span> 替换为 <span class="math inline">\(a-\lfloor\frac{a}{b}\rfloor b\)</span> ，得 <span class="math display">\[
\begin{align}
bx&#39;+(a\%b)y&#39;&amp;=bx&#39;+(a-\lfloor\frac{a}{b}\rfloor b)y&#39;\\
&amp;=ay&#39;+b(x&#39;-\lfloor\frac{a}{b}\rfloor y&#39;)
\end{align}
\]</span> 则 <span class="math inline">\(x,y\)</span> 和 <span class="math inline">\(x&#39;,y&#39;\)</span> 的关系为 <span class="math display">\[
x=y&#39;,y=x&#39;-\lfloor\frac{a}{b}\rfloor y&#39;
\]</span> 当 <span class="math inline">\(b=0\)</span> 时，<span class="math inline">\(x&#39;=1\)</span> ，<span class="math inline">\(y\)</span> 可以为任何值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y, <span class="keyword">int</span> &amp;gcd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">    	x = <span class="number">1</span>, y = <span class="number">0</span>, gcd = a;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    exgcd(b, a%b, y, x, gcd);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求出的 x,y 为某一组解，x 通解为 <span class="math inline">\(x+k\times\frac{b}{\gcd(a,b)}\)</span>。</p>
<h2 id="整数唯一分解定理">整数唯一分解定理</h2>
<p>对于任意整数 <span class="math inline">\(N\ (N\ge2)\)</span> <span class="math display">\[
\large N=\prod_{i=1}^k{p_i^{r_i}}\quad (p_i\text{为质数},r_i\ge0)
\]</span></p>
<p><span class="math inline">\(N\)</span> 的正约数集合：<span class="math inline">\(\large\{\prod_{i=1}^k{p_i^{b_i}}\}\ (0\le b_i\le r_i)\)</span></p>
<p><span class="math inline">\(N\)</span> 的正约数个数：<span class="math inline">\(\large\prod_{i=1}^k{(r_i+1)}\)</span></p>
<p><span class="math inline">\(N\)</span> 的正约数和：<span class="math inline">\(\large\prod_{i=1}^k(\sum_{j=0}^{r_i}p_i^j)\)</span></p>
<h2 id="威尔逊定理">威尔逊定理</h2>
<p><span class="math inline">\(p\)</span> 是质数的充要条件为: <span class="math display">\[
(p-1)!\equiv -1\pmod p
\]</span></p>
<h2 id="费马小定理">费马小定理</h2>
<p><span class="math inline">\(p\)</span> 为质数，且 <span class="math inline">\(\gcd(a,p)=1\)</span> ，则： <span class="math display">\[
a^{p-1}\equiv 1\pmod p
\]</span> 故 <span class="math inline">\(a\)</span> 在模 <span class="math inline">\(p\)</span> 下的乘法逆元为 <span class="math inline">\(a^{p-2}\)</span></p>
<h3 id="线性预处理逆元">线性预处理逆元</h3>
<p>设 <span class="math inline">\(p=i*k+r(0\le r\le i)\)</span></p>
<p><span class="math display">\[
i*k+r\equiv 0\pmod p
\]</span></p>
<p>两边乘 <span class="math inline">\(i^{-1}r^{-1}\)</span></p>
<p><span class="math display">\[
k\times r^{-1}+i^{-1}\equiv 0 \pmod p
\\
i^{-1}\equiv -k\times r^{-1}\pmod p
\]</span></p>
<p>其中 <span class="math inline">\(r=p\%i,k=\lfloor\frac{p}{i}\rfloor\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    inv[i] = (p - p / i) * inv[p%i] % p;</span><br></pre></td></tr></table></figure>
<p>还有一种方法：</p>
<p>设 <span class="math inline">\(s_i=\prod_{j=1}^{i}a_i,invs_i=s_i^{-1}\)</span></p>
<p><span class="math inline">\(O(\log_2(mod))\)</span> 预处理 <span class="math inline">\(invs_n\)</span> ，则 <span class="math inline">\(invs_i=invs_{i+1}\times a_{i+1}\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    s[i] = s[i<span class="number">-1</span>] * a[i] % p;</span><br><span class="line">invs[n] = power(s[n], p<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i; --i)</span><br><span class="line">    invs[i] = invs[i+<span class="number">1</span>] * a[i+<span class="number">1</span>] % p;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    inv[i] = invs[i] * s[i<span class="number">-1</span>] % p;</span><br></pre></td></tr></table></figure>
<h2 id="欧拉函数">欧拉函数</h2>
<p><span class="math display">\[
\varphi(n)=\sum_{i=1}^n[\gcd(n, i)=1]
\]</span></p>
<p>若 <span class="math inline">\(p\)</span> 为素数，则 <span class="math inline">\(\varphi(p)=p-1\)</span></p>
<p>若 <span class="math inline">\(\gcd(a,b)=1\)</span>，则 <span class="math inline">\(\varphi(ab)=\varphi(a)\varphi(b)\)</span></p>
<p>基于素因数分解求 <span class="math inline">\(\varphi(n)\)</span> ，复杂度 <span class="math inline">\(O(\sqrt{n})\)</span> ：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">euler_phi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>); </span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>)</span><br><span class="line">                n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="number">1</span>) </span><br><span class="line">        res = res / n * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="欧拉定理">欧拉定理</h2>
<p><span class="math inline">\(a,p\)</span> 为互质的正整数 <span class="math display">\[
a^{\varphi(p)}\equiv 1\pmod p
\]</span></p>
<h3 id="扩展欧拉定理">扩展欧拉定理</h3>
<p>若 <span class="math inline">\(a,p\)</span> 不一定互质，且 <span class="math inline">\(x\ge \varphi(p)\)</span> <span class="math display">\[
a^x\equiv a^{x\%\varphi(p)+\varphi(p)}\pmod p
\]</span></p>
<h2 id="中国剩余定理">中国剩余定理</h2>
<h3 id="crt">crt</h3>
<p>对于一元线性同余方程组： <span class="math display">\[
\begin{cases}
    x\equiv a_1\pmod{m_1}\\
    x\equiv a_2\pmod{m_2}\\
    ……\\
    x\equiv a_n\pmod{m_n}
\end{cases}
\]</span> 其中 <span class="math inline">\(m_i\)</span> 两两互质</p>
<p>该方程组的通解为： <span class="math display">\[
M=\prod_{i=1}^nm_i\\
M_i=\frac{M}{m_i}\\
t_i=M_i^{-1}\pmod{m_i}\\
x\equiv \sum_{i=1}^n{a_it_iM_i\pmod M}
\]</span></p>
<h3 id="excrt">excrt</h3>
<p><a href="http://renamoe.gitee.io/2020/08/15/2020-08-15-%E6%9D%BF%E5%AD%90-CRT-exCRT/">见总结</a></p>
<h2 id="拉格朗日插值">拉格朗日插值</h2>
<p>对于一个给定 n 个点 <span class="math inline">\((x_i,y_i)\)</span> 的多项式，可以 <span class="math inline">\(O(n^2)\)</span> 算出该多项式在 <span class="math inline">\(x_k\)</span> 的取值 <span class="math display">\[
f(x_k)=\sum_{i=1}^n{y_i\prod_{i\not=j}\frac{x_k-x_j}{x_i-x_j}}
\]</span> 如果已知取值 <span class="math inline">\(x_1\)</span> 到 <span class="math inline">\(x_n\)</span> 是连续的话，可以预处理前缀积优化到 <span class="math inline">\(O(n\log n)\)</span>（逆元再线性处理就是 <span class="math inline">\(O(n)\)</span> ）</p>
<h2 id="莫比乌斯函数">莫比乌斯函数</h2>
<p><span class="math display">\[
\mu(n)=
\begin{cases}
    1&amp; (n=1)\\
    (-1)^k&amp; (n\text{无平方数因数},n=\prod_{i=1}^k{p_i})\\
    0&amp; (n\text{有大于1的平方数因数})
\end{cases}
\]</span></p>
<p><span class="math display">\[
\sum_{d\mid n}\mu(d)=
\begin{cases}
    1&amp; (n=1)\\
    0&amp; (n=0)
\end{cases}\\
\sum_{d\mid n}\frac{\mu(d)}{d}=\frac{\varphi(n)}{n}
\]</span></p>
<h2 id="一些积性函数">一些积性函数</h2>
<ul>
<li><span class="math inline">\(\varphi(n)\)</span>：欧拉函数</li>
<li><span class="math inline">\(\mu(n)\)</span>：莫比乌斯函数</li>
<li><span class="math inline">\(\gcd(n,k)\)</span>：（<span class="math inline">\(k\)</span> 固定时）最小公因数</li>
<li><span class="math inline">\(d(n)\)</span>：<span class="math inline">\(n\)</span> 的约数个数</li>
<li><span class="math inline">\(\sigma(n)\)</span>：<span class="math inline">\(n\)</span> 的约数和</li>
<li><span class="math inline">\(1(n)=1\)</span></li>
<li><span class="math inline">\(id(n)=n\)</span></li>
<li><span class="math inline">\(e(n)=\begin{cases}1&amp;(n=1) \\ 0 &amp;(n\not=1) \end{cases}\)</span></li>
</ul>
<h2 id="狄利克雷卷积">狄利克雷卷积</h2>
<p><span class="math display">\[
h=f\times g\\
h(n)=\sum_{i\mid n}{f(i)*g(\frac{n}{i})}
\]</span></p>
<p>两个数论函数的狄利克雷卷积结果仍是一个数论函数</p>
<p>两个积性函数的狄利克雷卷积仍是一个积性函数</p>
<p>狄利克雷卷积满足交换律、结合律</p>
<h2 id="lucas定理">Lucas定理</h2>
<p><span class="math display">\[
\binom{n}{m}\equiv\binom{\lfloor\frac{n}{p}\rfloor}{\lfloor\frac{m}{p}\rfloor}\binom{n\bmod p}{m\bmod p}\pmod p
\]</span></p>
<hr />
<p>待补充……</p>
]]></content>
      <categories>
        <category>总结</category>
        <category>Math</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>总结 SAM</title>
    <url>/2020/02/13/2020-02-13-%E6%80%BB%E7%BB%93-SAM/</url>
    <content><![CDATA[<p><span class="math inline">\(\rm SAM:\ Suffix\ Automaton\)</span> ，后缀自动机。</p>
<p><strong>远古博客，有许多纰漏，慎重食用！</strong></p>
<p>难理解，但代码好写（当初敲完模板题没总结，现在忘光了QAQ）</p>
<p>总体上是 <strong>后缀 trie + parent tree</strong> ，构成一个可以表示所有子串的 DAG</p>
<a id="more"></a>
<p>福利：<a href="https://zrt.io/2020/01/sam/">后缀自动机可视化</a></p>
<p>推荐博客：</p>
<ul>
<li><a href="https://www.luogu.com.cn/blog/Kesdiael3/hou-zhui-zi-dong-ji-yang-xie">KesdiaelKen 的博客</a>（我就是看这博客学会的）</li>
<li><a href="https://www.luogu.com.cn/blog/ShadowassIIXVIIIIV/solution-p3804">shadowice1984 的博客</a></li>
<li><a href="https://www.cnblogs.com/xzyxzy/p/9186759.html">xzyxzy 的博客</a></li>
</ul>
<p>这博客主要是我总结自己不好理解的地方，不是很全面</p>
<hr />
<blockquote>
<p>声明：本文中图片大部分为 BANANA 从他人博客<del>盗来的</del>借鉴的，一些语言表达借鉴于 <a href="https://www.luogu.com.cn/blog/Kesdiael3/hou-zhui-zi-dong-ji-yang-xie">KesdiaelKen 的博客</a> ，若有侵权请 <a href="mailto:true-banana@outlook.com">联系BANANA</a> 删除</p>
</blockquote>
<h2 id="思路">思路</h2>
<h3 id="前置">前置</h3>
<p>先了解几个概念：</p>
<p><strong>后缀 trie </strong>：把字符串的每一个后缀插入到 trie 树里</p>
<p>一个普通的后缀 trie ，有很大部分节点是可以压缩的</p>
<p><img src="https://true-banana.github.io/img/001.png" /></p>
<p><strong>endpos 集合</strong> ：一个子串在原串出现的位置（可能出现多次）的右端点集合</p>
<blockquote>
<p>比如一个串“banana”</p>
<p><span class="math inline">\(endpos(b)=\{1\},\ endpos(a)=\{2,4,6\}\)</span></p>
<p><span class="math inline">\(endpos(an)=\{3,5\},\ endpos(ana)=\{4,6\}\)</span></p>
</blockquote>
<p><strong>parent tree</strong> ：一个子串前面添加一个或几个字符，可以将他的 endpos 集合<strong>分割</strong>，endpos 集合之间便有了父子关系</p>
<p><img src="https://true-banana.github.io/img/002.png" /></p>
<p>parent tree 上每一个节点表示的 endpos 集合唯一地表示一个后缀集合</p>
<p><del>不好举例，自己手模吧</del></p>
<h3 id="构造">构造</h3>
<p><em>将后缀 trie 和 parent tree 结合起来便是 SAM 的 DAG</em></p>
<p><strong>那么一条路径表示原串的一个子串，一个节点 x 表示根节点到 x 路径形成的所有串的 endpos 集合</strong></p>
<p>SAM 常见的增量构造：将字符串从前到后一个一个字符插进去（离线构造窝不会）</p>
<p>先确定一些量：</p>
<ul>
<li><p><span class="math inline">\(fa[x]\)</span> ：x 节点表示的集合在 parent tree 上的父亲</p></li>
<li><p><span class="math inline">\(len[x]\)</span> ：x 节点表示的集合中<strong>最长</strong>的串的长度</p>
<p>如果设最短的串长为 <span class="math inline">\(minlen[x]\)</span> ，那么 <span class="math inline">\(len[fa[x]]+1=minlen[x]\)</span> ，即 parent tree 上的分割关系</p></li>
</ul>
<p>我们考虑从后面插入一个字符 c，会有什么变化：</p>
<ul>
<li>多出新串的后缀</li>
<li>新串后缀的 endpos 集合改变</li>
</ul>
<p>那么在 trie 的意义上要把旧串所有后缀的后面加上字符 c</p>
<p>在 SAM 上实现就是先新建节点 np</p>
<p>然后把最后一个节点 p、它在 parent tree 的父亲以及祖先的 c 儿子设为该节点（<strong>相当于压缩地遍历旧串的所有后缀</strong>）</p>
<p>并且 <span class="math inline">\(len[np]=len[p]+1\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> p = last, np = last = ++cnt;</span><br><span class="line">len[np] = len[p] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; !ch[p][c])</span><br><span class="line">    ch[p][c] = np, p = fa[p];</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p>如果这些祖先都没有 c 儿子，到达最高的祖先就是根节点</p>
<p>说明字符 c 是一个新字符，parent tree 上根节点多一个儿子：只有位置 c 的 endpos 集合</p></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!p) fa[np] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><p>那么如果有一个祖先 p 已经有了 c 儿子，设它为 q</p>
<p>说明旧串有子串的结尾是 c 字符，那么就要看这个 q 的 len 了</p>
<ul>
<li><p><span class="math inline">\(len[q]=len[p]+1\)</span></p>
<p>说明 q 在插入时 p 就是最后一个节点了</p>
<p>那么根到 q 点表示的子串都是根到 np 表示的子串的后缀</p>
<p>在 parent tree 上，q 是 np 的父亲</p></li>
<li><p><span class="math inline">\(len[q]&gt;len[p]+1\)</span></p>
<p>在 parent tree 上，q 和 np 是兄弟</p>
<p>那么就新建一个 nq （复制一份 q ）作为它俩的父亲</p>
<p>将之前 p 及其祖先指向 q 的 c 儿子全指向 nq 即可</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> q = ch[p][c];</span><br><span class="line"><span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>)</span><br><span class="line">    fa[np] = q;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> nq = ++cnt;</span><br><span class="line">    <span class="built_in">memcpy</span>(ch[nq], ch[q], <span class="keyword">sizeof</span> ch[q]);</span><br><span class="line">    len[nq] = len[p] + <span class="number">1</span>;</span><br><span class="line">    fa[nq] = fa[q], fa[q] = fa[np] = nq;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; ch[p][c] == q)</span><br><span class="line">        ch[p][c] = nq, p = fa[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="code">code</h2>
<p>完整构造代码，看起来一堆 <code>while</code> 却是<span class="math inline">\(O(n)\)</span>。</p>
<p>注意点数是 <span class="math inline">\(2n\)</span> 规模。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Suffix_Automaton</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> cnt, last;</span><br><span class="line">    <span class="keyword">int</span> fa[N&lt;&lt;<span class="number">1</span>], ch[N&lt;&lt;<span class="number">1</span>][<span class="number">30</span>], len[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="title">Suffix_Automaton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        last = cnt = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = last, np = last = ++cnt;</span><br><span class="line">        len[np] = len[p] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; !ch[p][c])</span><br><span class="line">            ch[p][c] = np, p = fa[p];</span><br><span class="line">        <span class="keyword">if</span> (!p) fa[np] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> q = ch[p][c];</span><br><span class="line">            <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>)</span><br><span class="line">                fa[np] = q;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> nq = ++cnt;</span><br><span class="line">                <span class="built_in">memcpy</span>(ch[nq], ch[q], <span class="keyword">sizeof</span> ch[q]);</span><br><span class="line">                len[nq] = len[p] + <span class="number">1</span>;</span><br><span class="line">                fa[nq] = fa[q], fa[q] = fa[np] = nq;</span><br><span class="line">                <span class="keyword">while</span> (p &amp;&amp; ch[p][c] == q)</span><br><span class="line">                    ch[p][c] = nq, p = fa[p];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; SAM;</span><br></pre></td></tr></table></figure>
<h2 id="应用">应用</h2>
<ul>
<li><p>判断子串</p>
<p>直接在 SAM 上跑，跑完没到 NULL 即为子串</p></li>
<li><p>求不同子串个数</p>
<p>设 <span class="math inline">\(f[i]\)</span> 为从 i 点出发的子串， <span class="math inline">\(f[i]=\sum_{(i,j)\in Edge}{f[j]+1}\)</span></p>
<p>好像还可以直接求 <span class="math inline">\(\sum{(len[i]-len[fa[i]])}\)</span> ，因为 SAM上无重复子串</p></li>
<li><p>待更~</p></li>
</ul>
<h2 id="题目">题目</h2>
<p>BANANA 由于过菜，还不会写几道题~</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P3804">P3804 【模板】后缀自动机 (SAM)</a></li>
</ul>
<blockquote>
<p>求出 <em>S</em> 的所有出现次数不为 1 的子串的出现次数乘上该子串长度的最大值</p>
</blockquote>
<p>一个子串的出现次数即在 parent tree 上该子树的 size</p>
<p>暴力建出 parent tree，或者拓扑一下 DAG ，统计</p>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P4070">P4070 [SDOI2016]生成魔咒</a></li>
</ul>
<blockquote>
<p>每次向后插入一个字符，并求每次操作后不同子串个数</p>
</blockquote>
<p>显然 SAM 应用在求不同子串个数 <span class="math inline">\(\sum{(len[i]-len[fa[i]])}\)</span></p>
<p>每次只增加一个 len 影响总个数的节点，<code>ans += len[x] - len[fa[x]]</code>，于是每次 <span class="math inline">\(O(1)\)</span> 统计答案</p>
<p>大坑：“字符”范围 1e9 ，每个节点要用 map 存儿子</p>
<ul>
<li>待更~</li>
</ul>
]]></content>
      <categories>
        <category>总结</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 SA</title>
    <url>/2020/02/13/2020-02-13-%E6%9D%BF%E5%AD%90-SA/</url>
    <content><![CDATA[<p>先贴个板子，总结有时间在再说</p>
<a id="more"></a>
<h2 id="基数排序">基数排序</h2>
<p><span class="math inline">\(O(n)\)</span> 的排序是不是很诱人，桶排改进而已</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">qsort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        tax[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        ++tax[rnk[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        tax[i] += tax[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i)</span><br><span class="line">        sa[tax[rnk[tp[i]]]--] = tp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后缀排序">后缀排序</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_SA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        rnk[i] = s[i], tp[i] = i;</span><br><span class="line">    m = <span class="number">127</span>, qsort();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">1</span>, p = <span class="number">0</span>; w &lt;= n &amp;&amp; p &lt; n; m = p, w &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - w + <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            tp[++p] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (sa[i] &gt; w)</span><br><span class="line">                tp[++p] = sa[i] - w;</span><br><span class="line">        qsort();</span><br><span class="line">        swap(rnk, tp);</span><br><span class="line">        rnk[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">            rnk[sa[i]] = (tp[sa[i]] == tp[sa[i<span class="number">-1</span>]] &amp;&amp; tp[sa[i]+w] == tp[sa[i<span class="number">-1</span>]+w]) ? p : ++p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="求-height-数组">求 height 数组</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_height</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, k = <span class="number">0</span>, j; i &lt;= n; ++i) &#123;</span><br><span class="line">        k = max(<span class="number">0</span>, k - <span class="number">1</span>), j = sa[rnk[i]<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">while</span> (s[i+k] == s[j+k])</span><br><span class="line">            k++;</span><br><span class="line">        ht[rnk[i]] = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>SA</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P1966 火柴排队</title>
    <url>/2020/02/14/2020-02-14-%E9%A2%98%E8%A7%A3-P1966-%E7%81%AB%E6%9F%B4%E6%8E%92%E9%98%9F/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1966">题面</a></p>
<blockquote>
<p>两个数列 <span class="math inline">\(a,b\)</span>，求最少相邻两数交换多少次使得 <span class="math inline">\(\sum_{i=1}^n{(a_i-b_i)^2}\)</span> 最小</p>
</blockquote>
<a id="more"></a>
<h2 id="思路">思路</h2>
<p>先来简单地变换一下式子（见到这种狗式子一定要拆）： <span class="math display">\[
\sum{(a_i-b_i)^2}=\sum(a_i^2+b_i^2-2a_ib_i)
\]</span> <span class="math inline">\(\sum(a_i^2+b_i^2)\)</span> 是不变的，所以要最大化 <span class="math inline">\(\sum{a_ib_i}\)</span></p>
<p>所以要让 <span class="math inline">\(a,b\)</span> 中排名第 k 的两个数在同一位置上</p>
<p>为啥？<del>一点也不严谨的口胡</del>证明：</p>
<blockquote>
<p>假设有四个数 <span class="math inline">\(x_1,x_2,y_1,y_2\)</span>，且 <span class="math inline">\(x_1&lt;x_2,y_1&lt;y_2\)</span></p>
<p>那么 <span class="math inline">\(x_1y_1+x_2y_2&gt;x_1y_2+x_2y_1\)</span>，<del>这很显然吧</del></p>
<p>也就是说 <span class="math inline">\(a,b\)</span> 中最大两数乘积、次大两数乘积……的和是最大的</p>
</blockquote>
<p>然后怎么做？</p>
<p>让排名为 k 的 <span class="math inline">\(a_i,b_j\)</span> 两数在同一位置上，就是让 <span class="math inline">\(b_j\)</span> 到位置 <span class="math inline">\(i\)</span> 上</p>
<p>令 <span class="math inline">\(b_j=i\)</span>，再将 <span class="math inline">\(b\)</span> 数组排序，<span class="math inline">\(b_j\)</span> 自然到位置 <span class="math inline">\(i\)</span> 上了</p>
<p>是相邻两数交换来排序的话，最少次数就是此时 <span class="math inline">\(b\)</span> 的逆序对数（挺好证吧）</p>
<p>直接上树状数组或者归并</p>
<h2 id="code">code</h2>
<p>出题人还算良心，同一数列中两两各不相同，少了许多细节</p>
<p><a href="https://www.luogu.com.cn/record/30589508">评测记录</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;<span class="comment">/* fast read */</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">99999997</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ans;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N], tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 离散化</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">lsh</span><span class="params">(<span class="keyword">int</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) tmp[i] = t[i];</span><br><span class="line">    sort(tmp+<span class="number">1</span>, tmp+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> tot = unique(tmp+<span class="number">1</span>, tmp+n+<span class="number">1</span>) - tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        t[i] = lower_bound(tmp+<span class="number">1</span>, tmp+tot+<span class="number">1</span>, t[i]) - tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树状数组，用于求逆序对</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bit_Tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> tr[N];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x &lt;= n) </span><br><span class="line">            tr[x] += k, x += lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> re = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x) </span><br><span class="line">            re += tr[x], x -= lowbit(x);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; tr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(b[i]);</span><br><span class="line">    <span class="comment">// 离散化，同时也是得到每个数的排名</span></span><br><span class="line">    lsh(a), lsh(b);</span><br><span class="line">    <span class="comment">// 让 b 数列每个元素得到 a 中同一排名元素的坐标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        tmp[a[i]] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        b[i] = tmp[b[i]];</span><br><span class="line">    <span class="comment">// 统计答案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 每次加入一个数增加逆序对数：原个数 - 小于它的元素个数</span></span><br><span class="line">        ans = (ans + i - <span class="number">1</span> - tr.query(b[i])) % MOD;</span><br><span class="line">        tr.add(b[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2831 愤怒的小鸟</title>
    <url>/2020/02/14/2020-02-14-%E9%A2%98%E8%A7%A3-P2831-%E6%84%A4%E6%80%92%E7%9A%84%E5%B0%8F%E9%B8%9F/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2831">题面</a></p>
<blockquote>
<p>在坐标系第一象限有一些点，用一些经过原点、开口向下的抛物线 <span class="math inline">\(y=ax^2+bx\)</span> 覆盖所有点，最少需要多少条</p>
</blockquote>
<a id="more"></a>
<h2 id="思路">思路</h2>
<p>注意到 <span class="math inline">\(n\le 18\)</span>，基本上是状压 DP</p>
<h3 id="初始做法">初始做法</h3>
<p>考虑压缩点的覆盖状态，设 <span class="math inline">\(f[S]\)</span> 表示集合 <span class="math inline">\(S\)</span> 被覆盖需要最少的抛物线数</p>
<p>每两个点确定一条抛物线（经过原点），预处理每条抛物线 <span class="math inline">\(line_{i,j}\)</span> 能覆盖的点集合</p>
<p>不难得出转移方程： <span class="math display">\[
f[S\cup line_{i,j}]=f[S]+1\\
f[S\cup i]=f[S]+1
\]</span> 那么 <span class="math inline">\(O(2^n)\)</span> 枚举集合状态，再每个状态 <span class="math inline">\(O(n^2)\)</span> 枚举抛物线转移，复杂度 <span class="math inline">\(O(Tn^2 2^n)\)</span></p>
<p>估算一下，计算量在 4e8 级别，不一定过</p>
<h3 id="优化">优化</h3>
<p>在每个状态 <span class="math inline">\(S\)</span>，转移后至少覆盖一个点</p>
<p>从 i 出发枚举抛物线转移和从 j 出发枚举的顺序先后没有关系</p>
<p>先覆盖 i，和覆盖 j 后再覆盖 i，是一样的（如果 j 出发的抛物线能覆盖 i，从 i 出发也一定能覆盖 j）</p>
<p>于是每个状态我只从一个点出发枚举抛物线，复杂度降到 <span class="math inline">\(O(Tn2^n)\)</span>，稳过</p>
<p>要预处理每个状态最小的未覆盖的点是哪个</p>
<h3 id="提示">提示</h3>
<p>从两个点的坐标 <span class="math inline">\((x_1,y_1),(x_2,y_2)\)</span> 算出抛物线参数 <span class="math inline">\(a,b\)</span>，要推一下公式：</p>
<p>解 <span class="math inline">\(a\)</span>： <span class="math display">\[
\begin{cases}
    y_1=ax_1^2+bx_1\\
    y_2=ax_2^2+bx_2
\end{cases}\\
\begin{cases}
    \frac{y_1}{x_1}=ax_1+b\\
    \frac{y_2}{x_2}=ax_2+b
\end{cases}\\
a(x_1-x_2)=\frac{y_1}{x_1}-\frac{y_2}{x_2}\\
a=\frac{x_2y_1-x_1y_2}{x_1x_2(x_1-x_2)}
\]</span> 解 <span class="math inline">\(b\)</span>： <span class="math display">\[
\begin{cases}
    y_1=ax_1^2+bx_1\\
    y_2=ax_2^2+bx_2
\end{cases}\\
\begin{cases}
    \frac{y_1}{x_1^2}=a+\frac{b}{x_1}\\
    \frac{y_2}{x_2^2}=a+\frac{b}{x_2}
\end{cases}\\
b(\frac{1}{x_1}-\frac{1}{x_2})=\frac{y_1}{x_1^2}-\frac{y_2}{x_2^2}\\
b=\frac{x_1^2y_2-x_2^2y_1}{x_1x_2(x_1-x_2)}
\]</span></p>
<h2 id="code">code</h2>
<p><a href="https://www.luogu.com.cn/record/30577051">提交记录</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;<span class="comment">/* fast read */</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = (<span class="number">1</span> &lt;&lt; <span class="number">18</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装了抛物线，便于比较</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> a, b;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> ==(Line &amp;t) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fabs</span>(a - t.a) &lt;= eps &amp;&amp; <span class="built_in">fabs</span>(b - t.b) &lt;= eps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, m, maxn;</span><br><span class="line"><span class="keyword">int</span> low[MAXN], line[N][N], f[MAXN];</span><br><span class="line"><span class="keyword">double</span> x[N], y[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由推导的公式算抛物线</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Line <span class="title">get_line</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Line)&#123;</span><br><span class="line">        (x[b] * y[a] - x[a] * y[b]) / (x[a] * x[b] * (x[a] - x[b])),</span><br><span class="line">        (x[a] * x[a] * y[b] - x[b] * x[b] * y[a]) / (x[a] * x[b] * (x[a] - x[b]))</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 预处理最小未覆盖的点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= MAXN; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)</span><br><span class="line">            <span class="keyword">if</span> ((i &amp; (<span class="number">1</span> &lt;&lt; j)) == <span class="number">0</span>) &#123;</span><br><span class="line">                low[i] = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    read(T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        read(n), read(m);</span><br><span class="line">        maxn = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>, &amp;x[i], &amp;y[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                line[i][j] = <span class="number">0</span>;<span class="comment">// 多测清空</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">fabs</span>(x[i] - x[j]) &gt;= eps) &#123;<span class="comment">// 横坐标相同则无解</span></span><br><span class="line">                    Line t = get_line(i, j);</span><br><span class="line">                    <span class="keyword">if</span> (t.a &gt; -eps) <span class="keyword">continue</span>;<span class="comment">// 解出来开口向上不算</span></span><br><span class="line">                    line[i][j] |= (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>)) | (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>));</span><br><span class="line">                    <span class="comment">// 寻找在同一抛物线上的点</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line">                        <span class="keyword">if</span> (k != i &amp;&amp; k != j &amp;&amp; get_line(i, k) == t)</span><br><span class="line">                            line[i][j] |= <span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxn; ++i) f[i] = INF;<span class="comment">// 清空qwq</span></span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = low[i], j = <span class="number">1</span> &lt;&lt; (x - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (x &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">            f[i|j] = min(f[i|j], f[i] + <span class="number">1</span>); <span class="comment">// 只覆盖一个点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">1</span>; y &lt;= n; ++y)</span><br><span class="line">                f[i|line[x][y]] = min(f[i|line[x][y]], f[i] + <span class="number">1</span>); <span class="comment">// 通过抛物线转移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[maxn]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2014 [CTSC1997]选课</title>
    <url>/2020/04/04/2020-04-04-%E9%A2%98%E8%A7%A3-P2014-CTSC1997%E9%80%89%E8%AF%BE/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2014">题目</a></p>
<blockquote>
<p>给一棵 n 个点的树，每个点有权值，选择一个点必须同时选择其父节点</p>
<p>求选 m 个点的最大权值和</p>
</blockquote>
<a id="more"></a>
<h2 id="思路">思路</h2>
<p><strong>树上背包问题</strong></p>
<p>选择 m 个点使其总价值最大，典型的背包问题</p>
<p>先设 <span class="math inline">\(f_{i,j}\)</span>，表示以 i 为根的子树中选择 j 个能够得到最大价值</p>
<p>再考虑树形dp的模型，要求一棵树的答案能够由其子树得到</p>
<p>把节点 u 看作背包枚举空间 j，把每个儿子 v 看做物品，枚举选择个数（重量）k，物品价值为 <span class="math inline">\(f_{v,k}\)</span></p>
<p>转移方程： <span class="math display">\[
\large f_{u,j}=f_{u,j-k}+f_{v,k}
\]</span> 注意是01背包，j 要倒序枚举</p>
<ul>
<li><p>如何保证选择一个点的同时选择其父节点？</p></li>
<li><p>赋初值 <span class="math inline">\(f_{u,1}=val_u\)</span>，手动模拟一下dp过程就懂了</p></li>
</ul>
<h2 id="code">code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">309</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> nxt, to;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, cnt_e;</span><br><span class="line"><span class="keyword">int</span> head[N], val[N], f[N][N];</span><br><span class="line">Edge e[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[++cnt_e] = (Edge)&#123;head[u], v&#125;, head[u] = cnt_e;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    f[u][<span class="number">1</span>] = val[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt) &#123;</span><br><span class="line">        v = e[i].to;</span><br><span class="line">        dp(v);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m + <span class="number">1</span>; j; --j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; j; ++k)</span><br><span class="line">                f[u][j] = max(f[u][j], f[u][j-k] + f[v][k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u; i &lt;= n; ++i)</span><br><span class="line">        read(u), add_edge(u, i), read(val[i]);</span><br><span class="line">    dp(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[<span class="number">0</span>][m+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P5664 Emiya 家今天的饭</title>
    <url>/2020/04/04/2020-04-04-%E9%A2%98%E8%A7%A3-P5664-Emiya-%E5%AE%B6%E4%BB%8A%E5%A4%A9%E7%9A%84%E9%A5%AD/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P5664">题目</a></p>
<blockquote>
<p>n 种烹饪方法，有 m 种食材，第 i 个方法的第 j 种食材有 <span class="math inline">\(a_{i,j}\)</span> 个</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>要求：</p>
<ul>
<li>至少要做一道菜</li>
<li>一种方法最多做一道菜</li>
<li>做 k 道菜，每种食材使用次数不超过 <span class="math inline">\(\lfloor\frac{k}{2}\rfloor\)</span> 次</li>
</ul>
<p>求总方案数 <span class="math inline">\(\pmod{998244353}\)</span></p>
</blockquote>
<h2 id="思路">思路</h2>
<p>明显的计数DP</p>
<p>第三个限制很讨厌，先不管它</p>
<p>我们可以用总方案数减去不合法的方案</p>
<p>因为题目背景让我叙述不方便，<strong>建议把“方法”和“食材”想象成行和列</strong></p>
<h3 id="总方案数">总方案数</h3>
<p>无视第三个条件时，只要考虑每个方法选或不选</p>
<p>设 <span class="math inline">\(s_i\)</span> 表示第 i 种方法的食材个数和，即 <span class="math inline">\(\sum_{k=1}^m{a_{i,k}}\)</span></p>
<p>设 <span class="math inline">\(g_{i,j}\)</span> 表示前 i 种方法选了 j 种的方案数 <span class="math display">\[
\large g_{i,j}=g_{i-1,j}+g_{i-1,j-1}\times s_i
\]</span> 此时总方案数为</p>
<p><span class="math display">\[
\sum_{i=1}^n{g_{n,i}}
\]</span></p>
<p>复杂度 <span class="math inline">\(O(n^2)\)</span></p>
<h3 id="不合格方案数">不合格方案数</h3>
<p>某种食材选择的个数超过的总菜数的一半即为不合格</p>
<p>因为<strong>最多只有一种食材</strong>的个数会超过一半</p>
<p>只要对于每一种食材 i，考虑第 i 种食材的个数与其它食材的个数关系</p>
<p>设 <span class="math inline">\(f_{j,x,y}\)</span> 表示前 j 种方法，食材 i 选了 x 个，其它选了 y 个 <span class="math display">\[
\large f_{j,x,y}=f_{j-1,x,y}+f_{j-1,x-1,y}\times a_{j,i}+f_{j-1,x,y-1}\times(s_j-a_{j,i})
\]</span> 每种食材dp一遍，复杂度 <span class="math inline">\(O(mn^3)\)</span>，需要<strong>降维</strong></p>
<p>又碰上这种套路：<strong>我们不需要知道 x，y 的具体数值，只需要知道他们的关系</strong></p>
<p>设 <span class="math inline">\(f_{j,k}\)</span> 表示前 j 种方法，食材 i 选的个数比其它的多 k 个 <span class="math display">\[
\large f_{j,k}=f_{j-1,k}+f_{j-1,k-1}\times a_{j,i}+f_{j-1,k+1}\times(s_j-a_{j,i})
\]</span> 这样复杂度就是 <span class="math inline">\(O(mn^2)\)</span> 了</p>
<p>总共不合法方案数为 <span class="math display">\[
\sum_{i=1}^n{f_{n,i}}
\]</span></p>
<h3 id="细节">细节</h3>
<p>DP <span class="math inline">\(f_{j,k}\)</span> 时，k 的范围为 -j ~ j，可能为<strong>负数</strong>，需要数组下标整体偏移 n，数组也要开 2n 倍</p>
<p>转移时 <code>g[i][j] = (g[i-1][j] + sum[i][0] * g[i-1][j-1]) % MOD;</code> 这么写爆 long long</p>
<p>要<strong>每个</strong>乘法前强制转 long long，或者直接全开 long long</p>
<h2 id="code">code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">109</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2009</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">LL ans;</span><br><span class="line">LL a[N][M], sum[N][M], f[N][N&lt;&lt;<span class="number">1</span>], g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            read(a[i][j]), sum[i][<span class="number">0</span>] = (sum[i][<span class="number">0</span>] + a[i][j]) % MOD;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            sum[i][j] = (sum[i][<span class="number">0</span>] - a[i][j] + MOD) % MOD;</span><br><span class="line">    </span><br><span class="line">    g[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        g[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            g[i][j] = (g[i<span class="number">-1</span>][j] + sum[i][<span class="number">0</span>] * g[i<span class="number">-1</span>][j<span class="number">-1</span>]) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">        f[<span class="number">0</span>][n] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = n - j; k &lt;= n + j; ++k)</span><br><span class="line">                f[j][k] = (f[j<span class="number">-1</span>][k] + a[j][i] * f[j<span class="number">-1</span>][k<span class="number">-1</span>] + sum[j][i] * f[j<span class="number">-1</span>][k+<span class="number">1</span>]) % MOD;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            ans = (ans + MOD - f[n][n+j]) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        ans = (ans + g[n][i]) % MOD;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>递推DP</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>总结 虚树</title>
    <url>/2020/04/06/2020-04-06-%E6%80%BB%E7%BB%93-%E8%99%9A%E6%A0%91/</url>
    <content><![CDATA[<p>某些树形dp的数据范围过大，有多次询问，每次询问选定关键点（关键点总和在 1e5~1e6 的范围）</p>
<p>例题：<a href="https://www.luogu.com.cn/problem/P2495">P2495 [SDOI2011]消耗战</a></p>
<a id="more"></a>
<p>此时会有很多点不需要参与dp，只要另外建出一棵包含有用点的虚树来</p>
<p><img src="https://s1.ax1x.com/2020/04/06/Gs98AI.png" /></p>
<p>有一种增量构造的方法，难写难记（几个月前写的还没调出来），所以我干脆只学本文这种方法</p>
<p>推荐 <a href="https://www.luogu.com.cn/blog/ShadowassIIXVIIIIV/solution-p2495">shadowice1984 的博客</a></p>
<h2 id="思路">思路</h2>
<p>我们只要掌握了一棵树的dfs序，就可以模拟整个dfs过程</p>
<p>对于关键点序列 a，dfs 一遍，求出每个点的 dfs 序（入栈和出栈的）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">    pu[u] = ++dfu;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span> ((v = e[i].to) != last) &#123;</span><br><span class="line">            dfs(v, u);</span><br><span class="line">    po[u] = ++dfu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将关键点按dfs序排序，相邻两个点取 LCA，加入 a 序列，再把树根 1 加入</p>
<p>注意开个 bool 数组<strong>去重</strong></p>
<p>最后把整个序列 a 复制一份，全部<strong>取负</strong>，加入序列</p>
<p>此时序列 a 中全是虚树节点，正数代表入栈点，负数代表出栈点</p>
<p>将 a 序列按照 dfs 序排序，cmp 中要区分出入栈：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; <span class="number">0</span> ? pu[x] : po[-x]) &lt; (y &gt; <span class="number">0</span> ? pu[y] : po[-y]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在整个虚树的 dfs 序已经知道了，如果是简单的树形dp甚至不需要建树，直接模拟 dfs 遍历：</p>
<p>开一个栈，遍历 a 序列，如果是正数即入栈，进行 dfs 递归前的操作</p>
<p>负数说明出栈，进行 dfs 递归完各个子树后的操作</p>
<p>如果要建树，“dfs”时对于每个父子关系建边就行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= tot; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] &gt; <span class="number">0</span>) stk[++top] = a[i];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        v = stk[top--], u = stk[top];</span><br><span class="line">        Add_edge(u, v), Add_edge(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意多次询问的一定要清空（在 a 序列上的点），不能用 <span class="math inline">\(O(n)\)</span> 的 memset</p>
<h2 id="code">code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> tot, top, cnt_e;</span><br><span class="line"><span class="keyword">int</span> a[N&lt;&lt;<span class="number">1</span>], stk[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">    pu[u] = ++dfu;</span><br><span class="line">    <span class="comment">// 预处理LCA用的deep,fa...</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span> ((v = e[i].to) != last) &#123;</span><br><span class="line">            dfs(v, u);</span><br><span class="line">    po[u] = ++dfu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; <span class="number">0</span> ? pu[x] : po[-x]) &lt; (y &gt; <span class="number">0</span> ? pu[y] : po[-y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build_tree</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    tot = top = cnt_e = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">        a[++tot] = <span class="built_in">array</span>[i], vis[a[tot]] = <span class="literal">true</span>;</span><br><span class="line">    sort(a+<span class="number">1</span>, a+tot+<span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, lca; i &lt; k; ++i) &#123;</span><br><span class="line">        lca = LCA(a[i], a[i+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (!vis[lca]) a[++tot] = lca, vis[lca] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!vis[<span class="number">1</span>]) a[++tot] = <span class="number">1</span>;</span><br><span class="line">    k = tot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">        a[++tot] = -a[i];</span><br><span class="line">    sort(a+<span class="number">1</span>, a+tot+<span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= tot; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; <span class="number">0</span>) stk[++top] = a[i];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            v = stk[top--], u = stk[top];</span><br><span class="line">            Add_edge(u, v), Add_edge(v, u);</span><br><span class="line">            vis[v] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="luogu-p2495-code">Luogu P2495 code</h2>
<p>顺便放上去</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TT&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(TT x, <span class="keyword">char</span> end = <span class="string">&#x27;\n&#x27;</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">25e4</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> nxt, to, val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, cnt_e, dfu;</span><br><span class="line"><span class="keyword">int</span> head[N], pu[N], po[N], fa[N][<span class="number">20</span>], deep[N], mn[N], a[N&lt;&lt;<span class="number">1</span>], stk[N];</span><br><span class="line">LL f[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line">Edge e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[++cnt_e] = (Edge)&#123;head[u], v, w&#125;, head[u] = cnt_e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">    pu[u] = ++dfu;</span><br><span class="line">    deep[u] = deep[last] + <span class="number">1</span>;</span><br><span class="line">    fa[u][<span class="number">0</span>] = last;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; <span class="number">1</span> &lt;&lt; i &lt;= deep[u]; ++i)</span><br><span class="line">        fa[u][i] = fa[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span> ((v = e[i].to) != last) &#123;</span><br><span class="line">            mn[v] = min(mn[u], e[i].val);</span><br><span class="line">            dfs(v, u);</span><br><span class="line">        &#125;</span><br><span class="line">    po[u] = ++dfu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deep[x] &lt; deep[y]) swap(x, y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> (deep[fa[x][i]] &gt;= deep[y])</span><br><span class="line">            x = fa[x][i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> (fa[x][i] != fa[y][i])</span><br><span class="line">            x = fa[x][i], y = fa[y][i];</span><br><span class="line">    <span class="keyword">return</span> x == y ? x : fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; <span class="number">0</span> ? pu[x] : po[-x]) &lt; (y &gt; <span class="number">0</span> ? pu[y] : po[-y]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, w; i &lt; n; ++i)</span><br><span class="line">        read(u), read(v), read(w), add_edge(u, v, w), add_edge(v, u, w);</span><br><span class="line">    mn[<span class="number">1</span>] = <span class="number">0x7fffffff</span>;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    read(m);</span><br><span class="line">    <span class="keyword">int</span> k, tot, top;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        tot = top = <span class="number">0</span>;</span><br><span class="line">        read(k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">            read(a[++tot]), vis[a[tot]] = <span class="literal">true</span>, f[a[tot]] = mn[a[tot]];</span><br><span class="line">        sort(a+<span class="number">1</span>, a+k+<span class="number">1</span>, cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, lca; i &lt; k; ++i)&#123;</span><br><span class="line">            lca = LCA(a[i], a[i+<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (!vis[lca]) a[++tot] = lca, vis[lca] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!vis[<span class="number">1</span>]) a[++tot] = <span class="number">1</span>;</span><br><span class="line">        k = tot;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">            a[++tot] = -a[i];</span><br><span class="line">        sort(a+<span class="number">1</span>, a+tot+<span class="number">1</span>, cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u; i &lt;= tot; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; <span class="number">0</span>) stk[++top] = a[i];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                u = stk[top--];</span><br><span class="line">                <span class="keyword">if</span> (u != <span class="number">1</span>)</span><br><span class="line">                    f[stk[top]] += min(f[u], (LL)mn[u]);</span><br><span class="line">                <span class="keyword">else</span> print(f[u]);</span><br><span class="line">                f[u] = vis[u] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>LCA</tag>
        <tag>虚树</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 快速乘</title>
    <url>/2020/08/02/2020-08-02-%E6%9D%BF%E5%AD%90-%E5%BF%AB%E9%80%9F%E4%B9%98/</url>
    <content><![CDATA[<p>对于<code>long long</code>范围下模意义的乘法，我们需要快速乘防止溢出</p>
<a id="more"></a>
<h2 id="ologn-快速乘"><span class="math inline">\(O(logn)\)</span> 快速乘</h2>
<p>类比快速幂</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">mul</span><span class="params">(LL a, LL b, LL p)</span> </span>&#123;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = (ans + a) % p;</span><br><span class="line">        a = (a + a) % p, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="o1-快速乘-1"><span class="math inline">\(O(1)\)</span> 快速乘 #1</h2>
<p>利用<code>long double</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">mul</span><span class="params">(LL a, LL b, LL p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a * b - (LL)((<span class="keyword">long</span> <span class="keyword">double</span>)a / p * b) * p + p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="o1-快速乘-2"><span class="math inline">\(O(1)\)</span> 快速乘 #2</h2>
<p>利用位运算</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">mul</span><span class="params">(LL a, LL b, LL p)</span> </span>&#123;</span><br><span class="line">    LL lf = a * (b &gt;&gt; <span class="number">25L</span>L) % p * (<span class="number">1L</span>L &lt;&lt; <span class="number">25</span>) % p;</span><br><span class="line">    LL rg = a * (b &amp; ((<span class="number">1L</span>L &lt;&lt; <span class="number">25</span>) - <span class="number">1</span>)) % p;</span><br><span class="line">    <span class="keyword">return</span> (lf + rg) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
        <category>Math</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P3527 [POI2011]MET-Meteors</title>
    <url>/2020/08/04/2020-08-04-%E9%A2%98%E8%A7%A3-P3527-POI2011MET-Meteors/</url>
    <content><![CDATA[<blockquote>
<p>有 n 个成员国。环形轨道被分为 m 份（第 m份和第 1 份相邻），第 i 份上有第 <span class="math inline">\(a_i\)</span> 个国家的太空站。有 k 场陨石雨，[l, r]的轨道区间加上 a。</p>
<p>第 i 个成员国希望能够收集 <span class="math inline">\(p_i\)</span> 单位的陨石样本。判断对于每个国家，它需要在第几次陨石雨之后，才能收集足够的陨石。</p>
<p><span class="math inline">\(n,m,k\le 3\times 10^5\)</span></p>
</blockquote>
<a id="more"></a>
<h2 id="思路">思路</h2>
<p>这类题可以想到用整体二分来解决。</p>
<h3 id="onlog2n-做法"><span class="math inline">\(O(nlog^2n)\)</span> 做法</h3>
<p>将 k 场陨石雨作为修改，n 个国家作为查询。</p>
<p>二分答案时间 mid，mid 之前的修改放左边，之后的修改放右边；mid 之前收集足够的国家放左边，否则放右边。</p>
<p>将陨石雨以差分形式修改，利用树状数组 <span class="math inline">\(O(logn)\)</span> 查询每段轨道在某一时间的陨石数，这样每个国家暴力查总陨石数，即可划分国家。</p>
<p>这样分治下去复杂度 <span class="math inline">\(O(nlog^2n)\)</span>，能过这道题</p>
<h3 id="onlogn-做法"><span class="math inline">\(O(nlogn)\)</span> 做法</h3>
<p>感谢 <a href="https://www.luogu.com.cn/blog/jiangly/p3527-poi2011met-meteors-ti-xie">jly 神仙的题解</a> 启发，这个思路太棒了。</p>
<p>同样是二分答案时间 mid，陨石雨作为询问（修改），但是要把 m 个轨道放进去和修改一块二分。</p>
<p>mid 之前的询问放左边，之后的放右边；mid 之前轨道所在国家收集足够的放左边，否则放右边。</p>
<p>二分之前将所有询问按位置排序，分治时可以通过 two-pointers 扫描轨道和询问，从而计算每个轨道的陨石数，每个点的查询 <span class="math inline">\(O(1)\)</span>，分治每层 <span class="math inline">\(O(n)\)</span>，成功降了一个 log。</p>
<h2 id="code">code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> RenaMoe &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TT&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(TT x, <span class="keyword">char</span> end = <span class="string">&#x27;\n&#x27;</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ask</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> pos, id;</span><br><span class="line">    LL a;</span><br><span class="line">    Ask() &#123;&#125;</span><br><span class="line">    Ask(<span class="keyword">int</span> _p, <span class="keyword">int</span> _i, LL _a) &#123;</span><br><span class="line">        pos = _p, id = _i, a = _a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Ask &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pos &lt; t.pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, cnt;</span><br><span class="line"><span class="keyword">int</span> o[N], p[N], s[N], s1[N], s2[N], ans[N];</span><br><span class="line">LL sum[N];</span><br><span class="line">Ask q[N&lt;&lt;<span class="number">1</span>], q1[N&lt;&lt;<span class="number">1</span>], q2[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// l,r答案时间；sl,sr轨道区间；ql,qr询问区间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> sl, <span class="keyword">int</span> sr, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sl &gt; sr || ql &gt; qr) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = sl; i &lt;= sr; ++i) sum[o[s[i]]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        LL qsum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = sl, j = ql; i &lt;= sr; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt;= qr &amp;&amp; q[j].pos &lt;= s[i])</span><br><span class="line">                qsum += q[j].a, j++;</span><br><span class="line">            <span class="keyword">if</span> (sum[o[s[i]]] &lt; p[o[s[i]]])</span><br><span class="line">                sum[o[s[i]]] += qsum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = sl; i &lt;= sr; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum[o[s[i]]] &gt;= p[o[s[i]]])</span><br><span class="line">                ans[o[s[i]]] = l;</span><br><span class="line">            <span class="keyword">else</span> ans[o[s[i]]] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, cq1 = <span class="number">0</span>, cq2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = ql; i &lt;= qr; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[i].id &lt;= mid) q1[++cq1] = q[i];</span><br><span class="line">        <span class="keyword">else</span> q2[++cq2] = q[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cq1; ++i) q[ql+i<span class="number">-1</span>] = q1[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cq2; ++i) q[ql+cq1+i<span class="number">-1</span>] = q2[i];</span><br><span class="line"></span><br><span class="line">    LL qsum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = sl, j = ql; i &lt;= sr; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; ql+cq1 &amp;&amp; q[j].pos &lt;= s[i])</span><br><span class="line">            qsum += q[j].a, j++;</span><br><span class="line">        <span class="keyword">if</span> (sum[o[s[i]]] &lt; p[o[s[i]]])</span><br><span class="line">            sum[o[s[i]]] += qsum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cs1 = <span class="number">0</span>, cs2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = sl; i &lt;= sr; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum[o[s[i]]] &gt;= p[o[s[i]]])</span><br><span class="line">            s1[++cs1] = s[i];</span><br><span class="line">        <span class="keyword">else</span> s2[++cs2] = s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cs1; ++i) s[sl+i<span class="number">-1</span>] = s1[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cs2; ++i) s[sl+cs1+i<span class="number">-1</span>] = s2[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = sl+cs1; i &lt;= sr; ++i)</span><br><span class="line">        p[o[s[i]]] -= sum[o[s[i]]], sum[o[s[i]]] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    solve(l, mid, sl, sl+cs1<span class="number">-1</span>, ql, ql+cq1<span class="number">-1</span>);</span><br><span class="line">    solve(mid+<span class="number">1</span>, r, sl+cs1, sr, ql+cq1, qr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) read(o[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(p[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) s[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ans[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> k, l, r;</span><br><span class="line">    LL a;</span><br><span class="line">    read(k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        read(l), read(r), read(a);</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= r) &#123;</span><br><span class="line">            q[++cnt] = Ask(l, i, a);</span><br><span class="line">            <span class="keyword">if</span> (r &lt; m) q[++cnt] = Ask(r+<span class="number">1</span>, i, -a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            q[++cnt] = Ask(<span class="number">1</span>, i, a);</span><br><span class="line">            <span class="keyword">if</span> (l &gt; r + <span class="number">1</span>) &#123;</span><br><span class="line">                q[++cnt] = Ask(r+<span class="number">1</span>, i, -a);</span><br><span class="line">                q[++cnt] = Ask(l, i, a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q+<span class="number">1</span>, q+cnt+<span class="number">1</span>);</span><br><span class="line">    solve(<span class="number">1</span>, k, <span class="number">1</span>, m, <span class="number">1</span>, cnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans[i] == <span class="number">-1</span>) <span class="built_in">puts</span>(<span class="string">&quot;NIE&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> print(ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RenaMoe::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<p>真的跑的飞快 &gt;_&lt;</p>
<p><img src="https://s1.ax1x.com/2020/08/05/ariBRK.png" /></p>
<p>jly 题解讲的不是很详细，我太菜了根本看不懂，这道题我做了一晚上+一早上qwq</p>
<p>空间要开 3 倍以上啊啊啊，只开了 2 倍的我 wa 了几个小时！</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>思想</category>
      </categories>
      <tags>
        <tag>CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P4027 [NOI2007]货币兑换</title>
    <url>/2020/08/05/2020-08-05-%E9%A2%98%E8%A7%A3-P4027-NOI2007%E8%B4%A7%E5%B8%81%E5%85%91%E6%8D%A2/</url>
    <content><![CDATA[<blockquote>
<p>有 A,B 两种金券，它们每天的价值都不同，在第 i 天时分别为 <span class="math inline">\(A_i,B_i\)</span>，你可以用手中的金券换取相应价值的钱，或用钱兑换相同价值的金券，但兑换到的两种金券的数量之比是一个定值，这个定值在第 i 天为 <span class="math inline">\(R_i\)</span>。</p>
<p>现给出 n 天中两种金券的价值，R，以及你初始时拥有的资金 S，求 n 天后你最多能有多少钱。</p>
</blockquote>
<a id="more"></a>
<p>我来做经典的CDQ维护凸包了qwq。</p>
<h2 id="思路">思路</h2>
<h3 id="dp">DP</h3>
<p>如果第 i 天卖出相对于第 j 天买入有利可图，那么肯定全部卖出。</p>
<p>考虑 DP，我们可以推出转移方程： <span class="math display">\[
f_i=\frac{f_jR_j}{A_jR_j+B_j}\times A_i + \frac{f_j}{A_jR_j+B_j}\times B_i
\]</span> 我们设 A,B 券分别买入的数量为 <span class="math inline">\(x_i=\frac{f_iR_i}{A_iR_i+B_i},y_i=\frac{f_i}{A_iR_i+B_i}\)</span> 。</p>
<p>得到：</p>
<p><span class="math display">\[
f_i=A_ix_j + B_iy_j\\
y_j=-\frac{A_i}{B_i}x_j+\frac{f_i}{B_j}
\]</span></p>
<p>啊这是个斜率优化欸，维护上凸包使得直线的 <span class="math inline">\(b=\frac{f_i}{B_j}\)</span> 最大。</p>
<p><del>我上来就单调队列线性时间内干过去。。。啊怎么不太对</del>。</p>
<p>发现斜率 <span class="math inline">\(-\frac{A_i}{B_i}\)</span> 不是单调的，需要手写平衡树维护凸包什么的。</p>
<p>这辈子不可能写这种东西的，虽然 cmd2001 学长有博客讲用 <a href="https://www.cnblogs.com/Cmd2001/p/8492492.html">STL set 维护动态凸包</a>。</p>
<p>于是我们来学习 CDQ 维护斜率优化凸包。</p>
<h3 id="cdq-维护斜率优化的凸包">CDQ 维护斜率优化的凸包</h3>
<p>CDQ 分治的话，要每次计算左半边对右半边的贡献。</p>
<p>可以让左区间按 <span class="math inline">\(x_i\)</span> 排序，保持右区间按斜率 <span class="math inline">\(k_i=\frac{A_i}{B_i}\)</span> 单调递增有序。</p>
<p>左区间就可以通过栈维护一个斜率单调递减的凸包来更新右区间的答案。</p>
<p>每一层分治就这么 <span class="math inline">\(O(n)\)</span> 解决，总复杂度 <span class="math inline">\(O(nlogn)\)</span>。</p>
<h2 id="code">code</h2>
<p><a href="https://www.luogu.com.cn/record/36384478">提交记录</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> RenaMoe &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(TT &amp;x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps = <span class="number">1e-7</span>;<span class="comment">// 注意精度误差</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> INF = <span class="number">1e8</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ask</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> k, x, y, a, b, r;<span class="comment">// 分别表示：斜率,x,y,A,B,R</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, s;</span><br><span class="line"><span class="keyword">int</span> stk[N];</span><br><span class="line">Ask q[N], tmp[N];</span><br><span class="line"><span class="keyword">double</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Ask &amp;x, <span class="keyword">const</span> Ask &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.k &lt; y.k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求斜率</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">get_slope</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(q[i].x - q[j].x) &lt;= Eps) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> (q[i].y - q[j].y) / (q[i].x - q[j].x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="comment">// 此时1~l-1的答案都已经处理完，更新f[l]</span></span><br><span class="line">        f[l] = max(f[l], f[l<span class="number">-1</span>]);</span><br><span class="line">        q[l].y = f[l] / (q[l].a * q[l].r + q[l].b), q[l].x = q[l].y * q[l].r;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按id划分左右区间</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, q1 = l, q2 = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[i].id &lt;= mid) tmp[q1++] = q[i];</span><br><span class="line">        <span class="keyword">else</span> tmp[q2++] = q[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) q[i] = tmp[i];</span><br><span class="line">    <span class="comment">// 先处理左区间</span></span><br><span class="line">    solve(l, mid);</span><br><span class="line">    <span class="comment">// 维护左区间斜率单调递减的凸包</span></span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= mid; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &gt;= <span class="number">2</span> &amp;&amp; get_slope(stk[top<span class="number">-1</span>], stk[top]) &lt; get_slope(stk[top], i) + Eps) top--;</span><br><span class="line">        stk[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用左区间的凸包更新右区间答案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid+<span class="number">1</span>; i &lt;= r; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &gt;= <span class="number">2</span> &amp;&amp; get_slope(stk[top<span class="number">-1</span>], stk[top]) &lt;= q[i].k + Eps) top--;</span><br><span class="line">        <span class="keyword">int</span> j = stk[top];</span><br><span class="line">        f[q[i].id] = max(f[q[i].id], q[i].a * q[j].x + q[i].b * q[j].y);<span class="comment">// 注意是q[i].id，不是i</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理右区间</span></span><br><span class="line">    solve(mid+<span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">// 按x单调递增归并排序，以作为上一层的左区间</span></span><br><span class="line">    q1 = l, q2 = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q1 &lt;= mid &amp;&amp; (q2 &gt; r || q[q1].x &lt; q[q2].x + Eps)) tmp[i] = q[q1++];</span><br><span class="line">        <span class="keyword">else</span> tmp[i] = q[q2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) q[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf%lf&quot;</span>, &amp;q[i].a, &amp;q[i].b, &amp;q[i].r);</span><br><span class="line">        q[i].k = -(q[i].a / q[i].b), q[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(q+<span class="number">1</span>, q+n+<span class="number">1</span>, cmp);<span class="comment">// 先按斜率单调递增排序</span></span><br><span class="line">    f[<span class="number">0</span>] = s;</span><br><span class="line">    solve(<span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>, f[n]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RenaMoe::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>CDQ分治</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P6007 [USACO20JAN]Springboards G</title>
    <url>/2020/08/09/2020-08-09-%E9%A2%98%E8%A7%A3-P6007-USACO20JANSpringboards-G/</url>
    <content><![CDATA[<blockquote>
<p>N*N 的矩阵，从 (0,0) 走到 (N,N)，每次只能往右和往上走（求曼哈顿距离），有 P 个跳板可以从 <span class="math inline">\((x_1,y_1)\)</span> 无代价转移到 <span class="math inline">\((x_2,y_2)\)</span>，求需要行走的最少距离</p>
<p><span class="math inline">\(N\le10^9,P\le 10^5\)</span></p>
</blockquote>
<a id="more"></a>
<h2 id="思路">思路</h2>
<h3 id="问题转化">问题转化</h3>
<p><span class="math inline">\(O(N^2)\)</span> 和 <span class="math inline">\(O(P^2)\)</span> 的最短路都显然不行，我们可以观察一些性质并考虑 dp。</p>
<p>每次答案距离只能从左下方转移而来，即 <span class="math inline">\(f(x_1,y_1)\rightarrow f(x_2,y_2)\)</span> 满足 <span class="math inline">\(x1\le x_2,y1\le y_2\)</span>。</p>
<p>直接 dp 需要考虑不从跳板走的距离，正难则反，我们设 <span class="math inline">\(f(x,y)\)</span> 表示走到 <span class="math inline">\((x,y)\)</span> 能够省下的最大距离。</p>
<p>我们需要维护 <span class="math inline">\(x1\le x_2,y1\le y_2\)</span> 的最大 <span class="math inline">\(f(x_1,y_1)\)</span>，至此我们将问题转化成二维偏序。</p>
<h3 id="cdq">CDQ</h3>
<p>现在的问题是，每个跳板有两个端点：起点 <span class="math inline">\((x_1,y_1)\)</span> 和终点 <span class="math inline">\((x_2,y_2)\)</span>，并且只能从前一个终点转移到其右上方的一个起点。</p>
<p>我们可以把一个跳板拆成两个点，起点作为查询，终点作为修改。</p>
<p>接下来就是 CDQ 的套路：处理左区间，更新左区间对右区间的贡献，处理右区间，一定要保证分治的先后顺序正确。</p>
<p>复杂度 <span class="math inline">\(O(nlog^2n)\)</span>。</p>
<h3 id="细节">细节</h3>
<p>写完交上去一直 WA 一个点，还下不了数据急躁半天。</p>
<p>后来想到，可能会有某个跳板的终点的另一个跳板的起点重合，排序不当会处理不了。</p>
<p>可以输入时提前处理掉，或者排序时保证位置重合的修改在询问之前就行（具体见代码的 cmp 函数）。</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TT&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(TT &amp;x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x1, y1, x2, y2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, opt, id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, cnt;</span><br><span class="line"><span class="keyword">int</span> f[N], ans[N], len[N];</span><br><span class="line">Node a[N];</span><br><span class="line">Point p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc_dis</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x2 - x1 + y2 - y1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp_x</span><span class="params">(<span class="keyword">const</span> Point &amp;i, <span class="keyword">const</span> Point &amp;j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i.x == j.x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i.y == j.y) <span class="keyword">return</span> i.opt &gt; j.opt;<span class="comment">// 位置重合，让修改在前</span></span><br><span class="line">        <span class="keyword">return</span> i.y &lt; j.y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i.x &lt; j.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp_y</span><span class="params">(<span class="keyword">const</span> Point &amp;i, <span class="keyword">const</span> Point &amp;j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i.y == j.y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i.x == j.x) <span class="keyword">return</span> i.opt &gt; j.opt;</span><br><span class="line">        <span class="keyword">return</span> i.x &lt; j.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i.y &lt; j.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    CDQ(l, mid), sort(p+mid+<span class="number">1</span>, p+r+<span class="number">1</span>, cmp_y);</span><br><span class="line">    <span class="keyword">int</span> maxn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid+<span class="number">1</span>, j = l, k = <span class="number">-1</span>; i &lt;= r; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i].opt) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> id = p[i].id;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= mid &amp;&amp; p[j].y &lt;= p[i].y) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[j].opt)</span><br><span class="line">                maxn = max(maxn, ans[p[j].id]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[p[i].id] = max(ans[p[i].id], maxn + len[p[i].id]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(p+mid+<span class="number">1</span>, p+r+<span class="number">1</span>, cmp_x);</span><br><span class="line">    CDQ(mid+<span class="number">1</span>, r);</span><br><span class="line">    sort(p+l, p+r+<span class="number">1</span>, cmp_y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        read(a[i].x1), read(a[i].y1), read(a[i].x2), read(a[i].y2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        p[++cnt] = (Point)&#123;a[i].x1, a[i].y1, <span class="number">0</span>, i&#125;, p[++cnt] = (Point)&#123;a[i].x2, a[i].y2, <span class="number">1</span>, i&#125;;</span><br><span class="line">    p[++cnt] = (Point)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, p[++cnt] = (Point)&#123;n, n, <span class="number">0</span>, m+<span class="number">1</span>&#125;;</span><br><span class="line">    sort(p+<span class="number">1</span>, p+cnt+<span class="number">1</span>, cmp_x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        len[i] = calc_dis(a[i].x1, a[i].y1, a[i].x2, a[i].y2);</span><br><span class="line">    CDQ(<span class="number">1</span>, cnt);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n + n - ans[m+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title>总结 exBSGS</title>
    <url>/2020/08/15/2020-08-15-%E6%80%BB%E7%BB%93-exBSGS/</url>
    <content><![CDATA[<p>求解 <span class="math inline">\(a^x\equiv b\pmod p\)</span> 其中 p 不为质数情况的算法。</p>
<a id="more"></a>
<p>需要提前掌握 <a href="https://renamoe.gitee.io/2020/02/06/2020-02-06-%E6%80%BB%E7%BB%93-BSGS/">BSGS</a>。</p>
<p>模板题：<a href="https://www.luogu.com.cn/problem/P4195">Luogu P4195</a>。</p>
<h2 id="思路">思路</h2>
<p>p 不为质数时，我们需要让 <span class="math inline">\(\gcd(a, p)=1\)</span> 才能进行朴素 BSGS。</p>
<p>对于 <span class="math display">\[
a^x\equiv b\pmod p
\]</span> 设 <span class="math inline">\(d=\gcd(a,p)\)</span>， <span class="math display">\[
a^{x-1}\times a\equiv b \pmod p\\
a^{x-1}\times \frac{a}{d}\equiv \frac{b}{d} \pmod{\frac{p}{d}}\\
a^{x-1}\equiv \frac{\frac{b}{d}}{\frac{a}{d}}\pmod{\frac{p}{d}}
\]</span> 若 <span class="math inline">\(\gcd(a^{x-1},\frac{p}{d})\neq 1\)</span>，循环下去，直到 a,p 互质，进行朴素 BSGS 即可。</p>
<p>需要注意，若在过程中出现 <span class="math inline">\(d\not\mid b\)</span> 即无解。</p>
<p>另外，如果循环第 k 次时 <span class="math display">\[
a^{x-1}\equiv \frac{\frac{b}{d}}{\frac{a}{d}}\equiv 1\pmod{\frac{p}{d}}
\]</span> 此时 <span class="math inline">\(x-1=0\)</span>，最后答案为 k。</p>
<h2 id="实现">实现</h2>
<p>直接做的话，要求 <span class="math inline">\(\frac{a}{d}\)</span> 在模 <span class="math inline">\(\frac{p}{d}\)</span> 意义下的逆元，<span class="math inline">\(\frac{p}{d}\)</span> 不为质数，需要 exgcd 求逆元。</p>
<p>不写 exgcd 实现的话，设 <span class="math inline">\(c=\frac{a}{d}\)</span>，转化到 BSGS 中现在要求解 <span class="math inline">\(a^x\equiv \frac{b}{c}\pmod p\)</span>，将 c 乘到左边后做。</p>
<p>所以只要把 <span class="math inline">\(\frac{a}{d}\)</span> 传入 BSGS 就行。</p>
<h3 id="exbsgs-code">exBSGS code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">exBSGS</span><span class="params">(LL a, LL b, LL p)</span> </span>&#123;</span><br><span class="line">    a %= p, b %= p;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">1</span> || p == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 特判</span></span><br><span class="line">    LL d, cnt = <span class="number">0</span>, ad = <span class="number">1</span>; <span class="comment">// 分别是gcd(a,p)，循环次数，a/d</span></span><br><span class="line">    <span class="keyword">while</span> ((d = gcd(a, p)) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b % d) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        cnt++, b /= d, p /= d, ad = ad * a / d % p;</span><br><span class="line">        <span class="keyword">if</span> (ad == b) <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans = BSGS(a, b, p, ad);</span><br><span class="line">    <span class="keyword">return</span> ans == <span class="number">-1</span> ? <span class="number">-1</span> : ans + cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="luogu-p4195-code">luogu P4195 code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> RenaMoe &#123;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;LL, LL&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">power</span><span class="params">(LL a, LL b, LL p)</span> </span>&#123;</span><br><span class="line">    LL ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = ans * a % p;</span><br><span class="line">        a = a * a % p, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">BSGS</span><span class="params">(LL a, LL b, LL p, LL ad)</span> </span>&#123;</span><br><span class="line">    mp.clear();</span><br><span class="line">    b %= p;</span><br><span class="line">    <span class="keyword">if</span> (a % p == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL t = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(p)), an = b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= t; ++i)</span><br><span class="line">        mp[an] = i, an = an * a % p;</span><br><span class="line">    a = power(a, t, p), an = ad;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j; i &lt;= t; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mp.count(an)) &#123;</span><br><span class="line">            j = mp[an];</span><br><span class="line">            <span class="keyword">if</span> (i * t - j &gt;= <span class="number">0</span>) <span class="keyword">return</span> i * t - j;</span><br><span class="line">        &#125;</span><br><span class="line">        an = an * a % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL x, LL y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y ? gcd(y, x % y) : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">exBSGS</span><span class="params">(LL a, LL b, LL p)</span> </span>&#123;</span><br><span class="line">    a %= p, b %= p;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">1</span> || p == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    LL d, cnt = <span class="number">0</span>, ad = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((d = gcd(a, p)) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b % d) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        cnt++, b /= d, p /= d, ad = ad * a / d % p;</span><br><span class="line">        <span class="keyword">if</span> (ad == b) <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans = BSGS(a, b, p, ad);</span><br><span class="line">    <span class="keyword">return</span> ans == <span class="number">-1</span> ? <span class="number">-1</span> : ans + cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LL a, p, b;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        read(a), read(p), read(b);</span><br><span class="line">        <span class="keyword">if</span> (!a &amp;&amp; !b &amp;&amp; !p) <span class="keyword">break</span>;</span><br><span class="line">        LL ans = exBSGS(a, b, p);</span><br><span class="line">        <span class="keyword">if</span> (ans == <span class="number">-1</span>) <span class="built_in">puts</span>(<span class="string">&quot;No Solution&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RenaMoe::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Math</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>BSGS</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 CRT &amp; exCRT</title>
    <url>/2020/08/15/2020-08-15-%E6%9D%BF%E5%AD%90-CRT-exCRT/</url>
    <content><![CDATA[<p>大概写写中国剩余定理的公式和扩展中国剩余定理板子。</p>
<a id="more"></a>
<h2 id="中国剩余定理-crt">中国剩余定理 CRT</h2>
<p>对于一元线性同余方程组： <span class="math display">\[
\begin{cases}
    x\equiv a_1\pmod{m_1}\\
    x\equiv a_2\pmod{m_2}\\
    ……\\
    x\equiv a_n\pmod{m_n}
\end{cases}
\]</span> x 的最小非负整数解，其中 <span class="math inline">\(m_i\)</span> 两两互质。</p>
<p>该方程组的通解为： <span class="math display">\[
\begin{aligned}
M&amp;=\prod_{i=1}^nm_i\\
M_i&amp;=\frac{M}{m_i}\\
t_i&amp;\equiv M_i^{-1}\pmod{m_i}\\
x&amp;\equiv \sum_{i=1}^n{a_it_iM_i\pmod M}
\end{aligned}
\]</span></p>
<p>x 最小的话，<span class="math inline">\(t_i\)</span> 最小，要在用 exgcd 求解 <span class="math inline">\(M_i^{-1}\)</span> 时保证 <span class="math inline">\(t_i\)</span> 最小。</p>
<h2 id="扩展中国剩余定理-excrt">扩展中国剩余定理 exCRT</h2>
<p>同样是一元线性同余方程组，不过 <span class="math inline">\(m_i\)</span> 不再两两互质了。</p>
<p>考虑将方程两两合并。</p>
<p><span class="math display">\[
\begin{cases}
x\equiv a\pmod{m}\\
x\equiv A\pmod{M}
\end{cases}
\]</span> 即 <span class="math display">\[
\begin{cases}
x=my+a\\
x=MY+A
\end{cases}
\]</span> <span class="math display">\[
\begin{aligned}
my+a&amp;=MY+A\\
my-MY&amp;=A-a
\end{aligned}
\]</span> 通过 exgcd 求出 y 关于 <span class="math inline">\(my+M(-Y)=\gcd(m,M)\)</span> 的解 <span class="math inline">\(y_0\)</span>，那么 y 的特定解为 <span class="math inline">\(y_0\times\frac{A-a}{\gcd(n,M)}\)</span>。</p>
<p>因为要最小化 x，所以要最小化 y。</p>
<p>y 在 exgcd 中通解为 <span class="math inline">\(y_0+\frac{M}{\gcd(m,M)}\)</span>，所以要最小值为 <span class="math display">\[
y=y_0\times\frac{A-a}{\gcd(n,M)}\bmod \frac{M}{\gcd(m,M)}
\]</span></p>
<p>两个同余方程合并为 <span class="math display">\[
x\equiv my+a\pmod{\operatorname{lcm}(m,M)}
\]</span></p>
<h3 id="excrt-code">exCRT code</h3>
<p>模板题 <a href="https://www.luogu.com.cn/problem/P4777">Luogu P4777</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">exCRT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ai 为 a，bi 为 m</span></span><br><span class="line">    LL ans = ai[<span class="number">1</span>], mod = bi[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        LL g, x, y, bg, a = ai[i], b = bi[i], c;</span><br><span class="line">        exgcd(mod, b, x, y, g);</span><br><span class="line">        c = (a - ans % b + b);</span><br><span class="line">        <span class="keyword">if</span> (c % g) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        x = mul(x, c/g, b/g); <span class="comment">// 防爆long long的快速乘</span></span><br><span class="line">        ans += x * mod;</span><br><span class="line">        mod = lcm(mod, b);</span><br><span class="line">        ans = (ans % mod + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Math</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>CRT</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 GarsiaWachs算法</title>
    <url>/2020/08/18/2020-08-18-%E6%9D%BF%E5%AD%90-GarsiaWachs%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>专门用来解决石子合并问题的算法。</p>
<a id="more"></a>
<p><a href="https://www.luogu.com.cn/problem/P5569">P5569 「SDOI2008」石子合并</a></p>
<p>数据范围：<span class="math inline">\(n\le 4\times 10^4\)</span>。</p>
<h2 id="做法">做法</h2>
<ul>
<li>找到最小的 i 满足 <span class="math inline">\(a_{i-1}&lt;a_{i+1}\)</span></li>
<li>合并 <span class="math inline">\(a_{i-1},a_i\)</span></li>
<li>找到最大的 j 满足 <span class="math inline">\(j &lt; k\)</span> 并且 <span class="math inline">\(a_j &gt; a_{i-1} + a_i\)</span></li>
<li>将 i-1,i 合并后的石子插入到 j 后面</li>
</ul>
<p>通过 vector 模拟，直到合并为一个元素。</p>
<p>注意处理边界 <span class="math inline">\(a_0=a_{n+1}=\infty\)</span>。</p>
<p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>，需要开 O2 才能过 qwq。</p>
<p>证明见 <a href="https://eastern.blog.luogu.org/post-ti-xie-garsiawachs-suan-fa">Eastern 的博客</a>。</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> RenaMoe &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(TT &amp;x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ans;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    a.push_back(INF);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; ++i)</span><br><span class="line">        read(x), a.push_back(x);</span><br><span class="line">    a.push_back(INF);</span><br><span class="line">    <span class="keyword">int</span> i, j, sum;</span><br><span class="line">    <span class="keyword">while</span> (n-- &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (a[i<span class="number">-1</span>] &lt; a[i+<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        sum = a[i<span class="number">-1</span>] + a[i];</span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; ~j; --j)</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; sum)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        a.erase(a.begin() + i - <span class="number">1</span>);</span><br><span class="line">        a.erase(a.begin() + i - <span class="number">1</span>);</span><br><span class="line">        a.insert(a.begin() + j + <span class="number">1</span>, sum);</span><br><span class="line">        ans += sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RenaMoe::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 LOJ#6500 「雅礼集训 2018 Day2」操作</title>
    <url>/2020/08/18/2020-08-18-%E9%A2%98%E8%A7%A3-LOJ-6500/</url>
    <content><![CDATA[<blockquote>
<p>给出一串 01 序列和正整数 k，一次操作将长度为 k 的子区间取反，m 次询问一个区间内全部变为 0 的最小操作次数，不可能完成输出 -1。</p>
<p><span class="math inline">\(1\le n\le 2\times 10^6,1\le m\le 5\times 10^5\)</span></p>
</blockquote>
<a id="more"></a>
<p>很考验问题转化的题。</p>
<h2 id="思路">思路</h2>
<h3 id="暴力">暴力</h3>
<p>原题 <span class="math inline">\(O(n^2)\)</span> 暴力有 30 分，翻转策略是从左向右扫，遇到 1 就将以它为左端点且长为 k 的区间取反。</p>
<p>至于正确性，显然该位左侧的点不能再被取反。</p>
<p>运用差分（异或意义下）可以将区间取反降到 <span class="math inline">\(O(1)\)</span>。</p>
<h3 id="正解">正解</h3>
<p>观察差分序列，我们暴力中每次会把距离为 k 的两个点取反。</p>
<p>我们将询问区间提取出来，左右侧加上 0，再差分，观察：</p>
<blockquote>
<p>原序列：0100011010</p>
<p>提取 [7, 9]：0 101 0</p>
<p>差分：01111</p>
</blockquote>
<p>当 k 为 2 时，该例需要两步（即[7,8]、[8,9]）。</p>
<p>问题转化成在这样的差分序列中，每次将距离为 k 的两个点取反，需要的最小操作次数。</p>
<h4 id="判断有解">判断有解</h4>
<p>可以得到，只有在编号模 k 值相同的位置中，1 的个数为偶数个，问题有解。</p>
<p>可以用<strong>哈希</strong> <span class="math inline">\(O(1)\)</span> 判断是否有解：</p>
<p>对编号模 k 值相同的位置赋一个 hash 值，然后对所有 1 做前缀异或和。</p>
<p>因为异或的性质，某个 hash 值有偶数个，异或起来为 0。</p>
<p>那么提取区间异或和即可判断是否有解。</p>
<h4 id="计算答案">计算答案</h4>
<p>现在要计算最小操作次数，易得我们需要将编号模 k 值相同的位置中，所有的 1 相邻两两配对。</p>
<p>答案就是每对位置差除以 k。</p>
<p>我们还是对这些答案做<strong>前缀和</strong>，以便 <span class="math inline">\(O(1)\)</span> 查询。</p>
<p>需要注意的是，两两配对的点中，做前缀和的话，如果有偶数个点那么恰好为答案；如果有奇数个点，要考虑到两个前缀和做差形成偶数个点的情况。</p>
<p>具体实现看预处理代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b[] 模k值相同的位置的前缀答案</span></span><br><span class="line"><span class="comment">// sum[] 所有位置的前缀答案</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    sum[i] = sum[i<span class="number">-1</span>];</span><br><span class="line">    hsum[i] = hsum[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span> (a[i] ^ a[i<span class="number">-1</span>]) &#123;</span><br><span class="line">        hsum[i] ^= hash[i%k];</span><br><span class="line">        <span class="comment">// 以下是重点</span></span><br><span class="line">        sum[i] -= b[i%k];</span><br><span class="line">        b[i%k] = i / k - b[i%k];</span><br><span class="line">        sum[i] += b[i%k];</span><br><span class="line">        <span class="comment">// 如果有偶数个点，b[i%k]值为两两距离差除以k，即答案</span></span><br><span class="line">        <span class="comment">// 如果有奇数个点，b[i%k]值为i/k-原b[i%k]，即该位置减去之前的答案</span></span><br><span class="line">        <span class="comment">// 手模可以发现，这样子两个奇数点前缀和相减，配对情况恰好错开，值为新配对的答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里多记录两个值以便后续处理左右端点的影响</span></span><br><span class="line">    bb[i] = b[i%k];</span><br><span class="line">    br[i] = b[(i+<span class="number">1</span>)%k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="左右端点的影响">左右端点的影响</h4>
<p>因为提取区间要让区间左右侧为 0，前缀和中并没有考虑。</p>
<blockquote>
<p>原序列：0100011010</p>
<p>提取 [7, 9] 的差分：</p>
<p>000000 1111 0</p>
<p>原序列 [7,9] 差分：</p>
<p>011001 0111 0</p>
</blockquote>
<p>因为我们提取之后让区间左侧都变为 0，所以差分序列中第 7 位是不同的。</p>
<p>询问区间 <span class="math inline">\([l,r]\)</span> 中，如果 l 处原来为 1，那么提取后的差分序列中该处一定为 1；同理，r 处为 1，那么差分序列中 r+1 处一定为 1。</p>
<p>其它地方的差分和预处理的就一样了。</p>
<p>那么就先通过预处理的计算 <span class="math inline">\([l+1,r]\)</span> 的答案，再把端点的影响加进去。</p>
<p>因此预处理时要多记录当前答案状态，最后加入方法和预处理一样。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bb[] 预处理中第i位的答案</span></span><br><span class="line"><span class="comment">// br[] 预处理中第i+1位的答案</span></span><br><span class="line"><span class="keyword">int</span> ans = sum[r] - sum[l];</span><br><span class="line"><span class="keyword">int</span> h = hsum[r] ^ hsum[l];</span><br><span class="line"><span class="keyword">if</span> (a[l]) &#123;</span><br><span class="line">    ans += bb[l] * <span class="number">2</span> - l / k;</span><br><span class="line">    h ^= hash[l%k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[r]) &#123;</span><br><span class="line">    ans += (r + <span class="number">1</span>) / k - <span class="number">2</span> * br[r];</span><br><span class="line">    h ^= hash[(r+<span class="number">1</span>)%k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> RenaMoe &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(TT &amp;x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k, m;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N], bb[N], br[N], hash[N], hsum[N], sum[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    read(n), read(k), read(m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) </span><br><span class="line">        hash[i] = (rand() % <span class="number">32767</span> * <span class="number">100000</span>) + (rand() % <span class="number">32767</span>); <span class="comment">// 这是什么辣鸡random方法啊</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = s[i] == <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        sum[i] = sum[i<span class="number">-1</span>];</span><br><span class="line">        hsum[i] = hsum[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span> (a[i] ^ a[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            hsum[i] ^= hash[i%k];</span><br><span class="line">            sum[i] -= b[i%k];</span><br><span class="line">            b[i%k] = i / k - b[i%k];</span><br><span class="line">            sum[i] += b[i%k];</span><br><span class="line">        &#125;</span><br><span class="line">        bb[i] = b[i%k];</span><br><span class="line">        br[i] = b[(i+<span class="number">1</span>)%k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        read(l), read(r);</span><br><span class="line">        <span class="keyword">int</span> ans = sum[r] - sum[l];</span><br><span class="line">        <span class="keyword">int</span> h = hsum[r] ^ hsum[l];</span><br><span class="line">        <span class="keyword">if</span> (a[l]) &#123;</span><br><span class="line">            ans += bb[l] * <span class="number">2</span> - l / k;</span><br><span class="line">            h ^= hash[l%k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[r]) &#123;</span><br><span class="line">            ans += (r + <span class="number">1</span>) / k - <span class="number">2</span> * br[r];</span><br><span class="line">            h ^= hash[(r+<span class="number">1</span>)%k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, h ? <span class="number">-1</span> : ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RenaMoe::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>思想</category>
      </categories>
      <tags>
        <tag>差分/前缀和</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title>总结 计算几何基础</title>
    <url>/2020/08/22/2020-08-22-%E6%80%BB%E7%BB%93-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>记录一些计算几何相关的知识。</p>
<a id="more"></a>
<p>推荐学习资料：<a href="https://www.luogu.com.cn/blog/wjyyy/geometry1">wjyyy 的博客</a> 。</p>
<h2 id="向量">向量</h2>
<h3 id="模">模</h3>
<p>向量的长度，<span class="math inline">\(\vec{a}=(x,y),|\vec{a}|=\sqrt{x^2+y^2}\)</span>。</p>
<h3 id="加减">加减</h3>
<p>几何意义为两个向量 <span class="math inline">\(\vec{a},\vec{b}\)</span> （线段）首尾相接，<span class="math inline">\(\vec{a}\)</span> 的头指向 <span class="math inline">\(\vec{b}\)</span> 的尾即 <span class="math inline">\(\vec{a}+\vec{b}\)</span>。</p>
<p>对于 <span class="math inline">\(\vec{a}=(x_1,y_1),\vec{b}=(x_2,y_2)\)</span>，<span class="math inline">\(\vec{a}+\vec{b}=(x_1+y_1,x_2+y_2)\)</span>。</p>
<h3 id="数乘">数乘</h3>
<p>对向量缩放。对于 <span class="math inline">\(\vec{a}=(x,y)\)</span>，<span class="math inline">\(\lambda\vec{a}=(\lambda x,\lambda y)\)</span>。</p>
<h3 id="点积数量积内积">点积（数量积、内积）</h3>
<p>几何意义为向量 <span class="math inline">\(\vec{a}\)</span> 在向量 <span class="math inline">\(\vec{b}\)</span> 上的投影再乘上向量 <span class="math inline">\(\vec{b}\)</span> 的模长。</p>
<p>点积是一个实数，设 <span class="math inline">\(\theta\)</span> 为 <span class="math inline">\(\vec{a},\vec{b}\)</span> 的夹角，<span class="math inline">\(\vec{a}\cdot \vec{b}=|\vec{a}||\vec{b}|\cos\theta\)</span>。</p>
<p>对于 <span class="math inline">\(\vec{a}=(x_1,y_1),\vec{b}=(x_2,y_2)\)</span>，<span class="math inline">\(\vec{a}\cdot\vec{b}=x_1x_2+x_2y_2\)</span>。</p>
<p>点积满足交换律。</p>
<h3 id="叉积外积">叉积（外积）</h3>
<p>几何意义为两个向量平行四边形法围成的有向面积。</p>
<p>叉积是一个伪向量（所以当成实数好了），设 <span class="math inline">\(\theta\)</span> 为 <span class="math inline">\(\vec{a},\vec{b}\)</span> 的夹角，<span class="math inline">\(\vec{a}\cdot \vec{b}=|\vec{a}||\vec{b}|\sin\theta\)</span>。</p>
<p>对于 <span class="math inline">\(\vec{a}=(x_1,y_1),\vec{b}=(x_2,y_2)\)</span>，<span class="math inline">\(\vec{a}\cdot\vec{b}=x_1y_2-x_2y_1\)</span>。</p>
<hr />
<p>咕咕咕。。。</p>
]]></content>
      <categories>
        <category>总结</category>
        <category>Math</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 bzoj#2395 [Balkan 2011]Timeismoney</title>
    <url>/2020/08/23/2020-08-23-%E9%A2%98%E8%A7%A3-bzoj2395-Balkan-2011Timeismoney/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://darkbzoj.tk/problem/2395">题面</a></p>
<p>给出一个 n 点 m 边的无向图，每个边有权值 <span class="math inline">\(c_i,t_i\)</span>，求出一个生成树使最小化： <span class="math display">\[
(\sum_{i=1}^m c_i)\times(\sum_{i=1}^m t_i)
\]</span> <span class="math inline">\(1\le n\le 200,1\le m\le 1\times 10^4\)</span></p>
</blockquote>
<a id="more"></a>
<h2 id="思路">思路</h2>
<p>不同寻常的最小生成树。</p>
<h3 id="转化题意">转化题意</h3>
<p>先对于所有生成树的答案，设 <span class="math inline">\(C=\sum c_i,T=\sum t_i\)</span>，把他们表示成一个二维平面上若干个点（x 表示 C，y 表示 T）。</p>
<p>那么要最小化 <span class="math inline">\(C\times T\)</span>，就是用一个曲线 <span class="math inline">\(y=\frac{C\times T}{x}\)</span> 在这些点中取值，答案点一定在这些点的<strong>左下凸壳</strong>上。</p>
<p>接下来就是考虑怎么求出所有左下凸壳上的点来更新答案。</p>
<h3 id="分治">分治</h3>
<p>先考虑凸壳上的极值：C 最小时，该点表示以 c 为边权做最小生成树的答案；T 最小时，该点表示以 t 为边权做最小生成树的答案。</p>
<p>设以上两个点为 P,Q，我们把 P,Q 相连，然后找到点 S 使得 <span class="math inline">\(S_{\triangle PQS}\)</span> <strong>最大</strong>，则 S 一定在凸壳上。</p>
<p><img src="https://s1.ax1x.com/2020/08/23/d0OmuQ.png" /></p>
<p>利用<strong>叉积</strong>来求三角形面积的话，已知 <span class="math inline">\(P=(x_1,y_1),Q=(x_2,y_2),S=(x,y)\)</span>： <span class="math display">\[
\begin{align}
2S_{\triangle PQS}&amp;=\vec{PS}\times\vec{PQ}\\
&amp;=(x-x_1,y-y_1)\times(x_2-x_1,y_2-y_1)\\
&amp;=(x-x_1)(y_2-y_1)-(x_2-x_1)(y-y_1)\\
&amp;=(y_2-y_1)x-(x_2-x_1)y-(y_2-y_1)x_1+(x_2-x_1)y_1
\end{align}
\]</span> 忽略后面两项常数，可以转化成<strong>最小化</strong> <span class="math inline">\((x_2-x_1)y-(y_2-y_1)x\)</span>。</p>
<p>那么把所有边权重新赋为 <span class="math inline">\((x_2-x_1)t-(y_2-y_1)c\)</span>，跑一边最小生成树即可找到点 S。</p>
<p>以 S 划分，分治下去即可。</p>
<p>注意<strong>边界</strong>：如果找到的点 S 在 PQ 直线上方（通过叉积判断），那么凸壳上 P,Q 相邻，不再分治。</p>
<h3 id="复杂度">复杂度</h3>
<p>不是很懂，<del>O(能过)</del>。</p>
<p><img src="https://s1.ax1x.com/2020/08/23/d0xTFs.png" /></p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> RenaMoe &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(TT &amp;x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    LL c, t, val;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Edge &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> val &lt; t.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    LL x, y;</span><br><span class="line">    Point() &#123;&#125;</span><br><span class="line">    Point(LL _x, LL _y) : x(_x), y(_y) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Point &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x * y == t.x * t.y ? x &lt; t.x : x * y &lt; t.x * t.y;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> -(<span class="keyword">const</span> Point &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - t.x, y - t.y);</span><br><span class="line">    &#125;</span><br><span class="line">    LL <span class="keyword">operator</span> *(<span class="keyword">const</span> Point &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x * t.y - y * t.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">Point ans;</span><br><span class="line"><span class="keyword">int</span> fa[N];</span><br><span class="line">Edge e[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Point <span class="title">Kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">re</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    sort(e+<span class="number">1</span>, e+m+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = find(e[i].x), y = find(e[i].y);</span><br><span class="line">        <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">            fa[x] = y;</span><br><span class="line">            re.x += e[i].c, re.y += e[i].t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// l: P,  r: Q,  mid: S </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(Point l, Point r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        e[i].val = e[i].t * (r.x - l.x) - e[i].c * (r.y - l.y);</span><br><span class="line">    Point mid = Kruskal();</span><br><span class="line">    <span class="keyword">if</span> ((mid - l) * (r - l) &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    ans = min(ans, mid);</span><br><span class="line">    solve(l, mid), solve(mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; ++i) &#123;</span><br><span class="line">        read(u), read(v), read(e[i].c), read(e[i].t);</span><br><span class="line">        e[i].x = u + <span class="number">1</span>, e[i].y = v + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) e[i].val = e[i].c;</span><br><span class="line">    Point l = Kruskal();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) e[i].val = e[i].t;</span><br><span class="line">    Point r = Kruskal();</span><br><span class="line">    ans = min(l, r);</span><br><span class="line">    solve(l, r);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>, ans.x, ans.y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RenaMoe::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图论</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
        <tag>最小生成树</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF1117G Recursive Queries</title>
    <url>/2020/08/24/2020-08-24-%E9%A2%98%E8%A7%A3-CF1117G-Recursive-Queries/</url>
    <content><![CDATA[<blockquote>
<p>给出一个长为 n 的排列，每次给出询问 <span class="math inline">\([l_i,r_i]\)</span>（可以离线），求 <span class="math inline">\(f(l_i,r_i)\)</span>： <span class="math display">\[
f(l,r)=\begin{cases}
(r-l+1)+f(l,m_{l,r}-1)+f(m_{l,r}+1,r)\quad &amp;(l\le r)\\
0\quad &amp;(l &gt; r)
\end{cases}
\]</span></p>
<p><span class="math inline">\(m_{l,r}\)</span> 为 <span class="math inline">\([l,r]\)</span> 的最大值的位置。</p>
</blockquote>
<a id="more"></a>
<h2 id="思路">思路</h2>
<h3 id="转化题意">转化题意</h3>
<p>给出的式子应该很好理解吧，就是区间最大值将区间分开，递归下去。</p>
<p>那么一个区间的最大值也就代表这个区间，其贡献为区间长度。</p>
<p>最后该区间的答案就是每个点的贡献之和。</p>
<p>设 i 左边第一个大于 <span class="math inline">\(a_i\)</span> 的位置为 <span class="math inline">\(lb(i)\)</span>，右边第一个大于 <span class="math inline">\(a_i\)</span> 的位置为 <span class="math inline">\(rb(i)\)</span>，（若无该位置，<span class="math inline">\(lb(i)=0,rb(i)=n+1\)</span>）。</p>
<p>其实就是要统计：</p>
<p><span class="math display">\[
\sum_{i=l}^r\min(rb(i)-1,r)-\max(lb(i)+1,l)+1
\]</span></p>
<h3 id="预处理-lbirbi">预处理 <span class="math inline">\(lb(i),rb(i)\)</span></h3>
<p>利用<strong>单调栈</strong> <span class="math inline">\(O(n)\)</span> 处理即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (top &amp;&amp; a[stk[top]] &lt; a[i])</span><br><span class="line">        rb[stk[top--]] = i;</span><br><span class="line">    lb[i] = stk[top];</span><br><span class="line">    stk[++top] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (top) rb[stk[top--]] = n + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="离线统计">离线统计</h3>
<p>现将每个点的贡献<strong>拆开</strong>，分别统计 <span class="math inline">\(lb(i),rb(i)\)</span>，需要区间求和。</p>
<p>以统计 <span class="math inline">\(lb(i)\)</span> 为例：</p>
<p>注意到如果 <span class="math inline">\(i\in [l,r],lb(i)+1&lt;l\)</span>，该点贡献为 <span class="math inline">\(l\)</span>。</p>
<p>我们将所有询问离线下来，固定 l，对每个 r 区间求和。</p>
<p>每次向右移动 l，所有 <span class="math inline">\(lb(i)=l\)</span> 的位置的贡献都应该改为 l。</p>
<p>那么就把这些位置去掉贡献，打上 tag，每次统计答案时，统计区间有 tag 的个数另外计算。</p>
<p>单点修改，区间查询，开两棵<strong>树状数组</strong>分别维护 <span class="math inline">\(lb(i)\)</span> 的贡献和 tag 个数。</p>
<p>统计 <span class="math inline">\(rb(i)\)</span> 的贡献同理，<strong>倒着</strong>做就行。</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> RenaMoe &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(TT &amp;x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ask</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[N], lb[N], rb[N], stk[N];</span><br><span class="line">LL ans[N];</span><br><span class="line">Ask q[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; qry[N], del[N]; <span class="comment">// qry[i]：左端点为i的询问，del[i]：lb为i的位置</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bit</span> &#123;</span></span><br><span class="line">    LL tr[N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(tr, <span class="number">0</span>, <span class="keyword">sizeof</span> tr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, LL k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += i &amp; -i)</span><br><span class="line">            tr[i] += k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        LL re = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i -= i &amp; -i)</span><br><span class="line">            re += tr[i];</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; tr1, tr2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) read(q[i].l);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) read(q[i].r);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单调栈求lb[i],rb[i]</span></span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &amp;&amp; a[stk[top]] &lt; a[i])</span><br><span class="line">            rb[stk[top--]] = i;</span><br><span class="line">        <span class="keyword">if</span> (top) lb[i] = stk[top];</span><br><span class="line">        stk[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (top) rb[stk[top--]] = n + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        del[lb[i]].push_back(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        qry[q[i].l].push_back(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        tr1.update(i, lb[i]); <span class="comment">// 注意+1-1的细节</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 清除贡献，打tag</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; del[i<span class="number">-1</span>].size(); ++j) &#123;</span><br><span class="line">            tr1.update(del[i<span class="number">-1</span>][j], -lb[del[i<span class="number">-1</span>][j]]);</span><br><span class="line">            tr2.update(del[i<span class="number">-1</span>][j], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; qry[i].size(); ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = qry[i][j];</span><br><span class="line">            ans[id] -= tr1.query(q[id].r) - tr1.query(q[id].l<span class="number">-1</span>);</span><br><span class="line">            ans[id] -= (LL)(i - <span class="number">1</span>) * (tr2.query(q[id].r) - tr2.query(q[id].l<span class="number">-1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">        del[i].clear(), qry[i].clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        del[rb[i]].push_back(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        qry[q[i].r].push_back(i);</span><br><span class="line">    tr1.clear(), tr2.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        tr1.update(i, rb[i]<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; del[i+<span class="number">1</span>].size(); ++j) &#123;</span><br><span class="line">            tr1.update(del[i+<span class="number">1</span>][j], -rb[del[i+<span class="number">1</span>][j]]+<span class="number">1</span>);</span><br><span class="line">            tr2.update(del[i+<span class="number">1</span>][j], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; qry[i].size(); ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = qry[i][j];</span><br><span class="line">            ans[id] += tr1.query(q[id].r) - tr1.query(q[id].l<span class="number">-1</span>);</span><br><span class="line">            ans[id] += (LL)i * (tr2.query(q[id].r) - tr2.query(q[id].l<span class="number">-1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, ans[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P3953 逛公园</title>
    <url>/2020/08/24/2020-08-24-%E9%A2%98%E8%A7%A3-P3953-%E9%80%9B%E5%85%AC%E5%9B%AD/</url>
    <content><![CDATA[<blockquote>
<p>给出 n 点 m 边的有向图，设 1 点到 n 点最短路为 d，求长度小于等于 d+k 的路线方案数。</p>
<p><span class="math inline">\(n\le 10^5,m\le 2\times 10^5,k\le50\)</span>，每条边边权为<strong>非负</strong>整数。</p>
<p>若方案数无穷，输出 -1。</p>
</blockquote>
<a id="more"></a>
<p>因为 0 环的问题，这题绝大部分题解都假了，<a href="https://www.luogu.com.cn/blog/salix-leaf/solution-p3953">详情看这里</a>。</p>
<h2 id="思路">思路</h2>
<h3 id="分层图">分层图</h3>
<p>先预处理以 1 和 n 为起点的单源最短路。</p>
<p>考虑 dp，设 <span class="math inline">\(f[u][i]\)</span> 表示 1 到 u 路径比原先最短路长度多出 i 的方案数。</p>
<p>对于每条边 <span class="math inline">\(E_{u\rightarrow v}\)</span>，<span class="math inline">\(f[v][i+dis_u+val_E-dis_v]\Longleftarrow f[u][i]\)</span>。</p>
<p>可以发现每条边上的转移 <span class="math inline">\(dis_u+val_E-dis_v\)</span> 是定值，于是把 dp 转化到分层图上。</p>
<p>在分层图上拓扑 dp，答案就是 <span class="math inline">\(\sum_{i=0}^k f[n][i]\)</span>。</p>
<p>我比较懒，直接把每个状态 <span class="math inline">\((u,i)\)</span> 新建了点（结果跑的巨慢）。</p>
<h3 id="无解情况">无解情况</h3>
<p>注意拓扑完如果仍有点未入队，证明有 0 环。</p>
<p>0 环一直跑下去，方案数肯定无穷啊。</p>
<p>但是我们看下面这个图：</p>
<p><img src="https://s1.ax1x.com/2020/08/24/drkaOs.png" /></p>
<p>有解的路径并没有经过 0 环，也就是我们应该去掉不在有解路径上的边。</p>
<p>判一下是否 <span class="math inline">\(dis_{1,u}+val_E+dis_{v,n}\le dis_{1,n}+k\)</span> 即可。</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> RenaMoe &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(TT &amp;x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> K = <span class="number">60</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> nxt, to, val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, dis;</span><br><span class="line">    Data() &#123;&#125;</span><br><span class="line">    Data(<span class="keyword">int</span> x, <span class="keyword">int</span> d) : id(x), dis(d) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Data &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dis &gt; t.dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, m, kk, mod, cnte;</span><br><span class="line"><span class="keyword">int</span> ex[N], ey[N], ew[N], head[N*K], dis1[N], disn[N], out[N*K], ans[N*K], q[N*K];</span><br><span class="line">Edge e[N*K];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;Data&gt; heap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[++cnte] = (Edge)&#123;head[u], v, w&#125;, head[u] = cnte;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cnte = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="built_in">memset</span>(out, <span class="number">0</span>, <span class="keyword">sizeof</span> out);</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span> ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分层图编号</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> k * n + x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> *dis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        dis[i] = INF, vis[i] = <span class="literal">false</span>;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    heap.push(Data(s, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span> (!heap.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = heap.top().id;</span><br><span class="line">        heap.pop();</span><br><span class="line">        <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt) &#123;</span><br><span class="line">            v = e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (dis[v] &gt; dis[u] + e[i].val) &#123;</span><br><span class="line">                dis[v] = dis[u] + e[i].val;</span><br><span class="line">                heap.push(Data(v, dis[v]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        init();</span><br><span class="line">        read(n), read(m), read(kk), read(mod);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            read(ex[i]), read(ey[i]), read(ew[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理最短路</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            add_edge(ex[i], ey[i], ew[i]);</span><br><span class="line">        Dijkstra(<span class="number">1</span>, dis1);</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span> head), cnte = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            add_edge(ey[i], ex[i], ew[i]);</span><br><span class="line">        Dijkstra(n, disn);</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span> head), cnte = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去掉不在有解路径上的边</span></span><br><span class="line">        <span class="keyword">int</span> tm = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis1[ex[i]] + ew[i] + disn[ey[i]] &lt;= dis1[n] + kk)</span><br><span class="line">                tm++, ex[tm] = ex[i], ey[tm] = ey[i], ew[tm] = ew[i];</span><br><span class="line">        &#125;</span><br><span class="line">        m = tm;</span><br><span class="line">        <span class="comment">// 建出分层图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> dt = dis1[ex[i]] + ew[i] - dis1[ey[i]];</span><br><span class="line">            <span class="keyword">int</span> u = id(ex[i], <span class="number">0</span>), v = id(ey[i], dt);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j + dt &lt;= kk; ++j) &#123;</span><br><span class="line">                add_edge(u, v, <span class="number">0</span>), out[v]++;</span><br><span class="line">                u += n, v += n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tot = id(n, kk), sum = <span class="number">0</span>, sum_ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 拓扑dp</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i)</span><br><span class="line">            <span class="keyword">if</span> (!out[i]) q[++r] = i;</span><br><span class="line">        ans[id(<span class="number">1</span>, <span class="number">0</span>)] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q[l++];</span><br><span class="line">            sum++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt) &#123;</span><br><span class="line">                v = e[i].to;</span><br><span class="line">                ans[v] = (ans[v] + ans[u]) % mod;</span><br><span class="line">                <span class="keyword">if</span> (!(--out[v]))</span><br><span class="line">                    q[++r] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum != tot)	</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>); <span class="comment">// 有0环</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= kk; ++i)</span><br><span class="line">                sum_ans = (sum_ans + ans[id(n, i)]) % mod;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum_ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RenaMoe::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图论</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P4998 信号站</title>
    <url>/2020/08/26/2020-08-26-%E9%A2%98%E8%A7%A3-P4998-%E4%BF%A1%E5%8F%B7%E7%AB%99/</url>
    <content><![CDATA[<blockquote>
<p>一条路上有 n 户人家，坐标为 <span class="math inline">\(a_i\)</span>，需要建 k 个不同位置的信号站，每个信号站的不合理值为所有人家到信号站的距离和，求不合理值最小的 k 个信号站不合理值之和。</p>
<p><span class="math inline">\(k\le n\le 10^6,0\le a_i\le 10^6\)</span></p>
</blockquote>
<a id="more"></a>
<p><del>我才不会告诉你我是趁着估值频繁更新的时候来水题解的。</del></p>
<h2 id="思路">思路</h2>
<p>k,n 和坐标值域是同阶的。</p>
<p>设位置 i 的人家数有 <span class="math inline">\(b_i\)</span> 个，单次处理某个点的答案复杂度是 <span class="math inline">\(O(n)\)</span> 的，即 <span class="math inline">\(f_i=\sum b_j\times |i-j|\)</span>。</p>
<p>这时候需要我们观察两个点的答案之间的关系，尝试利用状态重叠的部分减少复杂度。</p>
<p>常用技巧，推一下将信号站由 i 挪到 i+1 答案变化了多少：</p>
<ul>
<li>i 左边的点（包括 i 处）离信号站距离都加了一</li>
<li>i 右边的点离信号站距离都减了一</li>
</ul>
<p>那么我们要维护每个点左右边各有几个点，通过前缀和或者递推，可将每次查询降到 <span class="math inline">\(O(1)\)</span>。</p>
<h2 id="细节">细节</h2>
<p>我赌你写一发交上去，倒数第二个点会 WA。</p>
<p>为什么？我们如果只计算了 <span class="math inline">\(i\in [0,10^6]\)</span> 的值，会忽略掉信号站建在负数位置的答案。</p>
<p>看个例子就懂了：</p>
<blockquote>
<p>n = 3，位置 <span class="math inline">\(a_i\)</span> 都为 0，k = 3。</p>
<p>那么三个信号站的位置分别为：-1，0，1。</p>
</blockquote>
<p>把所有位置向右平移 <span class="math inline">\(10^6\)</span> 单位距离，计算答案的范围扩大一倍就行。</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> RenaMoe &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(TT &amp;x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> L = <span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line">LL l, r, ans;</span><br><span class="line">LL a[N&lt;&lt;<span class="number">1</span>], f[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; ++i)</span><br><span class="line">        read(x), a[x+L]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= L+L; ++i)</span><br><span class="line">        f[<span class="number">0</span>] += a[i] * i;</span><br><span class="line">    <span class="comment">// l,r 分别是该位置左右两边的点数</span></span><br><span class="line">    r = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= L+L; ++i) &#123;</span><br><span class="line">        l += a[i<span class="number">-1</span>];</span><br><span class="line">        f[i] = f[i<span class="number">-1</span>] + l - r;</span><br><span class="line">        r -= a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(f, f+L+L+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">        ans += f[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
  </entry>
  <entry>
    <title>题解 P1081 开车旅行</title>
    <url>/2020/08/28/2020-08-28-%E9%A2%98%E8%A7%A3-P1081-%E5%BC%80%E8%BD%A6%E6%97%85%E8%A1%8C/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.luogu.com.cn/problem/P1081">题面</a></p>
<p>题面不好概括，贴个链接好了。</p>
</blockquote>
<a id="more"></a>
<p><del>你一个倍增题怎么这么难码啊！抱歉，是我的亲手写的 sb bug 让我调一天。</del></p>
<p>还是放一下题面好了：</p>
<p><img src="https://s1.ax1x.com/2020/08/28/doohOH.png" /></p>
<h2 id="思路">思路</h2>
<p>调完已经筋疲力尽了，不多说。</p>
<p>找距离最近的，那就倒着插入 set 来维护。</p>
<p>利用倍增的思想，预处理 <span class="math inline">\(nxt_{i,j}\)</span> 表示 i 点走 <span class="math inline">\(2^j\)</span> 次到达位置，同理 <span class="math inline">\(fa_{i,j},fb_{i,j}\)</span> 为两人答案。</p>
<p>细节看代码好了。</p>
<h2 id="代码">代码</h2>
<p>得 <code>long long</code>，这里 <code>define</code> 是我偷懒了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> RenaMoe &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(TT &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">bool</span> f = <span class="literal">false</span>; <span class="keyword">char</span> in = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(in)) &#123; <span class="keyword">if</span> (in == <span class="string">&#x27;-&#x27;</span>) f = <span class="literal">true</span>; in = getchar(); &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(in)) x = x * <span class="number">10</span> + in - <span class="string">&#x27;0&#x27;</span>, in = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">City</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> h, id;</span><br><span class="line">    City() &#123;&#125;</span><br><span class="line">    City(<span class="keyword">int</span> _h, <span class="keyword">int</span> _id) : h(_h), id(_id) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> City &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> h == t.h ? id &lt; t.id : h &lt; t.h; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tmp</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> h, dth, id;<span class="comment">// dth 为距离（delta h）</span></span><br><span class="line">    Tmp() &#123;&#125;</span><br><span class="line">    Tmp(City t) : h(t.h), id(t.id) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Tmp &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dth == t.dth ? h &lt; t.h : dth &lt; t.dth;<span class="comment">// 一定要好好读题qwq</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, ans_a, ans_b;</span><br><span class="line"><span class="keyword">int</span> h[N], nxt[N][<span class="number">20</span>], fa[N][<span class="number">20</span>], fb[N][<span class="number">20</span>], da[N], db[N], na[N], nb[N];</span><br><span class="line"><span class="built_in">multiset</span>&lt;City&gt; st;</span><br><span class="line">Tmp tmp[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    ans_a = ans_b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> (nxt[s][i] &amp;&amp; ans_a + ans_b + fa[s][i] + fb[s][i] &lt;= d) &#123;</span><br><span class="line">            ans_a += fa[s][i];</span><br><span class="line">            ans_b += fb[s][i];</span><br><span class="line">            s = nxt[s][i];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        read(h[i]);</span><br><span class="line">    st.insert(City(-INF, <span class="number">0</span>)), st.insert(City(-INF, <span class="number">0</span>));</span><br><span class="line">    st.insert(City(INF, n+<span class="number">1</span>)), st.insert(City(INF, n+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">multiset</span>&lt;City&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) &#123;</span><br><span class="line">        <span class="function">City <span class="title">u</span><span class="params">(h[i], i)</span></span>;</span><br><span class="line">        st.insert(u);</span><br><span class="line">        it = st.find(u);</span><br><span class="line">        tmp[<span class="number">0</span>] = Tmp(*--it), tmp[<span class="number">1</span>] = Tmp(*--it);</span><br><span class="line">        it = st.find(u);</span><br><span class="line">        tmp[<span class="number">2</span>] = Tmp(*++it), tmp[<span class="number">3</span>] = Tmp(*++it);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) </span><br><span class="line">            tmp[j].dth = <span class="built_in">abs</span>(tmp[j].h - h[i]);</span><br><span class="line">        sort(tmp, tmp+<span class="number">4</span>);</span><br><span class="line">        <span class="comment">// na,nb：分别以a,b开车的下一个位置，da,db为其距离</span></span><br><span class="line">        na[i] = tmp[<span class="number">1</span>].id, da[i] = tmp[<span class="number">1</span>].dth;</span><br><span class="line">        nb[i] = tmp[<span class="number">0</span>].id, db[i] = tmp[<span class="number">0</span>].dth;</span><br><span class="line">        nxt[i][<span class="number">0</span>] = na[i], fa[i][<span class="number">0</span>] = da[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        nxt[i][<span class="number">1</span>] = nb[na[i]];</span><br><span class="line">        fa[i][<span class="number">1</span>] = fa[i][<span class="number">0</span>], fb[i][<span class="number">1</span>] = db[na[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">19</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++u) &#123;</span><br><span class="line">            nxt[u][i] = nxt[nxt[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">            fa[u][i] = fa[u][i<span class="number">-1</span>] + fa[nxt[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">            fb[u][i] = fb[u][i<span class="number">-1</span>] + fb[nxt[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> s, x, ans;</span><br><span class="line">    read(x);</span><br><span class="line">    <span class="keyword">double</span> rat = (<span class="keyword">double</span>)INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        solve(i, x);</span><br><span class="line">        <span class="keyword">if</span> (ans_b == <span class="number">0</span>) ans_a = INF, ans_b = <span class="number">1</span>;<span class="comment">// 注意ans_b为0的情况</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">double</span>)ans_a / (<span class="keyword">double</span>)ans_b &lt; rat)</span><br><span class="line">            rat = (<span class="keyword">double</span>)ans_a / (<span class="keyword">double</span>)ans_b, ans = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    read(m);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        read(s), read(x);</span><br><span class="line">        solve(s, x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>, ans_a, ans_b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RenaMoe::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>20年11月13日 小测</title>
    <url>/2020/11/14/20%E5%B9%B411%E6%9C%8813%E6%97%A5%E5%B0%8F%E6%B5%8B/</url>
    <content><![CDATA[<p>贪心 + 状压 DP。</p>
<p>死刚 A 题，30 分。</p>
<a id="more"></a>
<h1 id="a">A</h1>
<p><a href="http://sjzezoj.com:9280/problem/44">题目</a></p>
<blockquote>
<p>给出 m 个长度不超过 n 的黑白序列，每次将同色的长度大于 1 的区间换成一个相反颜色的点，求每一列直到到不能操作的最少步数之和。 <span class="math inline">\(n\le 10^4,m\le100\)</span>。</p>
</blockquote>
<p>贪心。</p>
<p>每次操作就是将相邻三个（边界是两个）合并，贪心的想，一定是从中间能消的开始消（尽量每次消除两个区间）。</p>
<p>如果中间两个可行的区间中间的区间个数超过总数一半，那么答案为中间的区间数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, len, tot, ans;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s+<span class="number">1</span>);</span><br><span class="line">        len = <span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[i<span class="number">-1</span>]) a[tot]++;</span><br><span class="line">            <span class="keyword">else</span> a[++tot] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; <span class="number">1</span>) a[i] = <span class="number">1</span>, flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> a[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> l = tot &gt;&gt; <span class="number">1</span>, r = l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &amp;&amp; !a[l]) l--;</span><br><span class="line">        <span class="keyword">while</span> (r &lt;= tot &amp;&amp; !a[r]) r++;</span><br><span class="line">        <span class="keyword">if</span> (!l) &#123;</span><br><span class="line">            ans += r;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &gt; tot) &#123;</span><br><span class="line">            ans += tot - l + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((r - l) * <span class="number">2</span> &gt;= tot) ans += r - l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> ans += tot / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="b">B</h1>
<p><a href="http://sjzezoj.com:9280/contest/10/problem/45">题目</a></p>
<blockquote>
<p>n 个商店 m 个物品，每种物品在每个商店有不同的价值，每个商店有交通费，求买完所有物品的最小费用。 <span class="math inline">\(n\le 100,m\le 16\)</span>。</p>
</blockquote>
<p>状压 DP。</p>
<p>设 <span class="math inline">\(f_{i,S}\)</span> 表示前 i 个商店已购买 S 状态的最小费用。对于每个商店，强制去该商店，更新所有状态，再与不去该商店的状态取 <span class="math inline">\(\min\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">109</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, maxn;</span><br><span class="line"><span class="keyword">int</span> f[M][N], val[M][M], fee[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        read(fee[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            read(val[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    maxn = (<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(f[<span class="number">0</span>], <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f[<span class="number">0</span>]);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= maxn; ++j) &#123;</span><br><span class="line">            f[i][j] = f[i<span class="number">-1</span>][j] + fee[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= maxn; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((j &amp; (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>))) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                f[i][j] = min(f[i][j], f[i][j ^ (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>))] + val[i][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= maxn; ++j) &#123;</span><br><span class="line">            f[i][j] = min(f[i][j], f[i<span class="number">-1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\\n&quot;</span>, f[n][maxn]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>比赛</category>
      </categories>
  </entry>
  <entry>
    <title>20年11月14日 模拟赛</title>
    <url>/2020/11/15/20%E5%B9%B411%E6%9C%8814%E6%97%A5-%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>规律 + 树链剖分 + trie 树 + 简单 DP。</p>
<p>235分，算是没有挂分。</p>
<a id="more"></a>
<h1 id="a-演讲">A 演讲</h1>
<p><a href="http://sjzezoj.com:9280/problem/49">题目</a></p>
<blockquote>
<p>给定矩阵 <span class="math inline">\(g\)</span>，如果 i 被 j D，那么 i 就会去 D <span class="math inline">\(g_{i,j}\)</span>，一直循环下去，求第 d 个人。</p>
<p><span class="math inline">\(n\le 600,d\le 10^{18}\)</span>。</p>
</blockquote>
<p>规律题。</p>
<p>可以发现状态 <span class="math inline">\((i,j)\)</span> 只能转移到确定的一处，手模一下可以发现，这样下去会产生一个 ρ 型环。</p>
<p>只要预处理 <span class="math inline">\(n^2\)</span> 个状态就能找到环。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">609</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, tot, cur;</span><br><span class="line">LL d;</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="built_in">pair</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mem[N*N];</span><br><span class="line"><span class="built_in">map</span> &lt;<span class="built_in">pair</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(d);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            read(g[i][j]);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">1</span>;</span><br><span class="line">    mem[tot = <span class="number">1</span>] = <span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> id = <span class="number">2</span>; ; ++id) &#123;</span><br><span class="line">        <span class="built_in">pair</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; t(i, j);</span><br><span class="line">        <span class="keyword">if</span> (mp.count(t)) &#123;</span><br><span class="line">            cur = mp[t];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mp[t] = id;</span><br><span class="line">        mem[++tot] = t;</span><br><span class="line">        <span class="keyword">int</span> k = g[i][j];</span><br><span class="line">        j = i, i = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (d &lt;= tot)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\\n&quot;</span>, mem[d].first);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        d -= cur - <span class="number">1</span>;</span><br><span class="line">        d = (d - <span class="number">1</span>) % (tot - cur + <span class="number">1</span>) + cur;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\\n&quot;</span>, mem[d].first);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="b-卡车调度">B 卡车调度</h1>
<p><a href="http://sjzezoj.com:9280/problem/50">题目</a></p>
<blockquote>
<p>给出一个 n 点 m 边带权无向图，q 次询问：每次需要选的 x 和 y之间的路径和另外一条边（该边一端点是选定路径上的点），最小化这些边的最大值。</p>
<p><span class="math inline">\(n,q\le 3\times 10^5,m\le10^6\)</span>。</p>
</blockquote>
<p>最小生成树 + 树链剖分。</p>
<p>易证该路径一定在最小生成树上，树链剖分或倍增维护。</p>
<p>问题在于如何处理多出来的这条边。</p>
<p>对于路径上的每个点（不包括两端），已经被两条边经过，第三条边一定不大于该点第三小的出边，直接维护每个点第三小的出边边值，端点单独处理。（这里的边是原图的边。）</p>
<p>为什么？如果已经经过的两条边为最小的两条出边，那么该边就是第三小的最优；如果不是，该边为最小或第二小，其权值会经过的那两条边覆盖。</p>
<p>最后只要对 路径边权最大值 和 路径点第三小边权 两者取最大值。</p>
<p>有些地方用了奇怪的 trick，莫名其妙被别人慢很多。好像还是最长的？？？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e6</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">int</span> head[N], nxt[N&lt;&lt;<span class="number">1</span>], to[N&lt;&lt;<span class="number">1</span>], val[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        nxt[++cnt] = head[u], to[cnt] = v, val[cnt] = w, head[u] = cnt;</span><br><span class="line">        nxt[++cnt] = head[v], to[cnt] = u, val[cnt] = w, head[v] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; G;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, val;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Edge &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> val &lt; t.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FindSet</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fa[N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fa[x] == x ? x : fa[x] = find(fa[x]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; F; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, Q, tot;</span><br><span class="line"><span class="keyword">int</span> a1[N], a2[N], fa[N], deep[N], son[N], size[N], top[N], id[N];</span><br><span class="line">Edge ed[M];</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; out[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    deep[u] = deep[pre] + <span class="number">1</span>;</span><br><span class="line">    fa[u] = pre;</span><br><span class="line">    size[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = G.head[u], v; i; i = G.nxt[i]) &#123;</span><br><span class="line">        v = G.to[i];</span><br><span class="line">        <span class="keyword">if</span> (v == pre) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(v, u);</span><br><span class="line">        size[u] += size[v];</span><br><span class="line">        <span class="keyword">if</span> (!son[u] || size[v] &gt; size[son[u]]) son[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegTree</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(x) ((x) &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(x) ((x) &lt;&lt; 1 | 1)</span></span><br><span class="line">    <span class="keyword">int</span> ma[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    SegTree() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (N&lt;&lt;<span class="number">2</span>); ++i) ma[i] = -INF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> suc)</span> </span>&#123;</span><br><span class="line">        ma[suc] = max(ma[ls(suc)], ma[rs(suc)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> *a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            ma[suc] = a[l];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        build(ls(suc), l, mid, a), build(rs(suc), mid+<span class="number">1</span>, r, a);</span><br><span class="line">        push_up(suc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            ma[suc] = k;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (p &lt;= mid) update(ls(suc), l, mid, p, k);</span><br><span class="line">        <span class="keyword">else</span> update(rs(suc), mid+<span class="number">1</span>, r, p, k);</span><br><span class="line">        push_up(suc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) <span class="keyword">return</span> ma[suc];</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, res = -INF;</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= mid) res = max(res, query(ls(suc), l, mid, ql, qr));</span><br><span class="line">        <span class="keyword">if</span> (qr &gt; mid) res = max(res, query(rs(suc), mid+<span class="number">1</span>, r, ql, qr));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; tr1, tr2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tp, <span class="keyword">int</span> eval)</span> </span>&#123;</span><br><span class="line">    id[u] = ++tot;</span><br><span class="line">    top[u] = tp;</span><br><span class="line">    a1[id[u]] = eval;</span><br><span class="line">    <span class="keyword">if</span> (!son[u]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = G.head[u], v; i; i = G.nxt[i]) &#123;</span><br><span class="line">        v = G.to[i];</span><br><span class="line">        <span class="keyword">if</span> (v == son[u]) &#123;</span><br><span class="line">            dfs2(v, tp, G.val[i]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = G.head[u], v; i; i = G.nxt[i]) &#123;</span><br><span class="line">        v = G.to[i];</span><br><span class="line">        <span class="keyword">if</span> (v == fa[u] || v == son[u]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs2(v, v, G.val[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = -INF;</span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deep[top[x]] &lt; deep[top[y]]) swap(x, y);</span><br><span class="line">        res = max(res, tr1.query(<span class="number">1</span>, <span class="number">1</span>, n, id[top[x]], id[x]));</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (deep[x] &gt; deep[y]) swap(x, y);</span><br><span class="line">    <span class="keyword">if</span> (x != y) res = max(res, tr1.query(<span class="number">1</span>, <span class="number">1</span>, n, id[x]+<span class="number">1</span>, id[y]));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = -INF;</span><br><span class="line">    <span class="keyword">int</span> tx = x, ty = y;</span><br><span class="line">    tr2.update(<span class="number">1</span>, <span class="number">1</span>, n, id[tx], -INF), tr2.update(<span class="number">1</span>, <span class="number">1</span>, n, id[ty], -INF);</span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deep[top[x]] &lt; deep[top[y]]) swap(x, y);</span><br><span class="line">        res = max(res, tr2.query(<span class="number">1</span>, <span class="number">1</span>, n, id[top[x]], id[x]));</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (deep[x] &gt; deep[y]) swap(x, y);</span><br><span class="line"><span class="comment">//	printf(&quot;&gt; %d %d\\n&quot;, id[x], id[y]);</span></span><br><span class="line">    res = max(res, tr2.query(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[y]));</span><br><span class="line">    tr2.update(<span class="number">1</span>, <span class="number">1</span>, n, id[tx], a2[id[tx]]), tr2.update(<span class="number">1</span>, <span class="number">1</span>, n, id[ty], a2[id[ty]]);</span><br><span class="line">    <span class="keyword">return</span> -res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(m), read(Q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        read(ed[i].x), read(ed[i].y), read(ed[i].val);</span><br><span class="line">    &#125;</span><br><span class="line">    F.init(n);</span><br><span class="line">    sort(ed+<span class="number">1</span>, ed+m+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = F.find(ed[i].x), y = F.find(ed[i].y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">continue</span>;</span><br><span class="line">        F.fa[x] = y;</span><br><span class="line">        G.add(ed[i].x, ed[i].y, ed[i].val);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">0</span>), dfs2(<span class="number">1</span>, <span class="number">1</span>, -INF), tr1.build(<span class="number">1</span>, <span class="number">1</span>, n, a1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        out[ed[i].x].push_back(ed[i].val);</span><br><span class="line">        out[ed[i].y].push_back(ed[i].val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        sort(out[i].begin(), out[i].end());</span><br><span class="line">        <span class="keyword">if</span> (out[i].size() &gt;= <span class="number">3</span>) a2[id[i]] = -out[i][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">else</span> a2[id[i]] = -INF;</span><br><span class="line">    &#125;</span><br><span class="line">    tr2.build(<span class="number">1</span>, <span class="number">1</span>, n, a2);</span><br><span class="line">    <span class="comment">//for (int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, id[i]); puts(&quot;&quot;);</span></span><br><span class="line">    <span class="comment">//printf(&quot;&gt;&gt; %d\\n&quot;, tr2.query(1, 1, n, 1, 3));</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">        read(x), read(y);</span><br><span class="line">        <span class="keyword">int</span> q1 = query1(x, y); <span class="comment">//puts(&quot;(* _ *)&quot;);</span></span><br><span class="line">        <span class="keyword">int</span> q2 = query2(x, y);</span><br><span class="line">        <span class="keyword">if</span> (q2 == INF &amp;&amp; out[x].size() == <span class="number">1</span> &amp;&amp; out[y].size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (out[x].size() &gt;= <span class="number">2</span>) q2 = min(q2, out[x][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (out[y].size() &gt;= <span class="number">2</span>) q2 = min(q2, out[y][<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\\n&quot;</span>, max(q1, q2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="c-篝火舞蹈">C 篝火舞蹈</h1>
<p><a href="http://sjzezoj.com:9280/problem/51">题目</a></p>
<blockquote>
<p>给出 <span class="math inline">\([0,3^n]\)</span> 的序列 <span class="math inline">\(a\)</span>，有两个操作：1 操作将序列分成三部分，交换第二个和第三个部分，然后各部分递归重复该操作；2 操作将序列整体右移，即 <span class="math inline">\(a_i=a_{i-1},a_1=a_n\)</span>。</p>
<p><span class="math inline">\(n\le 12,Q\le 2\times 10^5\)</span>。</p>
</blockquote>
<p>trie 树。</p>
<p>真是难想又巧妙的思路。</p>
<p>将下标转化到 3 进制，可以发现 1 操作就是对于每一位将值为 1 的和值为 2 的交换。</p>
<p>那么可以放到 trie 树上，通过 lazy tag 优化（两次 1 操作会抵消）单次 <span class="math inline">\(\mathcal O(1)\)</span>。</p>
<p>2 操作难以直接转化到 trie 树上，那么换一个编号方式：</p>
<p><img src="https://s3.ax1x.com/2020/11/15/Di2HZn.png" /></p>
<p><del>这怎么想的到啊。</del>因为 1 操作的性质，正反插 trie 都是一样的。</p>
<p>2 操作其实是让所有编号的位置加一，最低位是 0 和 1 的只改变 1 位，是 2 的会进位，所以从低位到高位插 trie 的话，每一层只要交换三个子树，然后往一个子树内递归即可，单次复杂度降至 <span class="math inline">\(\mathcal{O}(\log_2n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, lim, Q, tot;</span><br><span class="line"><span class="keyword">int</span> ch[N][<span class="number">3</span>], id[N], tag[N], pw3[N], ans[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> deep, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deep == n) &#123;</span><br><span class="line">        id[suc] = k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        ch[suc][i] = ++tot;</span><br><span class="line">        build(ch[suc][i], deep+<span class="number">1</span>, k + i * pw3[deep]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> suc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tag[suc]) <span class="keyword">return</span>;</span><br><span class="line">    swap(ch[suc][<span class="number">1</span>], ch[suc][<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        tag[ch[suc][i]] ^= <span class="number">1</span>;</span><br><span class="line">    tag[suc] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">circle</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> deep)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deep == n) <span class="keyword">return</span>;</span><br><span class="line">    push_down(suc);</span><br><span class="line">    <span class="keyword">int</span> t = ch[suc][<span class="number">2</span>];</span><br><span class="line">    ch[suc][<span class="number">2</span>] = ch[suc][<span class="number">1</span>], ch[suc][<span class="number">1</span>] = ch[suc][<span class="number">0</span>], ch[suc][<span class="number">0</span>] = t;</span><br><span class="line">    circle(ch[suc][<span class="number">0</span>], deep+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_tag</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> deep, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deep == n) &#123;</span><br><span class="line">        ans[id[suc]] = k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(suc);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        clear_tag(ch[suc][i], deep+<span class="number">1</span>, k + i * pw3[deep]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s+<span class="number">1</span>);</span><br><span class="line">    Q = <span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    pw3[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) pw3[i] = pw3[i<span class="number">-1</span>] * <span class="number">3</span>;</span><br><span class="line">    lim = <span class="built_in">pow</span>(<span class="number">3</span>, n);</span><br><span class="line">    build(tot = <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;S&#x27;</span>) tag[<span class="number">1</span>] ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> circle(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clear_tag(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="d-练习曲">D 练习曲</h1>
<p>简单 DP。</p>
<p>不修改的话 DP 方程： <span class="math display">\[
\begin{aligned}
f_i&amp;=\min_{i-L\le j&lt;i}\{f_j\}+w(j+1,i)\\
w(j,i)&amp;=\max\{\max_{j\le k&lt;i}\{a_k\},\ a_i-1\} + 1
\end{aligned}
\]</span></p>
<p>修改的话，发现一个点只影响 <span class="math inline">\(2L\)</span> 个 DP 值，那么预处理正着和倒着分别 DP 一遍，处理影响的一段后拼接得到答案。</p>
<p>可以发现 <span class="math inline">\(f_i\)</span> 是单调不降的。从 <span class="math inline">\((x-L,x]\)</span> 中固定一个起点，当 <span class="math inline">\(x\)</span> 所在段权值一定时，这一段越长越好。</p>
<p>所以每次只要 <span class="math inline">\(\mathcal O(L)\)</span> 处理即可，复杂度 <span class="math inline">\(\mathcal O((n+q)L)\)</span>。其实觉得过不了的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6e5</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, L, Q;</span><br><span class="line">LL a[N], f[N], g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(L), read(Q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] + a[i];</span><br><span class="line">        LL ma = a[i] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt; <span class="number">0</span> &amp;&amp; i - j + <span class="number">1</span> &lt;= L; --j) &#123;</span><br><span class="line">            ma = max(ma, a[j]);</span><br><span class="line">            f[i] = min(f[i], f[j - <span class="number">1</span>] + ma + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> last = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        g[i] = g[i + <span class="number">1</span>] + a[i];</span><br><span class="line">        LL ma = a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n &amp;&amp; j - i + <span class="number">1</span> &lt;= L; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt;= ma) last = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> ma = a[j], last = <span class="literal">false</span>;</span><br><span class="line">            g[i] = min(g[i], g[j + <span class="number">1</span>] + ma + last);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    LL val;</span><br><span class="line">    <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">        read(x), read(val);</span><br><span class="line">        LL ans = f[x - <span class="number">1</span>] + g[x + <span class="number">1</span>] + val;</span><br><span class="line">        <span class="keyword">int</span> j = x + <span class="number">1</span>;</span><br><span class="line">        LL ma = val;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; x - i &lt;= L; --i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt;= n &amp;&amp; j - i - <span class="number">1</span> &lt;= L &amp;&amp; a[j] &lt;= ma) ++j;</span><br><span class="line">            j = min(j, i + L + <span class="number">1</span>);</span><br><span class="line">            ans = min(ans, f[i] + g[j] + ma + <span class="number">1</span>);</span><br><span class="line">            ma = max(ma, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        j = x - <span class="number">1</span>, ma = val;</span><br><span class="line">        <span class="keyword">bool</span> last = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x + <span class="number">1</span>; i &lt;= n + <span class="number">1</span> &amp;&amp; i - x &lt;= L; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; i - j - <span class="number">1</span> &lt;= L &amp;&amp; a[j] &lt; ma) --j;</span><br><span class="line">            j = max(j, i - L - <span class="number">1</span>);</span><br><span class="line">            ans = min(ans, f[j] + g[i] + ma + last);</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt;= ma) last = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> ma = a[i], last = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>比赛</category>
      </categories>
  </entry>
  <entry>
    <title>20年11月22日 「启智树」模拟赛</title>
    <url>/2020/11/22/20%E5%B9%B411%E6%9C%8822%E6%97%A5-%E3%80%8C%E5%90%AF%E6%99%BA%E6%A0%91%E3%80%8D%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>数论 + 模拟 + 图论 + 带权并查集。</p>
<p>88 块钱的比赛竟然没好好打 QAQ。</p>
<a id="more"></a>
<h1 id="a-等差数列">A 等差数列</h1>
<blockquote>
<p>给出两个等差数列 <span class="math inline">\(a,b\)</span>，求区间 <span class="math inline">\([l,r]\)</span> 中同时出现在两个等差数列的数的个数。</p>
<p><span class="math inline">\(a_1,b_1\le 100, r\le 10^{18}\)</span>。</p>
</blockquote>
<p>数论。</p>
<p>设 <span class="math inline">\(a,b\)</span> 的等差数列公差 <span class="math inline">\(d_1,d_2\)</span>，每 <span class="math inline">\(\operatorname{lcm}(d_1,d_2)\)</span> 就会出现一个符合条件的数，这个循环长度只有 <span class="math inline">\(10^4\)</span> 级别，暴力找即可。</p>
<p>然后 <span class="math inline">\([1,n]\)</span> 的答案就是最小的符合条件的数到 <span class="math inline">\(n\)</span> 之间的循环机个数，上取整。</p>
<p>最后答案差分一下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL a, aa, d1, b, bb, d2, l, r, fir, cc;</span><br><span class="line">LL sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; fir) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (LL)<span class="built_in">ceil</span>((<span class="keyword">double</span>)(n - fir + <span class="number">1</span>) / (<span class="keyword">double</span>)cc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(a), read(aa), read(b), read(bb), read(l), read(r);</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) swap(a, b), swap(aa, bb);</span><br><span class="line">    d1 = aa - a, d2 = bb - b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a; i &lt;= <span class="number">1e5</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((i - a) % d1 == <span class="number">0</span> &amp;&amp; (i - b) % d2 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!fir) fir = i;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cc = i - fir;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, solve(r) - solve(l<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="b-玩具">B 玩具</h1>
<p><img src="https://s3.ax1x.com/2020/11/22/DGnDZn.png" /></p>
<blockquote>
<p><span class="math inline">\(n\le 10^6\)</span>。</p>
<p>模拟题题目好长就不概括了。</p>
</blockquote>
<p>就是类似队列的思想预处理每个点到其之前 <span class="math inline">\(L\)</span> 个可行位置的长度，贪心地跳即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e6</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, B, L;</span><br><span class="line">LL ans;</span><br><span class="line">LL g[N];</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; B) sum -= str[i - B] == <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        sum += str[i] == <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= B &amp;&amp; sum &lt; L) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(L), read(B), read(n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!check()) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;IMPOSSIBLE&quot;</span>), <span class="keyword">void</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = L;</span><br><span class="line">    g[L] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L + <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            r = i, l++;</span><br><span class="line">            <span class="keyword">while</span> (str[l] == <span class="string">&#x27;0&#x27;</span>) l++;</span><br><span class="line">        &#125;</span><br><span class="line">        g[i] = l;</span><br><span class="line">    &#125;</span><br><span class="line">    l = L, r = B;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; n) &#123;</span><br><span class="line">        ans += L;</span><br><span class="line">        l = r, r = g[r] + B - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; n) ans += L;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans + n - B);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="c-整除">C 整除</h1>
<blockquote>
<p>给定 <span class="math inline">\(k,m\)</span>，求一个最小的能被 <span class="math inline">\(m\)</span> 整除的 <span class="math inline">\(n\)</span>，保证 <span class="math inline">\(n\)</span> 的每一位数字都属于 <span class="math inline">\([0,k)\)</span>。</p>
<p><span class="math inline">\(k\le 10,m\le 10^6\)</span>。</p>
</blockquote>
<p>图论。</p>
<p>设 <span class="math inline">\(f_i\)</span> 表示 <span class="math inline">\(n \bmod m = i\)</span> 的最小的 <span class="math inline">\(n\)</span>，<span class="math inline">\(f_i\)</span> 可以向 <span class="math inline">\(f_i\times10+j\quad(j\in[0,k))\)</span> 连边。</p>
<p>对每个点的出边从小到大 bfs，即可保证答案最小。</p>
<p><span class="math inline">\(f_i\)</span> 存不下，只存最低位的前驱点即可，最后从 <span class="math inline">\(0\)</span> 点往回倒推。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> K, m;</span><br><span class="line"><span class="keyword">int</span> dis[N], ans[N], pre[N], q[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; e[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; output;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(K), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; m; ++u) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; K; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = (u * <span class="number">10</span> + j) % m;</span><br><span class="line">            e[u].push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">        pre[u] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="keyword">int</span> ql = <span class="number">1</span>, qr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt; K; ++u) &#123;</span><br><span class="line">        ans[u] = u;</span><br><span class="line">        dis[u] = <span class="number">0</span>;</span><br><span class="line">        q[++qr] = u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ql &lt;= qr) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q[ql++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e[u].size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[u][i];</span><br><span class="line">            <span class="keyword">if</span> (dis[v] &gt; dis[u] + <span class="number">1</span>) &#123;</span><br><span class="line">                ans[v] = i;</span><br><span class="line">                dis[v] = dis[u] + <span class="number">1</span>;</span><br><span class="line">                pre[v] = u;</span><br><span class="line">                q[++qr] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u != <span class="number">-1</span>; u = pre[u]) &#123;</span><br><span class="line">        output.push_back(ans[u] + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = output.size() - <span class="number">1</span>; ~i; --i)</span><br><span class="line">        <span class="built_in">putchar</span>(output[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="d-集合">D 集合</h1>
<p>类似 <a href="https://www.luogu.com.cn/problem/CF571D">CF571D Campus</a>。</p>
<p>可以看这道题的 <a href="/2020/11/26/题解-CF571D-Campus">题解</a>（没用带权并查集）。</p>
]]></content>
      <categories>
        <category>比赛</category>
      </categories>
  </entry>
  <entry>
    <title>20年12月 刷题记录</title>
    <url>/2020/12/02/20%E5%B9%B412%E6%9C%88-%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>考完 NOIP 就要回去补文化课了，这个月可能做不了多少题了。</p>
<a id="more"></a>
<h1 id="日">2日</h1>
<h2 id="s2oj123-数组入门">S2OJ#123 数组入门</h2>
<p><a href="https://sjzezoj.com/problem/123">题目</a></p>
<p>分块。</p>
<p>取模可能会让中间的某些值修改后变成最小值，所以要用维护权值的数据结构。</p>
<p>考虑分块，每个块维护一个排好序的 vector，下放标记就重构，查询就 lower_bound。</p>
<p>经过多次调参和提交，发现块的大小为 <span class="math inline">\(n^{0.4}\)</span> 能 AC，复杂度 <span class="math inline">\(\mathcal O(m(n^{0.6}+n^{0.4}\log n^{0.4}))\)</span>。</p>
<h2 id="p1776-宝物筛选">P1776 宝物筛选</h2>
<p><a href="https://www.luogu.com.cn/problem/P1776">题目</a></p>
<p>单调队列优化多重背包。 <span class="math display">\[
\begin{aligned}
f(i,j)&amp;\leftarrow \max_{0\le k\le c}\{f(i-1, j-kw)+v\times k\}\\
f(i,d+kw)&amp;\leftarrow \max_{k-c\le k&#39;\le k}\{f(i-1, d+k&#39;w)-v\times k&#39;\}+v\times k
\end{aligned}
\]</span> 对于每个 <span class="math inline">\(d\ (0\le d &lt; w)\)</span> 分别用单调队列维护 DP，总复杂度 <span class="math inline">\(\mathcal O(nm)\)</span>。</p>
<h1 id="日-1">3日</h1>
<h2 id="u142829-魔法商店">U142829 魔法商店</h2>
<p><a href="https://www.luogu.com.cn/problem/U142829">题目</a></p>
<p>物品重量很小，按重量分类再排序，转化成多重背包。</p>
<p>设 <span class="math inline">\(s(i,j)\)</span> 为物品 <span class="math inline">\(i\)</span> 最大的前 <span class="math inline">\(j\)</span> 个物品价值和。 <span class="math display">\[
f(i,d+kw)\leftarrow \max_{k-c\le k&#39;\le k}\{f(i-1, d+k&#39;w)+s(i,k-k&#39;)\}
\]</span> <span class="math inline">\(s(i,j)\)</span> 是凸的，<span class="math inline">\(f(i,j)\)</span> 单调不降，所以这东西有决策单调性，可以单调队列优化，或者分治。</p>
<h2 id="cf220b-little-elephant-and-array">CF220B Little Elephant and Array</h2>
<p><a href="https://www.luogu.com.cn/problem/CF220B">题目</a></p>
<p>树状数组 + 离线。</p>
<p>离散化，用 vector 把每种权值的所有位置按顺序存起来，先令区间左端点为 <span class="math inline">\(1\)</span>，确定右端点合法范围，用树状数组区间打标记。</p>
<p>将所有询问离线，从左往右扫，对于以该点为左端点的询问在树状数组上单点查询；每次只有 <span class="math inline">\(1\)</span> 种权值答案改变，在树状数组上撤销和修改即可。</p>
<p>总复杂度 <span class="math inline">\(\mathcal O(n\log n)\)</span>。</p>
<h2 id="u144136-距离">U144136 距离</h2>
<p><a href="https://www.luogu.com.cn/problem/U144136">题目</a></p>
<p>倍增 + 二分 + 最短路。</p>
<p>发现不断地往 图里加边，<span class="math inline">\(1\)</span> 到 <span class="math inline">\(n\)</span> 的最短路单调不升，可以二分。</p>
<p>考虑 <span class="math inline">\(47\)</span> 分：对于某个时间段里的边建出图来跑最短路，二分 <span class="math inline">\(5\)</span> 次即可，复杂度 <span class="math inline">\(\mathcal O(n\log^2n)\)</span>。</p>
<p>至于满分做法，因为清空图的时间段很多，每次二分边界中有许多无用的范围，考虑用倍增缩小二分范围。</p>
<p>设上次清空时间点 <span class="math inline">\(D\)</span>，倍增到最小的时间点 <span class="math inline">\(D+2^i\)</span> 满足 <span class="math inline">\(dis(1,n)\le T\)</span>，在中间二分并更新 <span class="math inline">\(D\)</span>。</p>
<p>每条边最多被处理 <span class="math inline">\(\log q\)</span> 次，复杂度应该是 <span class="math inline">\(\mathcal O(q\log q)\)</span>。</p>
<p>毒瘤 <span class="math inline">\(\rm \color{black}{A}\color{red}{zusaCat}\)</span>，她卡了 SPFA。</p>
<h1 id="日-2">15日</h1>
<h2 id="p5410-模板扩展-kmpz-函数">P5410 【模板】扩展 KMP（Z 函数）</h2>
<p><a href="https://www.luogu.com.cn/problem/P5410">题目</a></p>
<p>见 <a href="/2020/01/17/2020-01-17-板子-kmp/">板子 kmp</a></p>
<h1 id="日-3">16日</h1>
<h2 id="p1494-国家集训队小z的袜子">P1494 [国家集训队]小Z的袜子</h2>
<p><a href="https://www.luogu.com.cn/problem/P1494">题目</a></p>
<p>经典莫队板子，复习。</p>
<h1 id="日-4">17日</h1>
<h2 id="sp10707-cot2---count-on-a-tree-ii">SP10707 COT2 - Count on a tree II</h2>
<p><a href="https://www.luogu.com.cn/problem/SP10707">题目</a></p>
<p>树上莫队，见 <a href="/2020/12/17/总结-莫队/">莫队总结</a>。</p>
<h1 id="日-5">19日</h1>
<h2 id="at1219-歴史の研究">AT1219 歴史の研究</h2>
<p><a href="https://www.luogu.com.cn/problem/AT1219">题目</a></p>
<p>回滚莫队，见 <a href="/2020/12/17/总结-莫队/">莫队总结</a>。</p>
<h1 id="日-6">20日</h1>
<h2 id="p4887-模板莫队二次离线第十四分块前体">P4887 【模板】莫队二次离线（第十四分块(前体)）</h2>
<p><a href="https://www.luogu.com.cn/problem/P4887">题目</a></p>
<p>二次离线莫队，见 <a href="/2020/12/17/总结-莫队/">莫队总结</a>。</p>
<h2 id="p4074-wc2013糖果公园">P4074 「WC2013」糖果公园</h2>
<p><a href="https://www.luogu.com.cn/problem/P4074">题目</a></p>
<p>树上莫队 + 带修莫队。</p>
<p>不太好码。</p>
<h1 id="日-7">21日</h1>
<h2 id="p2713-罗马游戏">P2713 罗马游戏</h2>
<p><a href="https://www.luogu.com.cn/problem/P2713">题目</a></p>
<p>可并堆。</p>
<h2 id="p4556-vani有约会雨天的尾巴-模板线段树合并">P4556 [Vani有约会]雨天的尾巴 /【模板】线段树合并</h2>
<p><a href="https://www.luogu.com.cn/problem/P4556">题目</a></p>
<p>树上差分 + 线段树合并。</p>
<p>注意是多次路径修改并且一次询问，树上差分后把所有询问插入对应点的线段树中，dfs 一遍把每个点儿子的线段树合并到它的线段树上，然后在线段树上查即可。</p>
<p>插入点数 <span class="math inline">\(n\)</span>，复杂度 <span class="math inline">\(\mathcal O(n\log n)\)</span>。</p>
<h1 id="日-8">22日</h1>
<h2 id="p3224-hnoi2012永无乡">P3224 [HNOI2012]永无乡</h2>
<p><a href="https://www.luogu.com.cn/problem/P3224">题目</a></p>
<p>并查集 + 线段树合并。</p>
<p>并查集维护连通性，线段树合并硬上即可，每次合并都没有重合的点，复杂度 <span class="math inline">\(\mathcal O(n\log n)\)</span>。</p>
<h2 id="p3919-模板可持久化线段树-1可持久化数组">P3919 【模板】可持久化线段树 1（可持久化数组）</h2>
<p><a href="https://www.luogu.com.cn/problem/P3919">题目</a></p>
<p>可持久化线段树。</p>
<h2 id="p2839-国家集训队middle">P2839 [国家集训队]middle</h2>
<p><a href="https://www.luogu.com.cn/problem/P2839">题目</a></p>
<p>二分 + 可持久化线段树。</p>
<p>中位数套路：把大于等于 <span class="math inline">\(x\)</span> 的设为 <span class="math inline">\(+1\)</span>，小于 <span class="math inline">\(x\)</span> 的设为 <span class="math inline">\(-1\)</span>，若和为 <span class="math inline">\(1\)</span> 或 <span class="math inline">\(0\)</span> 则 <span class="math inline">\(x\)</span> 为中位数。</p>
<p>先考虑询问固定的区间，二分最大的 <span class="math inline">\(x\)</span> 满足区间和 <span class="math inline">\(\ge 0\)</span>，所以需要对于每一个值开一棵求中位数的线段树。</p>
<p>相邻两个值的线段树只有很少几个值不同，可以通过可持久化线段树将时间空间降到 <span class="math inline">\(\mathcal O(n\log n)\)</span>。</p>
<p>对于询问 <span class="math inline">\(a,b,c,d\)</span>，<span class="math inline">\([b,c]\)</span> 是一定要选的，查和即可；因为要让中位数尽可能大，所以 check 时的区间可也要尽可能大，所以取 <span class="math inline">\([a,b)\)</span> 的最大后缀和、<span class="math inline">\((c,d]\)</span> 的最大前缀和。</p>
<h2 id="p1712-noi2016区间">P1712 [NOI2016]区间</h2>
<p><a href="https://www.luogu.com.cn/problem/P1712">题目</a></p>
<p>尺取法 + 线段树。</p>
<p>把所有区间按长度排序，然后模拟一个队列，每次向后挪动 <span class="math inline">\(r\)</span> 至有至少一个点覆盖次数 <span class="math inline">\(\ge m\)</span>，再尽量往后挪动 <span class="math inline">\(l\)</span>，更新答案，覆盖次数用线段树维护。</p>
<h1 id="日-9">23日</h1>
<h2 id="p5192-zoj3229-shoot-the-bullet东方文花帖模板有源汇上下界最大流">P5192 Zoj3229 Shoot the Bullet|东方文花帖|【模板】有源汇上下界最大流</h2>
<p><a href="https://www.luogu.com.cn/problem/P5192">题目</a></p>
<p>有源汇上下界最大流，见 <a href="/2020/01/17/2020-01-17-总结-网络流/">总结 网络流</a>。</p>
<h2 id="p6329-模板点分树-震波">P6329 【模板】点分树 | 震波</h2>
<p><a href="https://www.luogu.com.cn/problem/P6329">题目</a></p>
<p>点分树，见 <a href="/2020/12/23/总结-点分树（动态点分治）/">总结 点分树（动态点分治）</a>。</p>
<h1 id="日-10">24日</h1>
<h2 id="p3345-zjoi2015幻想乡战略游戏">P3345 [ZJOI2015]幻想乡战略游戏</h2>
<p><a href="https://www.luogu.com.cn/problem/P3345">题目</a></p>
<p>点分树，见 <a href="/2020/12/23/总结-点分树（动态点分治）/">总结 点分树（动态点分治）</a>。</p>
<h2 id="p3241-hnoi2015开店">P3241 [HNOI2015]开店</h2>
<p><a href="https://www.luogu.com.cn/problem/P3241">题目</a></p>
<p>点分树，见 <a href="/2020/12/23/总结-点分树（动态点分治）/">总结 点分树（动态点分治）</a>。</p>
<h1 id="日-11">26~27日</h1>
<p>写了一堆多项式板子题，见 <a href="/2020/12/25/2020-01-24-板子-多项式全家桶/">板子 多项式全家桶</a>。</p>
<h2 id="p2260-清华集训2012模积和">P2260 [清华集训2012]模积和</h2>
<p><a href="https://www.luogu.com.cn/problem/P2260">题目</a></p>
<p>整除分块。</p>
<p>令 <span class="math inline">\(n\le m\)</span>，推式子：</p>
<p><span class="math display">\[
\begin{aligned}
&amp;\quad\sum_{i=1}^n\sum_{j=1}^m[i\not=j](n\bmod i)(m\bmod j)\\
&amp;=\sum_{i=1}^n\sum_{j=1}^m(n-\lfloor\frac{n}{i}\rfloor i)(m-\lfloor\frac{m}{j}\rfloor j)-\sum_{i=1}^{n}(n-\lfloor\frac{n}{i}\rfloor i)(m-\lfloor\frac{m}{i}\rfloor i)
\end{aligned}
\]</span></p>
<p>设 <span class="math inline">\(F(n,k)=\sum_{i=1}^n \lfloor\frac{k}{i}\rfloor i\)</span>，这东西可以 <span class="math inline">\(\mathcal O(\sqrt{n})\)</span> 整除分块算。</p>
<p><span class="math display">\[
\begin{aligned}
&amp;=(n^2-F(n,n))(m^2-F(m, m))-\sum_{i=1}^{n}(nm-n\lfloor\frac{m}{i}\rfloor i-m\lfloor\frac{n}{i}\rfloor i+\lfloor\frac{n}{i}\rfloor\lfloor\frac{m}{i}\rfloor i^2)\\
&amp;=(n^2-F(n,n))(m^2-F(m, m))-n^2 m+nF(n,m)+mF(n,n)-\sum_{i=1}^{n}\lfloor\frac{n}{i}\rfloor\lfloor\frac{m}{i}\rfloor i^2\\
\end{aligned}
\]</span> 最后 <span class="math inline">\(\sum_{i=1}^n \lfloor\frac{n}{i}\rfloor\lfloor\frac{m}{i}\rfloor i^2\)</span> 这东西可以二维整除分块，两个整除分块叠加，块的数量是相加的。</p>
<h2 id="p4213-模板杜教筛sum">P4213 【模板】杜教筛（Sum）</h2>
<p><a href="https://www.luogu.com.cn/problem/P4213">题目</a></p>
<p>见 <a href="/2020/12/27/笔记-杜教筛/">笔记 杜教筛</a>。</p>
<h2 id="p4318-完全平方数">P4318 完全平方数</h2>
<p><a href="https://www.luogu.com.cn/problem/P4318">题目</a></p>
<p>二分 + 容斥。</p>
<p>先二分答案，然后考虑计算 <span class="math inline">\(f(n)=\sum_{i=1}^n \mu(i)^2\)</span>。</p>
<p>从另一个角度考虑，<span class="math inline">\(f(n)\)</span> 让有平方因子的数贡献为 <span class="math inline">\(0\)</span>，容斥的算就是 <span class="math inline">\(-\)</span> <span class="math inline">\(2^2\)</span> 的倍数 <span class="math inline">\(-\)</span> <span class="math inline">\(3^2\)</span> 的倍数 <span class="math inline">\(+\)</span> <span class="math inline">\(6^2\)</span> 的倍数，根据 <span class="math inline">\(\mu\)</span> 的定义，容斥系数就是 <span class="math inline">\(\mu\)</span>，所以 <span class="math inline">\(f(n)=\sum_{i=1}^{\sqrt{n}}\mu(i)\lfloor\frac{n}{i^2}\rfloor\)</span>。</p>
<p>复杂度 <span class="math inline">\(\mathcal O(\sqrt{n}\log n)\)</span>。</p>
<h1 id="日-12">28日</h1>
<h2 id="p4841-集训队作业2013城市规划">P4841 [集训队作业2013]城市规划</h2>
<p><a href="https://www.luogu.com.cn/problem/P4841">题目</a></p>
<p>多项式求逆。</p>
<p>设 <span class="math inline">\(f(n)\)</span> 表示 <span class="math inline">\(n\)</span> 个点的无向连通图方案数，<span class="math inline">\(g(n)\)</span> 表示 <span class="math inline">\(n\)</span> 个点无向图方案数（即 <span class="math inline">\(2^{\binom{n}{2}}\)</span>）。</p>
<p>钦定 <span class="math inline">\(1\)</span> 号点不动，枚举 <span class="math inline">\(1\)</span> 所在连通块大小，推式子： <span class="math display">\[
\begin{aligned}
g(n)&amp;=\sum_{i=1}^n \binom{n-1}{i-1}f(i)g(n-i)\\
g(n)&amp;=\sum_{i=1}^n \frac{(n-1)!}{(i-1)!(n-i)!}f(i)g(n-i)\\
\frac{g(n)}{(n-1)!}&amp;=\sum_{i=1}^n \frac{f(i)}{(i-1)!}\frac{g(n-i)}{(n-i)!}\\
\end{aligned}
\]</span> 设 <span class="math inline">\(F(n)=\frac{f(i)}{(i-1)!}\)</span>，<span class="math inline">\(G(n)=\frac{g(n-i)}{(n-i)!}\)</span>，<span class="math inline">\(H(n)=\frac{g(n)}{(n-1)!}\)</span>，可以看出来这是个卷积。 <span class="math display">\[
H(n)=\sum_{i=1}^nF(i)G(n-i)\Leftrightarrow F=H*G^{-1}
\]</span> 我们已知 <span class="math inline">\(H,G\)</span>，就可以用多项式求逆做。</p>
<h2 id="p4449-于神之怒加强版">P4449 于神之怒加强版</h2>
<p><a href="https://www.luogu.com.cn/problem/P4449">题目</a></p>
<p>整除分块 + 线性筛。</p>
<p>我们知道 <span class="math inline">\(\mu*I=\epsilon\)</span>，则 <span class="math display">\[
\begin{aligned}
&amp;\quad\sum_{i=1}^n\sum_{j=1}^m\gcd(i,j)^k\\
&amp;=\sum_{d=1}^n d^k\sum_{i=1}^{\lfloor n/d\rfloor}\sum_{j=1}^{\lfloor m/d\rfloor}[\gcd(i,j)=1]\\
&amp;=\sum_{d=1}^n d^k\sum_{i=1}^{\lfloor n/d\rfloor}\sum_{j=1}^{\lfloor m/d\rfloor}\sum_{x|i,x|j}\mu(x)\\
&amp;=\sum_{d=1}^n d^k\sum_{x=1}^{\lfloor n/d\rfloor}\mu(x)\lfloor n/dx\rfloor\lfloor m/dx\rfloor\\
&amp;=\sum_{d=1}^n d^k\sum_{y=1}^{\lfloor n\rfloor}\mu(y/d)\lfloor n/y\rfloor\lfloor m/y\rfloor\\
&amp;=\sum_{y=1}^{n}\lfloor n/y\rfloor\lfloor m/y\rfloor\sum_{d|y} d^k\mu(y/d)\\
\end{aligned}
\]</span> 设 <span class="math inline">\(f(n)=\sum_{d|y} d^k\mu(\frac{y}{d})\)</span>，是个积性函数，考虑线性筛。</p>
<p>若 <span class="math inline">\(n=\prod p^c\)</span>，则 <span class="math display">\[
\begin{aligned}
f(n)&amp;=\prod(-p^{k(c-1)}+p^{kc})\\
&amp;=\prod p^{k(c-1)}(p^k-1)
\end{aligned}
\]</span> 这样 <span class="math inline">\(f\)</span> 就满足了能够快速求得 <span class="math inline">\(f(p),f(p^k)\)</span>。</p>
<p>复杂度 <span class="math inline">\(\mathcal O(n\log n+T\sqrt{n})\)</span>。</p>
<h2 id="p3723-ah2017hnoi2017礼物">P3723 [AH2017/HNOI2017]礼物</h2>
<p><a href="https://www.luogu.com.cn/problem/P3723">题目</a></p>
<p>FFT。</p>
<p>题目让我们求 <span class="math display">\[
\begin{aligned}
&amp;\quad\sum_{i=1}^n(a_i-b_i+c)^2\\
&amp;=\sum_{i=1}^na_i^2+\sum_{i=1}^nb_i^2+2c\sum_{i=1}^n(a_i-b_i)+nc^2-2\sum_{i=1}^na_ib_i\\
\end{aligned}
\]</span> 发现前两项是不变项，和 <span class="math inline">\(c\)</span> 相关的是二次函数（值域很小大力枚举就好），问题是旋转 <span class="math inline">\(a\)</span> 序列最大化最后一项。</p>
<p>倍长 <span class="math inline">\(a\)</span> 就是 <span class="math inline">\(\sum_{i=1}^{2n} a_{i+k}b_i\)</span>，翻转 <span class="math inline">\(b\)</span> 得到 <span class="math inline">\(\sum_{i=1}^{2n} a_{i+k}b_{n-i}\)</span> 是个卷积，FFT 卷后在 <span class="math inline">\([n+1,2n]\)</span> 上找最大值即可。</p>
]]></content>
      <categories>
        <category>刷题记录</category>
      </categories>
  </entry>
  <entry>
    <title>20年12月1日 模拟赛</title>
    <url>/2020/12/01/20%E5%B9%B412%E6%9C%881%E6%97%A5-%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>博弈论 + 模拟 + 贪心 + 状压 DP。</p>
<p><del>100(?) + 40(?) + 60 + 10 = 210（数据太水了）</del></p>
<p>48 + 20 + 60 + 10 = 138。</p>
<a id="more"></a>
<h2 id="t1-树树">T1 树树</h2>
<blockquote>
<p>给出 <span class="math inline">\(n\)</span> 个点的树，两人轮流染色，先手染黑，后手染白，染完后若存在一个黑点相邻的都是黑点则先手赢。问结局。</p>
<p><span class="math inline">\(2\le n \le 10^5\)</span>。</p>
</blockquote>
<p>原题 <a href="https://atcoder.jp/contests/agc014/tasks/agc014_d">AGC014D Black and White Tree</a></p>
<p>博弈论 + DP。</p>
<p>一些显然的性质（考场上写的部分分）：</p>
<ul>
<li>一条链，奇数个点先手赢；</li>
<li>树上某一个点有大于等于两个叶子节点，先手赢。</li>
</ul>
<p><strong>正解</strong></p>
<p>若一个点出度为二，且有一个儿子为叶子，先手一定会选择她，后手会选择那个叶子。</p>
<p>这两个点染完色对上方的点没有影响，相当于从原树中删去，剩下的树再如此考虑。</p>
<p>直到只剩根节点，或者某一个点有大于等于两个叶子节点，判先手赢。</p>
<p>可以发现这个 DP 过程就是树上完美匹配。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">int</span> head[N], nxt[N * <span class="number">2</span>], to[N * <span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        ++cnt, nxt[cnt] = head[u], to[cnt] = v, head[u] = cnt;</span><br><span class="line">        ++cnt, nxt[cnt] = head[v], to[cnt] = u, head[v] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; G;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> size[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = G.head[u]; i; i = G.nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = G.to[i];</span><br><span class="line">        <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v, u);</span><br><span class="line">        <span class="keyword">if</span> (size[v] == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">        size[u] += size[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (size[u] &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;First&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ++size[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        read(u), read(v);</span><br><span class="line">        G.add(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (size[<span class="number">1</span>] &amp; <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;First&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Second&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t2-网格">T2 网格</h2>
<h2 id="t3-有手就行">T3 有手就行</h2>
<blockquote>
<p>给出 <span class="math inline">\(n\)</span> 个物品，每个物品有两个权值 <span class="math inline">\(a_i,b_i\)</span>，一个物品最多选 <span class="math inline">\(3\)</span> 次：第一次 <span class="math inline">\(a_i\)</span>，第二次 <span class="math inline">\(b_i\)</span>，第三次 <span class="math inline">\(a_i\)</span>。</p>
<p><span class="math inline">\(f(i)\)</span> 为选 <span class="math inline">\(i\)</span> 个物品最大权值和，求 <span class="math inline">\(\displaystyle \operatorname{xor}_{i=1}^mf(i)\)</span>。</p>
<p><span class="math inline">\(1\le n\le 5\times 10^6,1\le m\le 3\times n\)</span>。</p>
</blockquote>
<p>一个物品选 <span class="math inline">\(1\dots3\)</span> 次的状态可以拆成两个物品：<span class="math inline">\(A_i=a_i\)</span> 和 <span class="math inline">\(B_i=a_i+b_i\)</span>，两类物品空间为 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(2\)</span>。</p>
<p>发现物品空间只有两种，可以贪心地将两类物品从大到小排序，之后 DP 就轻松了。</p>
<p>设 <span class="math inline">\(f_i\)</span> 为选 <span class="math inline">\(i\)</span> 个物品最大权值和，每个状态同时维护两类物品分别取到了第几个 <span class="math inline">\(p^A_i,p^B_i\)</span>： <span class="math display">\[
\large f_i\leftarrow \max\{f_{i-1}+A_{p^A_{i-1}},\quad f_{i-2}+B_{p^B_{i-2}}\}
\]</span> 复杂度就是 <span class="math inline">\(\mathcal O(n\log n + n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> threshold = <span class="number">10000000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e7</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">ull k1, k2;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ull <span class="title">Rand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ull k3 = k1, k4 = k2;</span><br><span class="line">    k1 = k4;</span><br><span class="line">    k3 ^= (k3 &lt;&lt; <span class="number">23</span>);</span><br><span class="line">    k2 = k3 ^ k4 ^ (k3 &gt;&gt; <span class="number">17</span>) ^ (k4 &gt;&gt; <span class="number">26</span>);</span><br><span class="line">    <span class="keyword">return</span> k2 + k4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">LL ans;</span><br><span class="line">LL a[N], b[N], f[N];</span><br><span class="line"><span class="keyword">int</span> pa[N], pb[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">gen</span><span class="params">(<span class="keyword">int</span> n, ull _k1, ull _k2)</span> </span>&#123;</span><br><span class="line">    k1 = _k1, k2 = _k2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        a[i] = Rand() % threshold + <span class="number">1</span>;</span><br><span class="line">        b[i] = Rand() % threshold + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ull k1, k2;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k1 &gt;&gt; k2;</span><br><span class="line">    gen(n, k1, k2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) b[i] += a[i];</span><br><span class="line">    sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    sort(b + <span class="number">1</span>, b + n + <span class="number">1</span>);</span><br><span class="line">    reverse(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    reverse(b + <span class="number">1</span>, b + n + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    pa[<span class="number">0</span>] = pb[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    f[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">    pa[<span class="number">1</span>] = <span class="number">2</span>, pb[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pa[i - <span class="number">1</span>] &lt;= n &amp;&amp; (f[i - <span class="number">1</span>] + a[pa[i - <span class="number">1</span>]] &gt; f[i - <span class="number">2</span>] + b[pb[i - <span class="number">2</span>]])) &#123;</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>] + a[pa[i - <span class="number">1</span>]];</span><br><span class="line">            pa[i] = pa[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            pb[i] = pb[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            f[i] = f[i - <span class="number">2</span>] + b[pb[i - <span class="number">2</span>]];</span><br><span class="line">            pa[i] = pa[i - <span class="number">2</span>];</span><br><span class="line">            pb[i] = pb[i - <span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) ans ^= f[i];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="t4-求余数">T4 求余数</h2>
<blockquote>
<p>有多少长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(a\)</span>，满 足 <span class="math inline">\(1\le a_i \le m\)</span> 且对于任意 <span class="math inline">\(1\le i &lt; j \le n\)</span> 都满足 <span class="math inline">\(\gcd(a_i,a_j)=1\)</span>。</p>
<p><span class="math inline">\(n\le 10^5,m\le100,T\le 500\)</span>。</p>
</blockquote>
<p>数论 + 状压 DP。</p>
<p>其实只要先求所有数都 <span class="math inline">\(\ge 2\)</span> 的序列方案数，剩下的位置填 <span class="math inline">\(1\)</span> 即可。</p>
<p>观察到 <span class="math inline">\(m\)</span> 很小，将 <span class="math inline">\([2,m]\)</span> 的数的质因子出现的情况可以状压（<span class="math inline">\(100\)</span> 以内只有二十多个质数）。</p>
<p>进一步地，每个数大于 <span class="math inline">\(\sqrt{m}\)</span> 的质因子至多有 <span class="math inline">\(1\)</span> 个，所以只需要把 <span class="math inline">\(2,3,5,7\)</span> 四个质数压进状态，然后将 <span class="math inline">\([2,m]\)</span> 所有数按照（大于 <span class="math inline">\(7\)</span> 的）最大质因子分组。</p>
<p>对于质因子只有 <span class="math inline">\(2,3,5,7\)</span> 的数，用背包 DP 统计方案数，设 <span class="math inline">\(f_{i,j,S}\)</span> 表示前 <span class="math inline">\(i\)</span> 个数中选 <span class="math inline">\(j\)</span> 个数质因子状态为 <span class="math inline">\(S\)</span> 的方案数： <span class="math display">\[
f_{i,j,S}\leftarrow f_{i-1,j,S}+f_{i-1,j-1,S-p(x)}
\]</span> 对于分组后每一组的数，一个状态中至多选一个，同理进行 DP。</p>
<p>注意上界最多选二十多个数，并且第一维可以省去。</p>
<p>然后统计选 <span class="math inline">\(i\)</span> 个数的方案数为 <span class="math inline">\(g_i\)</span>，最后答案为： <span class="math display">\[
\begin{aligned}
&amp;\sum_{i=0}^{\min\{m,30\}}g_i\times i!\times \binom{n}{i}\\
&amp;=n!\times\sum_{i=0}^{\min\{m,30\}} g_i\times \frac{1}{(n-i)!}
\end{aligned}
\]</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">109</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Lim = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, m;</span><br><span class="line"><span class="keyword">int</span> p[M], f[M][<span class="number">20</span>], g[M], fac[N], ifac[N];</span><br><span class="line"><span class="keyword">int</span> prime[] = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) a[i].clear();</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span> p);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = prime[j];</span><br><span class="line">            <span class="keyword">if</span> (t % k) <span class="keyword">continue</span>;</span><br><span class="line">            p[i] |= <span class="number">1</span> &lt;&lt; j;</span><br><span class="line">            <span class="keyword">while</span> (t % k == <span class="number">0</span>) t /= k;</span><br><span class="line">        &#125;</span><br><span class="line">        a[t].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lm = <span class="number">1e5</span>;</span><br><span class="line">    fac[<span class="number">0</span>] = ifac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lm; ++i) fac[i] = (LL)fac[i - <span class="number">1</span>] * i % P;</span><br><span class="line">    ifac[lm] = power(fac[lm], P - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lm - <span class="number">1</span>; i; --i) ifac[i] = (LL)ifac[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % P;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        clear();</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        dec();</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)a[<span class="number">1</span>].size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = a[<span class="number">1</span>][i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">30</span>; j; --j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; Lim; ++s) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((s &amp; p[x]) != p[x]) <span class="keyword">continue</span>;</span><br><span class="line">                    f[j][s] = (f[j][s] + f[j - <span class="number">1</span>][s ^ p[x]]) % P;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i].empty()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">30</span>; j; --j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; Lim; ++s) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; (<span class="keyword">int</span>)a[i].size(); ++k) &#123;</span><br><span class="line">                        <span class="keyword">int</span> x = a[i][k];</span><br><span class="line">                        <span class="keyword">if</span> ((s &amp; p[x]) != p[x]) <span class="keyword">continue</span>;</span><br><span class="line">                        f[j][s] = (f[j][s] + f[j - <span class="number">1</span>][s ^ p[x]]) % P;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">30</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt;= Lim; ++s) g[i] = (g[i] + f[i][s]) % P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= min(m, <span class="number">30</span>); ++i) &#123;</span><br><span class="line">            ans = (ans + (LL)g[i] * ifac[n - i]) % P;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = (LL)ans * fac[n] % P;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>比赛</category>
      </categories>
  </entry>
  <entry>
    <title>20年12月29日 省选五校联合集训考试一</title>
    <url>/2020/12/29/20%E5%B9%B412%E6%9C%8829%E6%97%A5-%E7%9C%81%E9%80%89%E4%BA%94%E6%A0%A1%E8%81%94%E5%90%88%E9%9B%86%E8%AE%AD%E8%80%83%E8%AF%95%E4%B8%80/</url>
    <content><![CDATA[<p>构造 + min_25筛(?) + 区间 DP。</p>
<p>0 + 18 + 33 = 51，自闭场，垫底了。</p>
<a id="more"></a>
<p><a href="https://sjzezoj.com/blog/webnie/post/43">模拟赛官方题解</a></p>
<h2 id="a-我永远喜欢月">A 我永远喜欢月</h2>
<p><a href="https://sjzezoj.com/problem/190">题目</a></p>
<blockquote>
<p>给出 <span class="math inline">\(n\times m\)</span> 的矩阵 <span class="math inline">\(A,B\)</span>，每次操作选择 <span class="math inline">\((i,j)\)</span>，让 <span class="math inline">\(A\)</span> 中第 <span class="math inline">\(i\)</span> 行和第 <span class="math inline">\(j\)</span> 列都变为 <span class="math inline">\(0\)</span> 并将 <span class="math inline">\(A_{i,j}\)</span> 变为 <span class="math inline">\(1\)</span>。问若干次后是否能将 <span class="math inline">\(A\)</span> 变成 <span class="math inline">\(B\)</span>。</p>
<p><span class="math inline">\(n,m\le 10^3\)</span>。</p>
</blockquote>
<p>若 <span class="math inline">\(A\)</span> 中某一行或某一列有 <span class="math inline">\(\ge 2\)</span> 个 <span class="math inline">\(1\)</span>，那么就无法操作，“锁”住。</p>
<p>对于点 <span class="math inline">\((i,j)\)</span>，</p>
<ul>
<li><p>若第 <span class="math inline">\(i\)</span> 行和第 <span class="math inline">\(j\)</span> 列都锁住了，必须满足 <span class="math inline">\(A_{i,j}=B_{i,j}\)</span>，否则无解；</p></li>
<li><p>若只有行或者列被锁住，说明操作点一定不是该点；</p></li>
<li><p>若行和列都没锁住，就是可以任意操作的点。</p></li>
</ul>
<p>那么任意操作的点中，在 <span class="math inline">\(A\)</span> 中一定要有 <span class="math inline">\(0\)</span>（不然无从开始），在 <span class="math inline">\(B\)</span> 中一定要有 <span class="math inline">\(1\)</span>（每次操作至少剩一个 <span class="math inline">\(1\)</span>），否则无解。</p>
<p>注意特判一开始 <span class="math inline">\(A=B\)</span> 的情况。</p>
<p>复杂度 <span class="math inline">\(\mathcal O(nm)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, m;</span><br><span class="line"><span class="keyword">int</span> A[N][N], B[N][N], sum_col[N], sum_row[N];</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">bool</span> vis_row[N], vis_col[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) A[i][j] = B[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) sum_row[i] = vis_row[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) sum_col[i] = vis_col[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_row</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_col</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_row</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis_row[x]) <span class="keyword">return</span>;</span><br><span class="line">    vis_row[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="keyword">if</span> (B[x][i] == <span class="number">1</span>) lock_col(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_col</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis_col[x]) <span class="keyword">return</span>;</span><br><span class="line">    vis_col[x] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (B[i][x] == <span class="number">1</span>) lock_row(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> same = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            sum_row[i] += B[i][j];</span><br><span class="line">            sum_col[j] += B[i][j];</span><br><span class="line">            same &amp;= A[i][j] == B[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (same) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (sum_row[i] &gt; <span class="number">1</span>) lock_row(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="keyword">if</span> (sum_col[i] &gt; <span class="number">1</span>) lock_col(i);</span><br><span class="line">    <span class="keyword">bool</span> a0 = <span class="literal">false</span>, b1 = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis_row[i] &amp;&amp; vis_col[j]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i][j] != B[i][j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!vis_row[i] &amp;&amp; !vis_col[j]) &#123;</span><br><span class="line">                a0 |= A[i][j] == <span class="number">0</span>;</span><br><span class="line">                b1 |= B[i][j] == <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!a0 || !b1) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; (str + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) A[i][j] = str[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; (str + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) B[i][j] = str[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check()) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="b-因数">B 因数</h2>
<p><a href="https://sjzezoj.com/problem/191">题目</a></p>
<blockquote>
<p>若 <span class="math inline">\(\displaystyle n=\prod_{i=1}^{k}p_i^{c_i}\)</span>，设 <span class="math inline">\(\displaystyle f(n)=\sum_{i=1}^kc_i\)</span>。求 <span class="math inline">\(\displaystyle \sum_{i=1}^n f(i)\)</span>。</p>
<p><span class="math inline">\(n\le 10^{11}\)</span>。</p>
</blockquote>
<p><span class="math inline">\(\rm\color{black}{h}\color{red}{s\_black}\)</span> 讲这个要 min_25 筛，不会，先咕了。</p>
<h2 id="c-找朋友">C 找朋友</h2>
<p><a href="https://sjzezoj.com/problem/193">题目</a></p>
<blockquote>
<p>有 <span class="math inline">\(n\)</span> 个鱼缸，<span class="math inline">\(m\)</span> 只小鱼，每条鱼可以在一个区间内移动，安排鱼的位置，求在同一个位置的鱼的“对数”的最大值。</p>
<p><span class="math inline">\(n\le 10^4\)</span>，<span class="math inline">\(m\le 200\)</span>。</p>
</blockquote>
<p>区间 DP。</p>
<p>把小鱼的移动看成一条线段，设 <span class="math inline">\(f(i,j)\)</span> 表示严格区间 <span class="math inline">\([i,j]\)</span> 中的所有线段的最大答案。</p>
<p>枚举断点 <span class="math inline">\(k\)</span>，让能跨过 <span class="math inline">\(k\)</span> 的线段都集中在 <span class="math inline">\(k\)</span> 点，不能跨过 <span class="math inline">\(k\)</span> 点的线段的最优答案就是 <span class="math inline">\(f(i,k-1),f(k+1,j)\)</span>。</p>
<p>把位置离散化了，复杂度 <span class="math inline">\(\mathcal O(m^3)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">409</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, W, ans, tot;</span><br><span class="line"><span class="keyword">int</span> h[N], lb[N], rb[N], tmp[N], val[N], f[N][N], sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">lsh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) tmp[i] = lb[i], tmp[i + m] = rb[i];</span><br><span class="line">    sort(tmp + <span class="number">1</span>, tmp + m + m + <span class="number">1</span>);</span><br><span class="line">    tot = unique(tmp + <span class="number">1</span>, tmp + m + m + <span class="number">1</span>) - tmp - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        lb[i] = lower_bound(tmp + <span class="number">1</span>, tmp + tot + <span class="number">1</span>, lb[i]) - tmp;</span><br><span class="line">        rb[i] = lower_bound(tmp + <span class="number">1</span>, tmp + tot + <span class="number">1</span>, rb[i]) - tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(m), read(W);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        read(h[i]), h[i] = W - h[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        read(x), read(y);</span><br><span class="line">        lb[i] = rb[i] = x;</span><br><span class="line">        <span class="keyword">while</span> (lb[i] &gt; <span class="number">1</span> &amp;&amp; y &gt; h[lb[i]]) --lb[i];</span><br><span class="line">        <span class="keyword">while</span> (rb[i] &lt; n &amp;&amp; y &gt; h[rb[i]]) ++rb[i];</span><br><span class="line">    &#125;</span><br><span class="line">    lsh();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = lb[i]; j &lt;= rb[i]; ++j) ++val[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) val[i] = val[i] * (val[i] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= tot; ++len) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= tot; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lb[k] &gt;= i &amp;&amp; rb[k] &lt;= j) ++sum[lb[k]], --sum[rb[k] + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; ++k) sum[k] += sum[k - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; ++k)</span><br><span class="line">                f[i][j] = max(f[i][j], (sum[k] * (sum[k] - <span class="number">1</span>) / <span class="number">2</span>) + f[i][k - <span class="number">1</span>] + f[k + <span class="number">1</span>][j]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j + <span class="number">1</span>; ++k) sum[k] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[<span class="number">1</span>][tot]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>比赛</category>
      </categories>
  </entry>
  <entry>
    <title>21年1月 刷题记录</title>
    <url>/2021/01/08/21%E5%B9%B41%E6%9C%88-%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>哇塞怎么 2021 年了，怎么我还是那么菜。qwq</p>
<p>这个月做题重心在 SAM、数据结构。</p>
<p>因为疫情被封在学校很自闭，这个月做题很少啊，文化课也开始拖后腿了。</p>
<a id="more"></a>
<h1 id="日">8日</h1>
<h2 id="p3181-haoi2016找相同字符">P3181 [HAOI2016]找相同字符</h2>
<p><a href="https://www.luogu.com.cn/problem/P3181">题目</a></p>
<p>广义SAM。</p>
<p>把两个串插入广义SAM里，对于两个串分别维护不同的 <span class="math inline">\(size_0,size_1\)</span>，然后在 parent 树上统计，最后答案是 <span class="math inline">\(\sum_u size_0(u)\times size_1(u)\times (len(u)-len(link(u)))\)</span>。</p>
<h1 id="日-1">9日</h1>
<h2 id="cf666e-forensic-examination">CF666E Forensic Examination</h2>
<p><a href="https://www.luogu.com.cn/problem/CF666E">题目</a></p>
<p>广义SAM + 线段树合并。</p>
<p>把 <span class="math inline">\(S\)</span> 串和所有 <span class="math inline">\(T\)</span> 串插到 SAM 里，SAM 每个节点维护一棵线段树，记录在 <span class="math inline">\(T_{1\dots n}\)</span> 的出现次数，建出树来再线段树合并。对于每个询问，在 parent 树上倍增找到对应节点，查线段树即可。</p>
<p><code>pair</code> 慢死了，跑了五十多秒。</p>
<h2 id="p3346-zjoi2015诸神眷顾的幻想乡">P3346 [ZJOI2015]诸神眷顾的幻想乡</h2>
<p><a href="https://www.luogu.com.cn/problem/P3346">题目</a></p>
<p>广义SAM。</p>
<p>一个显然的性质：对于树上任何一个路径，一定能找到一个点，使得一该点为根时，该路径是直上直下的。</p>
<p>数据限制叶子很少，就对于每个叶子为根的几棵树当成 trie 树，插到一个 trie 里。</p>
<p>在 SAM 里离线构造，就是数本质不同子串个数的裸题了。</p>
<h1 id="日-2">10日</h1>
<h2 id="p6292-区间本质不同子串个数">P6292 区间本质不同子串个数</h2>
<p><a href="https://www.luogu.com.cn/problem/P6292">题目</a></p>
<p>SAM + LCT + 线段树。</p>
<p>类比静态区间数颜色数：最于每种颜色记录 <span class="math inline">\(last_i\)</span> 表示最晚出现位置，线段树维护区间和，询问离线后，扫描线处理，每加入一个点 <span class="math inline">\(i\)</span> 就让 <span class="math inline">\(last_{c_i}\)</span> 贡献 <span class="math inline">\(-1\)</span>，<span class="math inline">\(i\)</span> 位置 <span class="math inline">\(+1\)</span>。</p>
<p>现在同样离线询问，扫描线时在结尾加入点 <span class="math inline">\(i\)</span>，产生的子串是目前所有的后缀，我们需要让这些子串的 <span class="math inline">\(last\)</span> 贡献 <span class="math inline">\(-1\)</span>。</p>
<p>先把整个串 <span class="math inline">\(S\)</span> 建出 SAM，然后在 parent 的树上后缀 <span class="math inline">\(S[1,i]\)</span> 对应节点的所有祖先（一条链）就是以 <span class="math inline">\(i\)</span> 结尾的所有后缀，不能暴力跳，想到用 LCT 维护 parent 树结构。</p>
<p>可以发现这条链上相邻节点代表子串的右端点相同，左端点连续。那么在 LCT 的 access 操作时，对于这条链上每一段在线段树区间修改，同时标记新的 <span class="math inline">\(last\)</span>。最后加上当前所有后缀的贡献即可。</p>
<p>复杂度 <span class="math inline">\(\mathcal O(n\log^2 n + q\log n)\)</span>。</p>
<h2 id="sp1811-lcs---longest-common-substring">SP1811 LCS - Longest Common Substring</h2>
<p><a href="https://www.luogu.com.cn/problem/SP1811">题目</a></p>
<p>SAM。</p>
<p>求最长公共前缀，就是对于 <span class="math inline">\(T\)</span> 的每一个前缀，找到其最大的后缀是 <span class="math inline">\(S\)</span> 的子串。</p>
<p>那么把 <span class="math inline">\(S\)</span> 建出 SAM，然后在 SAM 上沿着 <span class="math inline">\(T\)</span> 走，每走一步匹配长度加一，若走不动了，就跳 <span class="math inline">\(link\)</span>，匹配长度缩小到 <span class="math inline">\(link\)</span> 节点的 <span class="math inline">\(len\)</span>，每一步的匹配长度取最大值即可。</p>
<p>除去建立 SAM 的复杂度，该部分复杂度 <span class="math inline">\(\mathcal O(|T|)\)</span>。</p>
<h1 id="日-3">11日</h1>
<h2 id="sp1812-lcs2---longest-common-substring-ii">SP1812 LCS2 - Longest Common Substring II</h2>
<p><a href="https://www.luogu.com.cn/problem/SP1812">题目</a></p>
<p>广义SAM。</p>
<p>和上题类似，把所有串扔进SAM里，然后我们随便找一个串来在SAM里匹配，并且只走在所有串中都出现过的节点（分别维护 <span class="math inline">\(size\)</span>）。</p>
<h1 id="日-4">14日</h1>
<h2 id="p4218-ctsc2010珠宝商">P4218 [CTSC2010]珠宝商</h2>
<p><a href="https://www.luogu.com.cn/problem/P4218">题目</a></p>
<p>见 <a href="/2021/01/14/题解-P4218-CTSC2010-珠宝商/">题解</a>。</p>
<h1 id="日-5">16日</h1>
<h2 id="heoi2016tjoi2016排序">2824 [HEOI2016/TJOI2016]排序</h2>
<p><a href="https://www.luogu.com.cn/problem/P2824">题目</a></p>
<p>线段树分裂 + 线段树合并。</p>
<p>每一个区间维护一棵权值线段树，每次排序就是把边界的区间线段树分裂，然后把这些区间的线段树合并，注意正序和倒序。</p>
<p>另外开一个 <code>set</code> 维护这些区间的左端点，便于查找所在区间。</p>
<p>复杂度是 <span class="math inline">\(\mathcal O((n+m)\log n)\)</span>，证明见 <a href="https://www.luogu.com.cn/blog/_post/108570">FlashHu 的题解</a>。</p>
<h2 id="p6186-noi-online-1-提高组-冒泡排序">P6186 [NOI Online #1 提高组] 冒泡排序</h2>
<p><a href="https://www.luogu.com.cn/problem/P6186">题目</a></p>
<p>树状数组。</p>
<p>设 <span class="math inline">\(f_i\)</span> 表示 <span class="math inline">\(j&lt;i,a_j&gt;a_i\)</span> 的 <span class="math inline">\(j\)</span> 的个数，观察冒泡排序的性质，每轮冒泡会让所有不为零的 <span class="math inline">\(f_i\)</span> 减一。所以查询答案就是 <span class="math inline">\(\sum_{i=1}^n[f_i&gt;k]f_i-k\)</span>。</p>
<p>交换操作只会改变相邻两个的 <span class="math inline">\(f\)</span> 值，很好处理。</p>
<p>逆序对个数上限是 <span class="math inline">\(n^2\)</span> 级别的，又忘了开 <code>long long</code>。</p>
<h2 id="p6478-noi-online-2-提高组-游戏">P6478 [NOI Online #2 提高组] 游戏</h2>
<p><a href="https://www.luogu.com.cn/problem/P6478">题目</a></p>
<p>树形DP + 二项式反演。</p>
<p>设 <span class="math inline">\(G(i)\)</span> 表示恰好 <span class="math inline">\(i\)</span> 对点匹配的方案数，不好计算，就再设 <span class="math inline">\(F(i)\)</span> 表示至少 <span class="math inline">\(i\)</span> 对点匹配的方案数，就可以二项式反演： <span class="math display">\[
F(k)=\sum_{i=k}^n\binom{i}{k}G(i)\Leftrightarrow G(k)=\sum_{i=k}^n(-1)^{i-k}\binom{i}{k}F(i)
\]</span> 现在考虑 <span class="math inline">\(F(i)\)</span> 怎么算。设 <span class="math inline">\(f(u,i)\)</span> 表示以 <span class="math inline">\(u\)</span> 为根的子树至少 <span class="math inline">\(i\)</span> 对点匹配的方案数，<span class="math inline">\(sum_0(u),sum_1(u)\)</span> 表示以 <span class="math inline">\(u\)</span> 为根的子树里白/黑点的个数，树形DP。先背包合并： <span class="math display">\[
f_*(u,i+j)=\sum_{i=0}^{size(u)}\sum_{j=0}^{size(v)}f(u,i)\times f(v,j)
\]</span></p>
<p>然后假设 <span class="math inline">\(u\)</span> 为黑点（白点同理），选出子树里未匹配的白点匹配： <span class="math display">\[
f_*(u,i+1)=f(u,i+1)+f(u,i)\times (sum_0(u)-i)
\]</span></p>
<p>DP 之后 <span class="math inline">\(F(i)=f(1,i)\times(n-i)!\)</span>（剩下的点任意匹配）。总复杂度 <span class="math inline">\(\mathcal O(n^2)\)</span>。</p>
<h1 id="日-6">17日</h1>
<h2 id="cf840d-destiny">CF840D Destiny</h2>
<p><a href="https://www.luogu.com.cn/problem/CF840D">题目</a></p>
<p>主席树。</p>
<p><span class="math inline">\(k\)</span> 很小，先建立主席树，维护权值区间内的数出现次数和。差分得到区间，每次尽量走可能有答案左区间。</p>
<p>复杂度 <span class="math inline">\(\mathcal O(nk\log n)\)</span>，相当于 <span class="math inline">\(k\)</span> 次单点查询。</p>
<h2 id="p5459-bjoi2016回转寿司">P5459 [BJOI2016]回转寿司</h2>
<p><a href="https://www.luogu.com.cn/problem/P5459">题目</a></p>
<p>离散化 + 树状数组。</p>
<p>前缀和一下，其实就是找 <span class="math inline">\(j&lt;i\)</span> 且 <span class="math inline">\(s_i-R\le s_j\le s_i-L\)</span> 的 <span class="math inline">\((i,j)\)</span> 点对个数。</p>
<p>离散化记得把 <span class="math inline">\(s_i-L\)</span>，<span class="math inline">\(s_i-R-1\)</span> 一块离散化，用 <code>unordered_map</code> 留下映射关系，然后就可以上树状数组了，复杂度 <span class="math inline">\(\mathcal O(n\log^2n)\)</span>。</p>
<h2 id="cf896c-willem-chtholly-and-seniorious">CF896C Willem, Chtholly and Seniorious</h2>
<p><a href="https://www.luogu.com.cn/problem/CF896C">题目</a></p>
<p>珂朵莉树。</p>
<p>就是将相邻的相同元素作为一个元素，用 <code>set</code> 维护，各种操作暴力。只有在有区间推平操作且<strong>数据随机</strong>的情况使用，此时复杂度接近 <span class="math inline">\(\mathcal O(n\log n)\)</span>。</p>
<h2 id="p1856-usaco5.5矩形周长picture">P1856 [USACO5.5]矩形周长Picture</h2>
<p><a href="https://www.luogu.com.cn/problem/P1856">题目</a></p>
<p>扫描线。</p>
<p>求矩形并的周长。先纵向扫描线，同一纵坐标的线段保证先加后减，每操作一条线段增加的答案是覆盖长度变化值的绝对值。横向再做一遍就好了。</p>
<h2 id="cf558e-a-simple-task">CF558E A Simple Task</h2>
<p><a href="https://www.luogu.com.cn/problem/CF558E">题目</a></p>
<p>珂朵莉树。</p>
<p>比 CF896C 还简单，直接用长为 26 的数组维护。</p>
<h1 id="日-7">21日</h1>
<h2 id="at2062-agc005d-k-perm-counting">AT2062 [AGC005D] ~K Perm Counting</h2>
<p><a href="https://www.luogu.com.cn/problem/AT2062">题目</a></p>
<p>容斥 + DP。</p>
<p>设 <span class="math inline">\(F(i)\)</span> 为有 <span class="math inline">\(i\)</span> 个位置不合法的方案数，容斥（反演）一下就是求 <span class="math inline">\(\sum_{i=0}^n(-1)^iF(i)\)</span>。</p>
<p>要求 <span class="math inline">\(F(i)\)</span>。每个位置 <span class="math inline">\(i\)</span> 放 <span class="math inline">\(i-k\)</span> 或 <span class="math inline">\(i+k\)</span>，会影响到其它的位置。</p>
<p>把坐标看作一列点，值也看成一列点，点 <span class="math inline">\(i\)</span> 和值 <span class="math inline">\(i\pm k\)</span> 连边，可以发现这是个二分图上 <span class="math inline">\(2k\)</span> 条链。</p>
<p>要选 <span class="math inline">\(i\)</span> 个点不合法，也就是坐标点向值点连边，但是坐标点和值点都至多连一条边。</p>
<p>把所有链拎出来并连成一条 <span class="math inline">\(2n\)</span> 的大链，设 <span class="math inline">\(f(i,j,0/1)\)</span> 表示前 <span class="math inline">\(i\)</span> 个点连了 <span class="math inline">\(j\)</span> 条边并且 <span class="math inline">\((i-1,i)\)</span> 这条边是否连上的方案数。</p>
<p>转移就很简单了： <span class="math inline">\(\begin{cases}f(i,j,0)=f(i-1,j,0)+f(i-1,j,1)\\f(i,j,1)=f(i-1,j-1,0)\end{cases}\)</span>，注意 <span class="math inline">\(i\)</span> 为链的开头时 <span class="math inline">\(f(i,j,1)=0\)</span>。</p>
<p>那么 <span class="math inline">\(F(i)=(f(2n,i,0)+f(2n,i,1))\times (n-i)!\)</span>，其中 <span class="math inline">\((n-i)!\)</span> 表示合法的点随便放。</p>
<p>复杂度 <span class="math inline">\(\mathcal O(n^2)\)</span>。</p>
<h1 id="日-8">22日</h1>
<h2 id="p4097-heoi2013segment">P4097 [HEOI2013]Segment</h2>
<p><a href="https://www.luogu.com.cn/problem/P4097">题目</a></p>
<p>李超线段树。</p>
<p>板子题。就是用线段树每个节点维护包含该区间最优线段（暴露在最高折线中横坐标跨度最大），插入线段时与原最优线段对交点分类讨论，查询就用 <span class="math inline">\(\log n\)</span> 个节点的最优线段都更新一遍。</p>
<p>具体见 <a href="https://www.luogu.com.cn/blog/_post/232133">George1123 的题解</a>。</p>
<p>每插入一条线段，会分到 <span class="math inline">\(\log n\)</span> 个节点里，而每个节点都需要 <span class="math inline">\(\mathcal O(\log n)\)</span> 的时间对所有子区间判断新线段是否为最优线段，所以单次插入复杂度 <span class="math inline">\(\mathcal O(\log^2 n)\)</span>；查询显然 <span class="math inline">\(\mathcal O(\log n)\)</span>。</p>
<h1 id="日-9">23日</h1>
<h2 id="p4198-楼房重建">P4198 楼房重建</h2>
<p><a href="https://www.luogu.com.cn/problem/P4198">题目</a></p>
<p>分块（正解是线段树）。</p>
<p>显然每个点转化成斜率。分块的话每个块内维护一个单调递增的序列，序列上二分来合并每个块，复杂度 <span class="math inline">\(\mathcal O(n\sqrt{n}\log n)\)</span> 或者 <span class="math inline">\(\mathcal O(n\sqrt{n\log n})\)</span>，实测前者更快。</p>
<p>线段树做法是维护区间最大值的该区间答案，每次合并两个区间就是在右区间上二分，复杂度 <span class="math inline">\(\mathcal O(n\log^2n)\)</span>。</p>
<h1 id="日-10">26日</h1>
<h2 id="p2056-zjoi2007捉迷藏">P2056 [ZJOI2007]捉迷藏</h2>
<p><a href="https://www.luogu.com.cn/problem/P2056">题目</a></p>
<p>括号序 + 线段树。</p>
<p>将树的 <a href="/2021/01/24/笔记-一些树上问题/">括号序</a> 弄出来，然后我们知道两点在括号序上的位置 <span class="math inline">\(pos_u,pos_v\)</span> 之间未匹配的括号数就是距离。去掉匹配的括号，剩下的就是左边若干 <code>)</code> 和右边若干 <code>(</code>，数目记为 <span class="math inline">\(a,b\)</span>。</p>
<p>我们要求黑点之间最大距离，可以类似“最大子段和”用线段树维护。</p>
<p>两个区间合并，左区间是以黑点开头的后缀（<span class="math inline">\(a_r,b_r\)</span>），右区间是以黑点结尾的前缀（<span class="math inline">\(a_l,b_l\)</span>），合并就是 <span class="math inline">\(a_r+b_l+|b_l-a_r|\)</span>，也就是 <span class="math inline">\(\max(a_r+b_r-a_l+b_l,~a_r-b_r+a_l+b_l)\)</span>。</p>
<p>设 <span class="math inline">\(lmax_1\)</span> 为前缀最大 <span class="math inline">\(a+b\)</span>，<span class="math inline">\(lmax_2\)</span> 为前缀最大 <span class="math inline">\(b-a\)</span>，<span class="math inline">\(rmax_1\)</span> 为前缀最大 <span class="math inline">\(a+b\)</span>，<span class="math inline">\(rmax_2\)</span> 为前缀最大 <span class="math inline">\(a-b\)</span>，就可以维护了。</p>
<p>这道题还可以用动态点分治做。</p>
<h1 id="日-11">28日</h1>
<h2 id="sp2916-gss5---can-you-answer-these-queries-v">SP2916 GSS5 - Can you answer these queries V</h2>
<p><a href="https://www.luogu.com.cn/problem/SP2916">题目</a></p>
<p>猫树。</p>
<p>其实是可以线段树做，每次询问对于区间 <span class="math inline">\([l_1,r_1]\)</span>、<span class="math inline">\([l_2,r_2]\)</span> 是否重叠、答案区间的两个端点是否在重叠区间，分类讨论一下。</p>
<p><a href="https://www.luogu.com.cn/blog/yestoday/mao-shu">猫树讲解</a>。为了练一下猫树，考虑把线段树换成猫树。猫树上就需要维护端点到 <span class="math inline">\(mid\)</span> 的权值和、包含端点的最大子段和，以及两者的前缀最大值。虽然单次询问变成 <span class="math inline">\(\mathcal O(1)\)</span> 了，可惜在这题没啥优势。</p>
<h2 id="at2370-agc013d-piling-up">AT2370 [AGC013D] Piling Up</h2>
<p><a href="https://www.luogu.com.cn/problem/AT2370">题目</a></p>
<p>计数DP。</p>
<p>设白球 <span class="math inline">\(x\)</span> 个，则黑球 <span class="math inline">\(n-x\)</span> 个，<code>cc</code> 表示两次取球颜色，手玩一下，可以发现：</p>
<ul>
<li><code>00</code>：<span class="math inline">\((x,n-x)\rightarrow(x-1,n-x)\rightarrow(x-1,n-x+1)\)</span>；</li>
<li><code>01</code>：<span class="math inline">\((x,n-x)\rightarrow(x-1,n-x)\rightarrow(x,n-x)\)</span>；</li>
<li><code>10</code>：<span class="math inline">\((x,n-x)\rightarrow(x,n-x-1)\rightarrow(x,n-x)\)</span>；</li>
<li><code>11</code>：<span class="math inline">\((x,n-x)\rightarrow(x,n-x-1)\rightarrow(x+1,n-x-1)\)</span>。</li>
</ul>
<p>设 <span class="math inline">\(f(i,j)\)</span> 表示走 <span class="math inline">\(i\)</span> 步有 <span class="math inline">\(j\)</span> 个白球的方案数，直接 DP 发现会重，因为 <span class="math inline">\(x\)</span> 状态序列为 <code>1 2 3</code> 和 <code>2 3 4</code> 产生的操作序列一样。</p>
<p>这里有个技巧，只统计经过最小值的方案。<code>00</code> 和 <code>01</code> 操作过程中 <span class="math inline">\(x\)</span> 值是会变小的，当 <span class="math inline">\(x=0\)</span> 时就没法通过这两个操作转移了，所以最小值就是 <span class="math inline">\(0\)</span>。</p>
<p>那么设 <span class="math inline">\(f(i,j,0/1)\)</span> 表示走 <span class="math inline">\(i\)</span> 步有 <span class="math inline">\(j\)</span> 个白球、是否经过 <span class="math inline">\(x=0\)</span> 的方案数，初始状态注意 <span class="math inline">\(f(0,0,1)=1\)</span>，<span class="math inline">\(f(0,i,0)=1\)</span>。</p>
<p>另外注意 <code>00</code> 操作是不能在 <span class="math inline">\(x=0\)</span> 处转移的。最后复杂度 <span class="math inline">\(\mathcal O(nm)\)</span>。</p>
<h1 id="日-12">31日</h1>
<h2 id="bzoj2870-最长道路tree">BZOJ#2870 最长道路tree</h2>
<p><a href="https://darkbzoj.tk/problem/2870">题目</a></p>
<p>边分治。</p>
<p>类似点分治，找到最接近重心的边，分成两棵子树来处理，相比点分治的优势就是处理答案简单，且不需要麻烦的容斥。不过会被菊花图卡，所以需要三度化处理。</p>
<p>对于这道题，就是统计答案时维护距离和路径最小值，然后双指针扫两遍。</p>
<p>具体地最好看 <a href="https://darkbzoj.tk/submission/107881">代码</a>。</p>
]]></content>
      <categories>
        <category>刷题记录</category>
      </categories>
  </entry>
  <entry>
    <title>21年1月2日 省选五校联合集训考试二</title>
    <url>/2021/01/05/21%E5%B9%B41%E6%9C%882%E6%97%A5-%E7%9C%81%E9%80%89%E4%BA%94%E6%A0%A1%E8%81%94%E5%90%88%E9%9B%86%E8%AE%AD%E8%80%83%E8%AF%95%E4%BA%8C/</url>
    <content><![CDATA[<p>数论 + 二分图匹配 + ？。</p>
<a id="more"></a>
<h2 id="a-完全平方数">A 完全平方数</h2>
<p><a href="https://sjzezoj.com/problem/202">题目</a></p>
<blockquote>
<p>给出 <span class="math inline">\(n\)</span>，求 <span class="math inline">\(a+b=n\)</span> 且 <span class="math inline">\(ab\)</span> 是完全平方数的 <span class="math inline">\((a,b)\)</span> 方案数。</p>
<p><span class="math inline">\(T\le 200\)</span>，<span class="math inline">\(n\le 10^9\)</span>。</p>
</blockquote>
<p>数论。</p>
<p>设 <span class="math inline">\(a=gx,b=gy\)</span>，其中 <span class="math inline">\(g=\gcd(a,b)\)</span>，那么 <span class="math inline">\(\gcd(x,y)=1\)</span>，<span class="math inline">\(n=g(x+y)\)</span>，<span class="math inline">\(ab=g^2xy\)</span>。</p>
<p>因为 <span class="math inline">\(g^2\)</span> 是完全平方数，所以 <span class="math inline">\(x,y\)</span> 也都必须是完全平方数，所以可以 <span class="math inline">\(\mathcal O(\sqrt{\frac{n}{g}})\)</span> 枚举。</p>
<p>我们可以 <span class="math inline">\(\displaystyle \mathcal O\bigg(\sum_{g|n,}\sqrt{\frac{n}{g}}\bigg)\)</span> 枚举来做了，是 70分。</p>
<p>那么让 <span class="math inline">\(\mu(g)\neq 0\)</span>（即 <span class="math inline">\(g\)</span> 没有平方项因子），且不限制 <span class="math inline">\(x,y\)</span> 互质（可以理解为将 <span class="math inline">\(g\)</span> 中的平方因子移到 <span class="math inline">\(x,y\)</span> 中）。</p>
<p>最后复杂度 <span class="math inline">\(\displaystyle \mathcal O\bigg(\sum_{g|n,\mu(g)\neq 0}\sqrt{\frac{n}{g}}\bigg)\)</span>，上界似乎是几十万。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, sqr, cntp, ans;</span><br><span class="line"><span class="keyword">int</span> pri[N];</span><br><span class="line"><span class="keyword">bool</span> np[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fac;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!np[i]) pri[++cntp] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cntp; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = i * pri[j];</span><br><span class="line">            <span class="keyword">if</span> (k &gt;= N) <span class="keyword">break</span>;</span><br><span class="line">            np[k] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_sq</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="built_in">sqrt</span>(x);</span><br><span class="line">    <span class="keyword">return</span> t * t == x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> lim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= lim; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = lim - (i * i);</span><br><span class="line">        <span class="keyword">if</span> (j &lt; i * i) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (!is_sq(j)) <span class="keyword">continue</span>;</span><br><span class="line">        ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    get_prime();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;0\n&quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        ans = <span class="number">0</span>, fac.clear();</span><br><span class="line">        <span class="keyword">int</span> t = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cntp; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t % pri[i]) <span class="keyword">continue</span>;</span><br><span class="line">            fac.push_back(pri[i]);</span><br><span class="line">            <span class="keyword">while</span> (t % pri[i] == <span class="number">0</span>) t /= pri[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t &gt; <span class="number">1</span>) fac.push_back(t);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxn = <span class="number">1</span> &lt;&lt; (<span class="keyword">int</span>)fac.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; maxn; ++s) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)fac.size(); ++i)</span><br><span class="line">                <span class="keyword">if</span> (s &amp; (<span class="number">1</span> &lt;&lt; i)) d *= fac[i];</span><br><span class="line">            calc(n / d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="b-素数">B 素数</h2>
<p><a href="https://sjzezoj.com/problem/203">题目</a></p>
<blockquote>
<p>有 <span class="math inline">\(n\)</span> 张不同的卡片，每张有正整数<span class="math inline">\(a_i\)</span>。进行 <span class="math inline">\(m\)</span> 轮操作，每轮操作选 <span class="math inline">\(2\)</span> 张卡片，要求卡片上的数之和是素数，并将这 <span class="math inline">\(2\)</span> 张卡片标记。问 <span class="math inline">\(m\)</span> 轮之后最多标记多少张卡片？</p>
<p><span class="math inline">\(1\le n,m\le 3000\)</span>，<span class="math inline">\(1\le a_i\le 10^6\)</span>。</p>
</blockquote>
<p>二分图匹配。</p>
<p>贪心地想，前几次选取没标记的一对卡片标记，剩余操作再每次标记一张。</p>
<p>观察匹配条件，发现 <span class="math inline">\(\ge 2\)</span> 的素数都是奇数，只能是一个奇数和一个偶数。去掉 <span class="math inline">\(1\)</span> 后，剩下的卡片就可以建成二分图。</p>
<p>再考虑 <span class="math inline">\(1\)</span>：两个 <span class="math inline">\(1\)</span> 可以匹配，也可以与其他偶数匹配。所以优先让其他数字跑二分图最大匹配，再把 <span class="math inline">\(1\)</span> 当做奇数点加到图里再跑一遍（不清空）。</p>
<p>求出来所以贡献为 <span class="math inline">\(2\)</span> 的点，剩下的满足要求的点贡献为 <span class="math inline">\(1\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">4e6</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">int</span> head[N], nxt[N], to[N], flow[N];</span><br><span class="line">    Graph() : cnt(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        nxt[++cnt] = head[u], to[cnt] = v, flow[cnt] = w, head[u] = cnt;</span><br><span class="line">        nxt[++cnt] = head[v], to[cnt] = u, flow[cnt] = <span class="number">0</span>, head[v] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; G;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, tot, cntp, cnt1, one, S, T;</span><br><span class="line"><span class="keyword">int</span> a[N], pri[M];</span><br><span class="line"><span class="keyword">bool</span> np[M], can[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e6</span>;</span><br><span class="line">    np[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= maxn; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!np[i]) pri[++cntp] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cntp &amp;&amp; i * pri[j] &lt;= maxn; ++j) &#123;</span><br><span class="line">            np[i * pri[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MaxFlow &#123;</span><br><span class="line">    <span class="keyword">int</span> cur[N], deep[N];</span><br><span class="line">    <span class="keyword">bool</span> inq[N];</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i)</span><br><span class="line">            cur[i] = G.head[i], deep[i] = INF, inq[i] = <span class="literal">false</span>;</span><br><span class="line">        q.push(S), deep[S] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q.front();</span><br><span class="line">            q.pop(), inq[u] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = G.head[u]; i; i = G.nxt[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = G.to[i];</span><br><span class="line">                <span class="keyword">if</span> (G.flow[i] &amp;&amp; deep[v] &gt; deep[u] + <span class="number">1</span>) &#123;</span><br><span class="line">                    deep[v] = deep[u] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!inq[v]) q.push(v), inq[v] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deep[T] != INF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> lim)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == T || !lim) <span class="keyword">return</span> lim;</span><br><span class="line">        <span class="keyword">int</span> rest = lim;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = cur[u]; i; i = G.nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G.to[i];</span><br><span class="line">            <span class="keyword">if</span> (deep[v] != deep[u] + <span class="number">1</span> || !G.flow[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> t = dfs(v, min(rest, G.flow[i]));</span><br><span class="line">            <span class="keyword">if</span> (!t) deep[v] = INF;</span><br><span class="line">            G.flow[i] -= t, G.flow[i ^ <span class="number">1</span>] += t, rest -= t;</span><br><span class="line">            <span class="keyword">if</span> (!rest) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lim - rest;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxflow = <span class="number">0</span>, t;</span><br><span class="line">        <span class="keyword">while</span> (bfs()) &#123;</span><br><span class="line">            <span class="keyword">while</span> ((t = dfs(S, INF))) maxflow += t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxflow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> MaxFlow::Dinic;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tot = cnt1 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(can, <span class="number">0</span>, <span class="keyword">sizeof</span> can);</span><br><span class="line">    G.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    get_prime();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">        clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        tot = n, S = ++tot, T = ++tot, one = ++tot;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                ++cnt1;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                G.add(S, i, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a[j] &amp; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (np[a[i] + a[j]]) <span class="keyword">continue</span>;</span><br><span class="line">                    G.add(i, j, <span class="number">1</span>);</span><br><span class="line">                    can[i] = can[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> G.add(i, T, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mf = Dinic();</span><br><span class="line">        <span class="keyword">if</span> (cnt1) &#123;</span><br><span class="line">            can[one] |= cnt1 &gt; <span class="number">1</span>;</span><br><span class="line">            G.add(S, one, cnt1);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] == <span class="number">1</span> || np[a[i] + <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                G.add(one, i, <span class="number">1</span>);</span><br><span class="line">                can[one] = can[i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> t = Dinic(), c1 = cnt1;</span><br><span class="line">            mf += t, c1 -= t;</span><br><span class="line">            mf += c1 / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后这里细节很多</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) sum += can[i];</span><br><span class="line">        sum += cnt1 * can[one];</span><br><span class="line">        <span class="keyword">if</span> (mf &gt;= m) ans = m * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mf * <span class="number">2</span> &gt;= sum) ans = sum;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = min(sum, m + mf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="c-广播">C 广播</h2>
<p><a href="https://sjzezoj.com/problem/204">题目</a></p>
]]></content>
      <categories>
        <category>比赛</category>
      </categories>
  </entry>
  <entry>
    <title>21年1月30日 模拟赛</title>
    <url>/2021/01/30/21%E5%B9%B41%E6%9C%8830%E6%97%A5-%E6%A8%A1%E6%8B%9F%E8%B5%9B/</url>
    <content><![CDATA[<p>数论 + 斐波那契循环节 + 计数。</p>
<a id="more"></a>
<h2 id="a-猫哭了你哭了吗">A 猫哭了，你哭了吗？</h2>
<p><a href="https://www.luogu.com.cn/problem/T166106">题目</a></p>
<p><a href="https://www.luogu.com.cn/problem/CF1030G">原题 CF1030G</a></p>
<blockquote>
<p>给出长为 <span class="math inline">\(n\)</span> 的均为质数的数列 <span class="math inline">\(p_1\dots p_n\)</span>，由这个数列可以生成的数列 <span class="math inline">\(f\)</span> 满足：<span class="math inline">\(f_i^{(0)}=x_i\)</span>，<span class="math inline">\(f_i^{(k)}=(a_if_i^{(k-1)}+b_i)\bmod p_i\)</span>，其中 <span class="math inline">\(a_i,b_i,x_i\)</span> 是你选定的 <span class="math inline">\([0,p_i)\)</span> 范围的数。求可以生成的不同数列的个数最大值。</p>
<p><span class="math inline">\(n\le 2\times 10^5\)</span>，<span class="math inline">\(p_i\le 2\times 10^6\)</span>。</p>
</blockquote>
<p><del>我确实哭了。</del></p>
<p>对于某一个 <span class="math inline">\(i\)</span>，设 <span class="math inline">\(A=a_i,B=b_i,X=x_i,P=p_i\)</span>，那么 <span class="math display">\[
f_i\equiv Af_{i-1}+B\pmod P
\]</span> 我们<del>显然</del>啊不<del>猜到</del> <span class="math inline">\(f_i\)</span> 的变化轨迹是个 <span class="math inline">\(\rho\)</span> 型环。</p>
<p>设每个 <span class="math inline">\(\rho\)</span> 型环柄长 <span class="math inline">\(d_i\)</span>，圆环周长 <span class="math inline">\(l_i\)</span>，合并这些环就是 <span class="math inline">\(\max d_i+\operatorname{lcm}l_i\)</span>。</p>
<blockquote>
<p>套路地，联立 <span class="math inline">\((f_i+k)\equiv A(f_{i-1}+k)\pmod P\)</span>，解得 <span class="math inline">\(\displaystyle k\equiv\frac{B}{A-1}\)</span>。</p>
<p>已知 <span class="math inline">\(f_0=X\)</span>，所以 <span class="math inline">\(\displaystyle f_i\equiv A^iX+\frac{(A^i-1)B}{A-1}\)</span>。 <span class="math display">\[
\begin{aligned}
f_n-f_m&amp;\equiv(A^n-A^m)X+\frac{(A^n-A_m)B}{A-1}\\
&amp;\equiv A^m(A^{n-m}-1)\Big(X+\frac{B}{A-1}\Big)\\
&amp;\equiv 0
\end{aligned}
\]</span></p>
<p>其中 <span class="math inline">\(n&gt;m\ge0\)</span>。这几个部分都考虑一下。</p>
</blockquote>
<p>所以可以考虑对 <span class="math inline">\(a_i\)</span> 分类讨论：</p>
<ul>
<li><p><span class="math inline">\(a_i=0\)</span>，显然 <span class="math inline">\(d_i=1\)</span>，<span class="math inline">\(l_i=0\)</span>；</p></li>
<li><p><span class="math inline">\(a_i=1\)</span>，直接进入环，<span class="math inline">\(d_i=0\)</span>，<span class="math inline">\(l_i=p_i\)</span>；</p></li>
<li><p><span class="math inline">\(a_i&gt;1\)</span>，此时 <span class="math inline">\(d_i=0\)</span>，可以得到 <span class="math inline">\((A^n-1)\Big(X+\frac{B}{A-1}\Big)\equiv0\)</span>。</p>
<p><span class="math inline">\(\Big(X+\frac{B}{A-1}\Big)\equiv0\)</span> 时 <span class="math inline">\(l=0\)</span>，这是不优的，那么 <span class="math inline">\(A^n-1\equiv0\)</span>，费马小定理得到 <span class="math inline">\(n=\varphi(P)=P-1\)</span>。即 <span class="math inline">\(l=p_i-1\)</span>。</p></li>
</ul>
<p>以上几个情况可以定义为选择 <span class="math inline">\(1,2,3\)</span>，我们要对每个 <span class="math inline">\(p_i\)</span> 分配选择，使最大化 <span class="math inline">\(\max d_i+\operatorname{lcm}l_i\)</span>。</p>
<p>由于 <span class="math inline">\(d_i\le1\)</span>，先考虑 <span class="math inline">\(\operatorname{lcm}l_i\)</span>。把 <span class="math inline">\(p_i\)</span> <strong>倒序排序</strong>，设 <span class="math inline">\(s\)</span> 为当前处理过的 <span class="math inline">\(l_i\)</span> 的 <span class="math inline">\(\operatorname{lcm}\)</span>，如果 <span class="math inline">\(s\)</span> 没有包含 <span class="math inline">\(p_i\)</span> 这个质因子，我们肯定是尽量选选择 <span class="math inline">\(2\)</span>；否则选选择 <span class="math inline">\(3\)</span>。</p>
<p>怎么分配选择 <span class="math inline">\(1\)</span> 的这个 <span class="math inline">\(d_i=1\)</span> 呢？找一个最没用的。具体地，记录 <span class="math inline">\(s\)</span> 每一个质因数的最高次幂，已经包含这个最高次幂的 <span class="math inline">\(l_i\)</span> 的个数。再扫一遍所有 <span class="math inline">\(l_i\)</span>，如果去掉它对 <span class="math inline">\(s\)</span> 无影响，就令它为选择 <span class="math inline">\(1\)</span>。</p>
<p><strong>代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">power</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = (LL)res * x % P;</span><br><span class="line">        x = (LL)x * x % P, y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, cntp, ans;</span><br><span class="line"><span class="keyword">int</span> a[N], pri[N], ma[N], cnt[N];</span><br><span class="line"><span class="keyword">bool</span> np[N], wc[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_prime</span><span class="params">(<span class="keyword">int</span> lim)</span> </span>&#123;</span><br><span class="line">    np[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= lim; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!np[i]) pri[++cntp] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cntp &amp;&amp; pri[j] * i &lt;= lim; ++j) &#123;</span><br><span class="line">            np[pri[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c &gt; ma[p]) ma[p] = c, cnt[p] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == ma[p]) ++cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">deco</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cntp &amp;&amp; pri[i] * pri[i] &lt;= x; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = pri[i];</span><br><span class="line">        <span class="keyword">if</span> (x % p) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x % p == <span class="number">0</span>) x /= p, ++c;</span><br><span class="line">        update(p, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) update(x, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!np[x]) &#123; <span class="comment">// bug</span></span><br><span class="line">        <span class="keyword">if</span> (ma[x] == <span class="number">1</span> &amp;&amp; cnt[x] == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cntp &amp;&amp; pri[i] * pri[i] &lt;= x; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = pri[i];</span><br><span class="line">        <span class="keyword">if</span> (x % p) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x % p == <span class="number">0</span>) x /= p, ++c;</span><br><span class="line">        <span class="keyword">if</span> (ma[p] == c &amp;&amp; cnt[p] == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span> &amp;&amp; ma[x] == <span class="number">1</span> &amp;&amp; cnt[x] == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// bug</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    sort(a+<span class="number">1</span>, a+n+<span class="number">1</span>), reverse(a+<span class="number">1</span>, a+n+<span class="number">1</span>);</span><br><span class="line">    get_prime(a[<span class="number">1</span>]);</span><br><span class="line">    ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ma[a[i]]) deco(a[i] - <span class="number">1</span>), wc[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> update(a[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cntp; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ma[pri[i]]) <span class="keyword">continue</span>;</span><br><span class="line">        ans = (LL)ans * power(pri[i], ma[pri[i]]) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((wc[i] &amp;&amp; check(a[i] - <span class="number">1</span>)) || (!wc[i] &amp;&amp; check(a[i]))) &#123;</span><br><span class="line">            ++ans;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="b-迫害">B 迫害</h2>
<p><a href="https://www.luogu.com.cn/problem/T166445">题目</a></p>
<blockquote>
<p>已知 <span class="math inline">\(g_0=a\)</span>，<span class="math inline">\(g_1=b\)</span>，<span class="math inline">\(g_i=3g_{i-1}-g_{i-2}\)</span>；<span class="math inline">\(f(n,0)=n\)</span>，<span class="math inline">\(f(n,k)=f(g(n),k-1)\)</span>。</p>
<p>给出 <span class="math inline">\(a,b,n,k,p\)</span>，求 <span class="math inline">\(f(n,k)\bmod p\)</span>。</p>
<p><span class="math inline">\(1\le T\le 1000\)</span>，<span class="math inline">\(1\le n\le10^9\)</span>，<span class="math inline">\(1\le k\le 100\)</span>，<span class="math inline">\(0\le a,b&lt;p\)</span>。</p>
</blockquote>
<p>斐波那契循环节 + 矩阵快速幂。</p>
<p>考场上想写 <span class="math inline">\(60\)</span> 分，随机化找循环节 + <span class="math inline">\(\mathcal O(\log n)\)</span> 快速幂 + 巨大常数，混了个 <span class="math inline">\(35\)</span> 分。</p>
<p>求斐波那契循环节的确定性算法及证明还没懂，先咕。</p>
<h2 id="c-寿司晚宴">C 寿司晚宴</h2>
<p><a href="https://www.luogu.com.cn/problem/T166447">题目</a></p>
<blockquote>
<p>有 <span class="math inline">\(n\)</span> 个寿司排成一排，<span class="math inline">\(m\)</span> 个人，每个人有一个喜欢的寿司，可以以某个寿司的左右侧为起点，朝向喜欢的寿司移动，直到取走并离开；若已经被其他人拿走，方向不变继续走，取走之后遇见的第一份未被取走的寿司后离开，或者直到边界。</p>
<p>求所有人都能取得寿司的方案数。</p>
<p><span class="math inline">\(m\le n\le 10^5\)</span>。</p>
</blockquote>
<p>先接链成环，在 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(n\)</span> 之间加入 <span class="math inline">\(0\)</span> 号寿司表示断点。</p>
<p>考虑每个人的方向和起点，排列方案数为 <span class="math inline">\(2^m(n+1)^m\)</span>，除以轮换数 <span class="math inline">\(n+1\)</span> 就是圆排列方案数。</p>
<p>然后我们钦定每个人都能拿到寿司，显然没有人会拿的寿司有 <span class="math inline">\(n-m+1\)</span> 个并且不再某个人的路径上，即可以放断点的方案数。</p>
<p>所以最后方案数为： <span class="math display">\[
2^m(n+1)^{m-1}(n-m+1)
\]</span> 代码就没必要了。</p>
]]></content>
      <categories>
        <category>比赛</category>
      </categories>
  </entry>
  <entry>
    <title>21年1月3日 省选五校联合集训考试三</title>
    <url>/2021/01/03/21%E5%B9%B41%E6%9C%883%E6%97%A5-%E7%9C%81%E9%80%89%E4%BA%94%E6%A0%A1%E8%81%94%E5%90%88%E9%9B%86%E8%AE%AD%E8%80%83%E8%AF%95%E4%B8%89/</url>
    <content><![CDATA[<p>计数 + SAM + 计数。</p>
<p><span class="math inline">\(\rm \color{black}{E}\color{red}{ternalAlexander}\)</span> 出的神仙模拟赛，我再一次爆零垫底了，不过题目质量很高👍。</p>
<a id="more"></a>
<p><a href="https://renamoe.gitee.io/upload/solutionbyEA.pdf">EA 的官方题解</a></p>
<h2 id="a-通用计数">A 通用计数</h2>
<p><a href="https://sjzezoj.com/problem/214">题目</a></p>
<blockquote>
<p>求有多少不同的包含 <span class="math inline">\(n\)</span> 个点的有标号无根树，满足：对于任何一个点 <span class="math inline">\(x\)</span> ，都存在点 <span class="math inline">\(y\)</span> 使得 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 之间有一条边且 <span class="math inline">\(|x-y| = 1\)</span>。</p>
<p><span class="math inline">\(2\le n\le 10^5\)</span>。</p>
</blockquote>
<p>容斥 + 多项式求逆。</p>
<p>转化题意将带标号的点 <span class="math inline">\(1\dots n\)</span> 依次连成一条链，将其划分，并且一个点的两条边不能同时被割去，然后连接成一棵新树。</p>
<p>有个引理：<span class="math inline">\(n\)</span> 个点 <span class="math inline">\(k\)</span> 个连通块形成生成树方案数为 <span class="math inline">\(n^{n-2}\prod_{i=1}^k a_i\)</span>。</p>
<p>枚举合法划分方案（看做一个割掉边的集合）<span class="math inline">\(P\)</span>，记 <span class="math inline">\(W(P)\)</span> 为划分 <span class="math inline">\(P\)</span> 产生的方案数，这里提出一个 <span class="math inline">\(n^{-2}\)</span> 后面再乘回去，所以 <span class="math inline">\(W(P)=\prod_{i=1}^k a_in\)</span>。</p>
<p>设 <span class="math inline">\(n\)</span> 个点满足要求的答案为 <span class="math inline">\(F(n)\times n^{-2}\)</span>，现在要计算 <span class="math inline">\(F(n)\)</span>。</p>
<p>直接计和会发现有的方案重复了，因为没有限定连的是那条边，两个连通块可能重新连上割掉的边合并成一个。</p>
<p>考虑容斥，然后推式子（这里 <span class="math inline">\(Q\)</span> 是 <span class="math inline">\(P\)</span> 的父集代表 <span class="math inline">\(P\)</span> 进一步划分得到的方案）： <span class="math display">\[
\begin{aligned}
F(n)&amp;=\sum_{P}\sum_{P\subset Q}(-1)^{|Q|-|P|}W(Q)\\
&amp;=\sum_{Q}W(Q)\sum_{P\subset Q}(-1)^{|Q|-|P|}\\
\end{aligned}\\
\]</span> 设 <span class="math inline">\(D(P)=\sum_{P\subset Q}(-1)^{|Q|-|P|}\)</span>，表示 <span class="math inline">\(P\)</span> 的容斥系数。</p>
<p>若 <span class="math inline">\(P\)</span> 将链划分成连通块 <span class="math inline">\(\{a_1,a_2\dots a_k\}\)</span>，发现各个连通块的 <span class="math inline">\(D\)</span> 值相互不影响，于是得到 <span class="math inline">\(D(P)=\prod_{i=1}^kD(\{a_i\})\)</span>。</p>
<p>而连通块的 <span class="math inline">\(D\)</span> 值是可以 DP 得到的，这里变量为数值代表连通块大小： <span class="math display">\[
\begin{aligned}
D(1)&amp;=0\\
D(2)&amp;=1\\
D(i)&amp;=D(i-1)-D(i-2)
\end{aligned}
\]</span> 递推式可以理解为：为了合法最后一条边不能断，对于一条链最后倒数第二条边，断掉对系数可以产生 <span class="math inline">\(-1\)</span> 的贡献。</p>
<p>对 <span class="math inline">\(F\)</span> 我们进一步得到： <span class="math display">\[
\begin{aligned}
F(n)&amp;=\sum_{Q}W(Q)D(Q)\\
&amp;=\sum_{Q}\prod_{i=1}^ka_inD(a_i)\\
\end{aligned}
\]</span> 再巧妙地设 <span class="math inline">\(G(i)=i\cdot n\cdot D(i)\)</span>，我们只要枚举第一个连通块的大小： <span class="math display">\[
\begin{aligned}
F(n)&amp;=\sum_{Q}\prod_{i=1}^kG(i)\\
&amp;=\sum_{i=1}^nG(i)F(n-i)
\end{aligned}
\]</span> 哇塞是个卷积，<span class="math inline">\(G\)</span> 可以由 <span class="math inline">\(D\)</span> 得到，那么就可以分治 FFT 得到 <span class="math inline">\(F(n)\)</span> 了。</p>
<p>或者（这里）用多项式求逆解决，计算 <span class="math inline">\((1-G(x))^{-1}\)</span> 即可。</p>
<p>复杂度 <span class="math inline">\(\mathcal O(n\log n)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略一大堆多项式模板代码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">poly_inv</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> D[N], F[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    D[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) D[i] = (D[i - <span class="number">1</span>] - D[i - <span class="number">2</span>] + P) % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) F[i] = (LL)i * n % P * D[i] % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) F[i] = (P - F[i]) % P;</span><br><span class="line">    F[<span class="number">0</span>] += <span class="number">1</span>;</span><br><span class="line">    poly_inv(F, n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (LL)F[n] * power((LL)n * n % P, P - <span class="number">2</span>) % P);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="b-屏蔽词汇">B 屏蔽词汇</h2>
<p><a href="https://sjzezoj.com/problem/215">题目</a></p>
<blockquote>
<p>给出串 <span class="math inline">\(S\)</span>，每次询问 <span class="math inline">\(S\)</span> 的一个子串 <span class="math inline">\(T\)</span>，求出至少要往 <span class="math inline">\(S\)</span> 中插入多少个分隔符使得 <span class="math inline">\(T\)</span> 不再是 <span class="math inline">\(S\)</span> 的子串。</p>
<p><span class="math inline">\(3\le n,q\le 10^5\)</span>。</p>
</blockquote>
<p>SAM + 线段树合并。</p>
<p>贪心的想，每次找到 <span class="math inline">\(T\)</span> 在 <span class="math inline">\(S\)</span> 中最早出现的位置，然后在最后一个字符之前加一个分隔符，继续做下去。（考场上没想到线段树合并就删了 SAM 像这样写了 <span class="math inline">\(\mathcal O(n^2)\)</span> 暴力。）</p>
<p>那么先把 <span class="math inline">\(S\)</span> 串扔到 SAM 里面，考虑维护子串出现位置集合，那就每个节点挂一棵线段树。</p>
<p>建出 parent 树后，每个节点就需要维护子树中所有线段树的并，就用到线段树合并。</p>
<p>这样对于询问，在 parent 树上倍增找到代表子串 <span class="math inline">\(T\)</span> 的节点，然后贪心做。</p>
<p>同时需要将计算过的答案记忆化。</p>
<p>复杂度是 <span class="math inline">\(\mathcal O((n+q)\sqrt{n}\log n)\)</span> 的，证明：</p>
<blockquote>
<p>设询问子串 <span class="math inline">\(T\)</span> 长度为 <span class="math inline">\(L\)</span>，分类讨论：</p>
<ul>
<li><span class="math inline">\(L\le \sqrt{n}\)</span>：我们贪心一次的复杂度 <span class="math inline">\(\mathcal O(c\log n)\)</span>，<span class="math inline">\(c\)</span> 为 <span class="math inline">\(T\)</span> 的出现次数，<span class="math inline">\(c\)</span> 上界是 <span class="math inline">\(\mathcal O(n)\)</span> 的；但是加上记忆化之后，发现长度 <span class="math inline">\(\le \sqrt{n}\)</span> 的串一共 <span class="math inline">\(n\sqrt{n}\)</span> 个，总复杂度 <span class="math inline">\(\mathcal O(n\sqrt{n}\log n)\)</span>。</li>
<li><span class="math inline">\(L&gt;\sqrt{n}\)</span>：贪心时每次向后跳 <span class="math inline">\(L-1\)</span> 个单位，所以产生贡献的位置集合大小不超过 <span class="math inline">\(\sqrt{n}\)</span>，总复杂度 <span class="math inline">\(\mathcal O(q\sqrt{n}\log n)\)</span>。</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">6e6</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, Q;</span><br><span class="line"><span class="keyword">int</span> id[N];</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mem[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">int</span> head[N], nxt[N], to[N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        ++cnt, nxt[cnt] = head[u], to[cnt] = v, head[u] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; G;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    <span class="keyword">int</span> rt[N], sum[M], ls[M], rs[M];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> suc)</span> </span>&#123;</span><br><span class="line">        sum[suc] = sum[ls[suc]] + sum[rs[suc]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> &amp;suc, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!suc) suc = ++tot;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            sum[suc] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (p &lt;= mid) modify(ls[suc], l, mid, p);</span><br><span class="line">        <span class="keyword">else</span> modify(rs[suc], mid + <span class="number">1</span>, r, p);</span><br><span class="line">        push_up(suc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!u || !v) <span class="keyword">return</span> u + v;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            sum[u] += sum[v];</span><br><span class="line">            <span class="keyword">return</span> u;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, suc = ++tot;</span><br><span class="line">        ls[suc] = merge(ls[u], ls[v], l, mid);</span><br><span class="line">        rs[suc] = merge(rs[u], rs[v], mid + <span class="number">1</span>, r);</span><br><span class="line">        push_up(suc);</span><br><span class="line">        <span class="keyword">return</span> suc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!sum[suc]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (p &gt; mid) <span class="keyword">return</span> find(rs[suc], mid + <span class="number">1</span>, r, p);</span><br><span class="line">        <span class="keyword">int</span> res = find(ls[suc], l, mid, p);</span><br><span class="line">        <span class="keyword">if</span> (!res) res = find(rs[suc], mid + <span class="number">1</span>, r, p);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; T;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SuffixAutomaton</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> tot, last;</span><br><span class="line">    <span class="keyword">int</span> link[N], ch[N][<span class="number">26</span>], len[N], fa[N][<span class="number">20</span>];</span><br><span class="line">    SuffixAutomaton() : tot(<span class="number">1</span>), last(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = last, np = last = ++tot;</span><br><span class="line">        len[np] = len[p] + <span class="number">1</span>, T.modify(T.rt[np], <span class="number">1</span>, n, pos);</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; !ch[p][c]) ch[p][c] = np, p = link[p];</span><br><span class="line">        <span class="keyword">if</span> (!p) link[np] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> q = ch[p][c];</span><br><span class="line">            <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>) link[np] = q;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> nq = ++tot;</span><br><span class="line">                <span class="built_in">memcpy</span>(ch[nq], ch[q], <span class="keyword">sizeof</span> ch[q]);</span><br><span class="line">                len[nq] = len[p] + <span class="number">1</span>, link[nq] = link[q];</span><br><span class="line">                link[q] = link[np] = nq;</span><br><span class="line">                <span class="keyword">while</span> (p &amp;&amp; ch[p][c] == q) ch[p][c] = nq, p = link[p];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> np;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= tot; ++i) G.add(link[i], i);</span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fat)</span> </span>&#123;</span><br><span class="line">        fa[u][<span class="number">0</span>] = fat;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">17</span>; ++i) fa[u][i] = fa[fa[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = G.head[u]; i; i = G.nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G.to[i];</span><br><span class="line">            dfs(v, u);</span><br><span class="line">            T.rt[u] = T.merge(T.rt[u], T.rt[v], <span class="number">1</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_fa</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">17</span>; ~i; --i)</span><br><span class="line">            <span class="keyword">if</span> (fa[u][i] &amp;&amp; len[fa[u][i]] &gt;= k) u = fa[u][i];</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; A;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; Q &gt;&gt; (str + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        id[i] = A.insert(str[i] - <span class="string">&#x27;a&#x27;</span>, i);</span><br><span class="line">    A.init();</span><br><span class="line">    <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r, len;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        len = r - l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> x = A.get_fa(id[r], len), i = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (mem[x].count(len)) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; mem[x][len] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = T.find(T.rt[x], <span class="number">1</span>, n, i);</span><br><span class="line">            <span class="keyword">if</span> (!p) <span class="keyword">break</span>;</span><br><span class="line">            ++ans, i = p + len - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mem[x][len] = ans;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="c-数位规划">C 数位规划</h2>
<p><a href="https://sjzezoj.com/problem/216">题目</a></p>
<blockquote>
<p>对于一个长度为 <span class="math inline">\(n\)</span> 的由 <span class="math inline">\(0 \sim 9\)</span> 组成的数字串 <span class="math inline">\(S\)</span>，定义 <span class="math inline">\(S\)</span> 的优秀度为：在 <span class="math inline">\([L,R]\)</span> 范围内的，且在 <span class="math inline">\(S\)</span> 中作为子串出现过的整数的个数。</p>
<p>给出 <span class="math inline">\(L,R,n\)</span>，求所有长度为 <span class="math inline">\(n\)</span> 的 <span class="math inline">\(S\)</span> 的优秀度的之和。</p>
<p><span class="math inline">\(n\le 400\)</span>，<span class="math inline">\(L,R\le 10^{18}\)</span>。</p>
</blockquote>
<p>太难了，先咕着。</p>
]]></content>
      <categories>
        <category>比赛</category>
      </categories>
  </entry>
  <entry>
    <title>CSP2020 游记</title>
    <url>/2020/11/06/CSP2020-%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>多图警告⚠️。</p>
<a id="more"></a>
<h2 id="初赛">初赛</h2>
<p>没啥感觉，水过去了。</p>
<blockquote>
<p>教练：只要你们听话，初赛保你们过。</p>
</blockquote>
<h2 id="复赛">复赛</h2>
<h3 id="day0">day0</h3>
<p>上午坐公交车，晕，睡。</p>
<p>我的手机在 n 老师那里，关着机但是没关闹钟……</p>
<p>上了动车，发现坐在过道，我得坐四五站，但是靠窗的的位置每到一站就换一个人。</p>
<p>后来我就<del>死皮赖脸地</del>坐在靠窗的位置，还好每次来的都是比较和善的大叔，都答应了。</p>
<p>到了燕大，门口有个坡，客车上不去 2333。</p>
<p>那个铭牌生锈的燕大宾馆不见了，取而代之的是闲庭四艺酒店（Four Arts Hotel），wow，全部装修了一番，<del>甲醛的味道</del>书墨的香气蛮浓的。</p>
<p><img src="https://s1.ax1x.com/2020/11/07/B46SjU.jpg" /></p>
<p><img src="https://s1.ax1x.com/2020/11/07/B4yzcT.jpg" /></p>
<p><img src="https://s1.ax1x.com/2020/11/07/B4yx3V.jpg" /></p>
<p><img src="https://s1.ax1x.com/2020/11/07/B4yXhq.jpg" /></p>
<p><img src="https://s1.ax1x.com/2020/11/07/B46PHJ.jpg" /></p>
<p>每一房间都有《宋代书画》，还有《毕业季》（看起来是言情小说？）。</p>
<p><img src="https://s1.ax1x.com/2020/11/07/B46PHJ.jpg" /></p>
<p>下午就开始模拟赛。</p>
<p>T1 算是模拟填数题？细节烦人，刚了两个小时才过大样例，心态大崩。</p>
<p>T2 结论题，打表找半天规律没成，摸了。</p>
<p>T4 数位 DP，推了会儿式子，调了快一个小时，大样例过了。</p>
<p>T3 时间紧，暴力都没写，听说很毒瘤。</p>
<p>和 ywk 一个房间，晚上想迫害他去隔壁房间玩恐怖游戏，没成 qwq。</p>
<p>题解数据发了，T1 写搜索这么轻松？？？T4 我正解写挂，和分块打表一个分？？？T2就这？？？</p>
<p>感觉 CSP 悬啊。<img src="https://cdn.jsdelivr.net/gh/xaoxuu/volantis@1.0.6/img/qq/快哭了.gif" /></p>
<p>不管了，明天再说。</p>
<h3 id="day0.5">day0.5</h3>
<p>失败的开始。</p>
<p>十点多洗完澡往床上一摊，“这个床好软啊~”</p>
<p>翻来覆去一个多小时没睡着，太软了感觉怎么躺都腰肩酸痛（硬板床睡习惯了），十二点时无奈之下下床做了几个俯卧撑，趁着疲惫睡去。</p>
<p>为什么我的鼻子对被子和枕头过敏啊！！！</p>
<p>在梦里都感觉呼吸困难，迷糊的我知道是鼻窦炎发作了，不过为了保证充足的睡眠，决定扛到天亮。</p>
<p>然后就因为差点窒息而被迫清醒了过来。</p>
<p>怎么才 3 点多啊？？？还得睡下去。（居然会有一天觉得睡觉很痛苦。QAQ）</p>
<p>把枕头用外套包起来，把能穿的衣服都穿在身上，被子只盖下半身。喷了一些药，睡。</p>
<p>这一觉还算舒畅，可惜只睡了 3 个小时。ywk 要考 PJ，7 点左右就有人来敲门。</p>
<h3 id="day1">day1</h3>
<p>一个上午都在颓废打音游打雀魂，想补觉没补成。</p>
<p>中午临时冲了杯咖啡，就去考试了。</p>
<p>密码输了五六遍没对，告诉我 <code>()</code> 也是密码？？？</p>
<p>开场<del>大力敲击键盘</del>慢悠悠地建完文件夹，读了半小时题，读完题后懵了。</p>
<p>T1 似乎写个二分在加亿点细节就好，woc 码不出来啊，调不对啊。刚了一个半小时才过大样例，还是悬。</p>
<p>T2 什么算法啊，是模拟吗？乱写一通过了大样例。</p>
<p>只剩 45 分钟了，写 T3 暴力，似乎线段树暴力做还算好写，还剩 15 分钟时调完，不知道能拿多少分。不过后来听说是个图论题。</p>
<p>花五分钟看 T4 发现 20 分白给，慌忙糊了几行。（考后发现把“不降”看成“不降”了，白给的 20 分没了。）</p>
<p>linux 下整理完了，还剩 2 分钟在 win7 发现莫名其妙有个叫 <code>@#</code> 的文件。</p>
<p>考完大脑有点晕。</p>
<hr />
<p>晚上一块去看海。</p>
<p><img src="https://s1.ax1x.com/2020/11/07/BIaxPK.jpg" /></p>
<p><img src="https://s1.ax1x.com/2020/11/07/BIasgg.jpg" /></p>
<p><img src="https://s1.ax1x.com/2020/11/07/BIar8S.jpg" /></p>
<p><img src="https://s3.ax1x.com/2020/12/05/DL74v8.jpg" /></p>
<p>不想吃晚饭，和 wxh，ycs，wgx 一块买了冷饮（本来想买奶茶的），然后寒风中在街边摊位等薯条汉堡。</p>
<p>回宿舍颓颓颓。</p>
<h2 id="后续">后续</h2>
<p>什么信竞题库有了民间数据，T1 85（数据水？），T2 90（破服务器卡常），T3 75，T4 0。</p>
<p>然后牛客似乎也有了，T1 40，T2 95。</p>
<p>洛谷上 T1 也是 40，看了 T1 真的挂没了，T2 被卡常 70，T3 30 比较真实。</p>
<p>这回考的都是什么啊，T1 出题人谁啊！！！</p>
<p>官方成绩出来，数据特特特别水，似乎到处被喷。</p>
<p>最后 100 + 95 + 70 + 0 = 265，辣鸡 RenaMoe。</p>
<p>膜拜 <a href="https://www.luogu.com.cn/user/120033">iuyi</a> 330 分巨佬 Orz。</p>
<h2 id="总结">总结</h2>
<p>虽然这次比赛不怎么重要，并且题目方向比较，但是暴露了不少问题。</p>
<ul>
<li>考试策略依旧不当，T1 写太久，后面题差点没时间写暴力。</li>
<li>代码能力差，主要为 T1 的问题，还是做题少写得慢。</li>
<li>没有对拍，不太会造数据。</li>
</ul>
<p>其它知识能力问题 NOIP 之前可能解决不了多少，毕竟 whk 太差了来机房时间有限。</p>
<p>以后周末多打打 cf 和 oi 赛制模拟赛吧，一定要把自己会的发挥好。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>NOIP2020 游记</title>
    <url>/2020/12/05/NOIP2020-%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p><del>没什么实感啊。</del>我考的什么玩意啊。</p>
<a id="more"></a>
<p><del>这次手机全程在 n 老师那里，没有照片。</del>照片都是 piao 来的。</p>
<h2 id="day-0">day 0</h2>
<p>早上被骗去做 <span class="math inline">\(\rm \color{black}{A}\color{red}{zusaCat}\)</span> 的题 <a href="https://www.luogu.com.cn/problem/U144136">U144136 距离</a>，倍增 + 二分好妙啊，写挂好多细节。</p>
<p>然后还没咋敲板子题就该走了。</p>
<p>火车上想敲板子，有点晕，敲不动，连扫描线都没敲完。</p>
<p>有趣的是今天的伙食：</p>
<p>中午提前去超市买了泡面，特意选了白象的（汤确实好喝），没看清买了金汤酸菜鱼。（谁知道那玩意是辣的啊！）</p>
<p>我是几乎不吃辣的，火车上把面送进嘴里的时候我是绝望的。</p>
<p>或许我当时红着嘴唇、小口又急促地喘气的样子很可笑吧。</p>
<p>算了算了真烦，强迫自己睡了一觉。</p>
<p>这次住首旅京伦酒店，听说是海景房，很期待。</p>
<p><img src="https://s3.ax1x.com/2020/12/05/DLOGkQ.jpg" /></p>
<p>打开房间门，看见了一面巨大的接地窗，能够清晰地看到。。。旁边的工地。</p>
<p>不过比上次的闲庭四艺酒店的空气好多了，在屋子里待着鼻窦炎没有发作。</p>
<p>幸好我爸和我一起来了，带着一套自家的枕头被子，终于能好好睡一觉了。</p>
<p>到秦皇岛的宾馆就该吃晚饭了？时间过得好快，板子题还没咋敲，我慌了。</p>
<p>点了 KFC 的外卖，又眼瞎了，点了个辣堡。不过一点辣味都没有，不知道是不是该高兴。</p>
<p>说实话这 19 块钱的汉堡做得和 石门 六块钱的汉堡差不多，莫名其妙开始想念石门。</p>
<p>晚上继续<del>水裙</del>敲板子，敲了两道然后就该睡觉了？</p>
<h2 id="day-1">day 1</h2>
<p>好像什么都不会就去考试的感觉。</p>
<figure>
<img src="https://s3.ax1x.com/2020/12/05/DLO3Tg.jpg" alt="早上风景还行" /><figcaption aria-hidden="true">早上风景还行</figcaption>
</figure>
<p>早饭没有胃口，但是吃完了差点迟到。</p>
<p>含着糖，算是撑住了没晕车。</p>
<figure>
<img src="https://s3.ax1x.com/2020/12/05/DLzxYD.jpg" alt="考前二中合影" /><figcaption aria-hidden="true">考前二中合影</figcaption>
</figure>
<p>座位号 <code>5-14</code>？我害怕极了。</p>
<p>经考场前得先用免洗洗手液洗手，一不小心挤多了，手上全是酒精，一时还干不了，拿着弄湿的准考证给监考员时有点尴尬。</p>
<p>坐在座位上看见玻璃外面是 <span class="math inline">\(\rm \color{black}{l}\color{red}{hm\_}\)</span>，为了告诉他不要像我一样犯傻，专门打手势告诉他，<del>不知道他懂了没有</del>他只是一直点头。</p>
<p>发现座位右前方是集训队爷，我害怕极了。</p>
<hr />
<p>开考没输错解压密码，好评。</p>
<p>T1，拓扑一下，再手写一下分数，过。</p>
<p>T2，卡住了，用哈希判循环节 <span class="math inline">\(\mathcal O(1)\)</span>，枚举约数 <span class="math inline">\(\mathcal O(\log n)\)</span>，就是不知道怎么二维数点，<span class="math inline">\(\log 26\cdot\log n\)</span> 和 <span class="math inline">\(26\log n\)</span> 能差多少啊！边写边改，写了个 <span class="math inline">\(\mathcal O(26\cdot n\log n)\)</span>，预计 <span class="math inline">\(68\)</span> ~ <span class="math inline">\(84\)</span> 分。</p>
<p>T3，什么鬼玩意，暴力都不会写。</p>
<p>T4，貌似可以倍增？码了半个多小时一个倍增 + 两个二分，发现自己复杂度的瓶颈在于 <span class="math inline">\(\mathcal O(w^k)\)</span> 枚举起点，删掉了。时间不够了，写个朴素的 <span class="math inline">\(30\)</span> 分暴力就跑。</p>
<p>跑个毛线，该交卷了。</p>
<p>恍惚的一下子就结束了。</p>
<hr />
<p>有点失落。</p>
<p>突然想起 T2 二维数点直接二维前缀和就好了，就可以少去那个 <span class="math inline">\(26\)</span> 的常数了。</p>
<p>水群时发现 T1 得写高精（其实考场上想过会不会爆 <code>long long</code>，但是不会构造又懒得写，就不管了）。</p>
<p><a href="https://www.oitiku.com/">信奥题库</a> 好快啊，马上就有了数据，虽然似乎很水。</p>
<p>测了一下，90 + 84 + 0 + 30 = 204。</p>
<p>担心官方数据 T1 会不会被卡成狗。</p>
<p>说实话觉得自己什么都不会。</p>
<p><img src="https://s3.ax1x.com/2020/12/05/DLx25D.png" /></p>
<p>还真就考了高精，我退役就是。</p>
<p><span class="math inline">\(\rm \color{black}{y}\color{red}{ouwike}\)</span> 好强啊，初三就考的比我高。</p>
<figure>
<img src="https://s3.ax1x.com/2020/12/05/DLHkP1.jpg" alt="youwike 考好的秘诀" /><figcaption aria-hidden="true">youwike 考好的秘诀</figcaption>
</figure>
<h2 id="尾声">尾声</h2>
<p>因为高二学考，高一就放假三天。</p>
<p>回家就开始颓颓颓，生活作息极不规律。</p>
<p>已经预感到事情不对了，等成绩一发：</p>
<p>60 + 84 + 0 + 25 = 169。</p>
<p>T1 卡成狗，不过这成绩也符合我的真实水平。</p>
<p>不过省排名 rk18 -&gt; rk28，感觉 7 级没希望了，不知道有没有省一。</p>
<p>菜是原罪，最后还是把命运交给了出题人。</p>
<p>回去补了一周文化课，月考前临时抱佛脚。</p>
<p>再后来发现 T1 可以用 <code>long double</code> 诶。</p>
<h2 id="总结">总结</h2>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>总结 四边形不等式优化DP</title>
    <url>/2020/11/21/%E6%80%BB%E7%BB%93-%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%BC%98%E5%8C%96DP/</url>
    <content><![CDATA[<p>四边形不等式优化是对特定形式的状态转移方程进行优化的一种方法。</p>
<a id="more"></a>
<p>开坑！</p>
<hr />
<p>对于 2D1D 的 DP（比如石子合并一类的区间 DP）： <span class="math display">\[
f_{i,j}=\min_{i\le k&lt;j}\{f_{i,k}+f_{k+1,j}\}+cost(i,j)
\]</span> 可以通过四边形不等式从 <span class="math inline">\(\mathcal O(n^3)\)</span> 优化到 <span class="math inline">\(\mathcal O(n^2)\)</span>。</p>
<h2 id="step-1证明-cost-为凸">step 1：证明 cost 为凸</h2>
<p>对于 <span class="math inline">\(i&lt;i+1\le j&lt;j+1\)</span>： <span class="math display">\[
w(i,j)+w(i+1,j+1)\le w(i+1,j)+w(i,j+1)
\]</span></p>
<h2 id="step-2证明-dp-为凸">step 2：证明 DP 为凸</h2>
<p>同理，对于 <span class="math inline">\(i&lt;i+1\le j&lt;j+1\)</span>： <span class="math display">\[
f(i,j)+f(i+1,j+1)\le f(i+1,j)+f(i,j+1)
\]</span></p>
<h2 id="step-3证明决策单调性">step 3：证明决策单调性</h2>
<p>设 <span class="math inline">\(g(i,j)\)</span> 为 <span class="math inline">\(f(i,j)\)</span> 的最优决策点： <span class="math display">\[
g(i,j-1)\le g(i,j) \le g(i+1,j)
\]</span></p>
<h2 id="应用">应用</h2>
<p><del>猜单调性后打表证明。</del></p>
<p><del>发现不行就改改式子往上套。</del></p>
<p>咕~</p>
]]></content>
      <categories>
        <category>总结</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>单调性优化</tag>
      </tags>
  </entry>
  <entry>
    <title>常用组合数</title>
    <url>/2020/10/24/%E6%80%BB%E7%BB%93-%E5%B8%B8%E7%94%A8%E7%BB%84%E5%90%88%E6%95%B0/</url>
    <content><![CDATA[<p>包括组合数、卡特兰数、第一二类斯特林数等。</p>
<a id="more"></a>
<h2 id="组合数">组合数</h2>
<p><span class="math display">\[
\begin{align}
\binom{n}{m}&amp;=\frac{n!}{(n-m)!m!}\\
\binom{n}{m}&amp;=\binom{n-1}{m}+\binom{n-1}{m-1}
\end{align}
\]</span></p>
<h3 id="插板法">插板法</h3>
<blockquote>
<p>将 <span class="math inline">\(n\)</span> 个相同物品分为 <span class="math inline">\(k\)</span> 组（非空）的方案数。</p>
</blockquote>
<p>对于 <span class="math inline">\(n\)</span> 个点，相邻两个有一个槽，插入 <span class="math inline">\(k-1\)</span> 个板，也就分成了 <span class="math inline">\(k\)</span> 组。</p>
<p>所以答案为 <span class="math inline">\(\displaystyle \binom{n-1}{k-1}\)</span>。</p>
<h3 id="多重集的组合数">多重集的组合数</h3>
<blockquote>
<p>从 <span class="math inline">\(n\)</span> 个数中选出 <span class="math inline">\(k\)</span> 个数组成多重集的方案数。</p>
</blockquote>
<p>等价于解 <span class="math inline">\(x_1+x_2+x_3+\cdots +x_n=k\)</span> 的非负整数解个数。</p>
<p>答案： <span class="math display">\[
\binom{n+k-1}{k-1}
\]</span> 插板法：在原来的 <span class="math inline">\(n-1\)</span> 个槽基础上再加 <span class="math inline">\(k\)</span> 个槽，被选则表示该组为空。</p>
<h2 id="卡特兰数">卡特兰数</h2>
<p><a href="https://oi-wiki.org/math/catalan/">详见OI Wiki</a></p>
<table>
<thead>
<tr class="header">
<th><span class="math inline">\(H_0\)</span></th>
<th><span class="math inline">\(H_1\)</span></th>
<th><span class="math inline">\(H_2\)</span></th>
<th><span class="math inline">\(H_3\)</span></th>
<th><span class="math inline">\(H_4\)</span></th>
<th><span class="math inline">\(H_5\)</span></th>
<th><span class="math inline">\(H_6\)</span></th>
<th>...</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>1</td>
<td>2</td>
<td>5</td>
<td>14</td>
<td>42</td>
<td>132</td>
<td>...</td>
</tr>
</tbody>
</table>
<h3 id="常用公式">常用公式：</h3>
<p><span class="math display">\[
\begin{align}
H_n&amp;=\frac{1}{n+1}\dbinom{2n}{n}
\\
H_n&amp;=\dbinom{2n}{n}-\dbinom{2n}{n-1}
\\
H_n&amp;=\begin{cases}
\sum_{i=1}^{n}H_{i-1}H_{n-i} &amp;n\ge2,n\in\mathbb{N_{+}}\\
1 &amp;n=0,1
\end{cases}
\\
H_n&amp;=\frac{4n-2}{n+1}H_{n-1}\\
\end{align}
\]</span></p>
<h3 id="应用">应用</h3>
<p><span class="math inline">\(H_n\)</span>：</p>
<ol type="1">
<li><p>表示由 <span class="math inline">\(n\)</span> 个节点组成不同构二叉树的方案数。</p></li>
<li><p>表示有 <span class="math inline">\(2n+1\)</span> 个节点组成不同构满二叉树的方案数。</p></li>
<li><p>表示通过连接顶点将 <span class="math inline">\((n+2)\)</span> 边的凸多边形分成三角形的方法个数。</p></li>
<li><p>表示在 <span class="math inline">\(n\times n\)</span> 的网格图中不越过对角线的路径条数。</p></li>
<li><p>表示长度为 <span class="math inline">\(2n\)</span> 的 <span class="math inline">\(\texttt{dyck word}\)</span> 个数(有 <span class="math inline">\(n\)</span> 个"X"与 <span class="math inline">\(n\)</span> 个"Y"组成的字符串，满足前缀“X”的个数大于等于前缀“Y”的个数)。</p></li>
</ol>
<h2 id="第一类斯特林数">第一类斯特林数</h2>
<p>表示将 <span class="math inline">\(n\)</span> 个两两不同的元素，划分为 <span class="math inline">\(k\)</span> 个非空圆排列的方案数。 <span class="math display">\[
\begin{bmatrix}n\\k\end{bmatrix}=\begin{bmatrix}n-1\\k-1\end{bmatrix}+(n-1)\begin{bmatrix}n-1\\k\end{bmatrix}
\]</span> 边界 <span class="math inline">\(\displaystyle \begin{bmatrix}n\\0\end{bmatrix}=[n=0]\)</span>。</p>
<h2 id="第二类斯特林数">第二类斯特林数</h2>
<p>表示将 <span class="math inline">\(n\)</span> 个两两不同的元素，划分为 <span class="math inline">\(k\)</span> 个非空子集的方案数。 <span class="math display">\[
\begin{Bmatrix}n\\k\end{Bmatrix}=\begin{Bmatrix}n-1\\k-1\end{Bmatrix}+k\begin{Bmatrix}n-1\\k\end{Bmatrix}
\]</span> 边界 <span class="math inline">\(\displaystyle \begin{Bmatrix}n\\0\end{Bmatrix}=[n=0]\)</span>。</p>
]]></content>
      <categories>
        <category>总结</category>
        <category>Math</category>
      </categories>
      <tags>
        <tag>组合数</tag>
      </tags>
  </entry>
  <entry>
    <title>总结 树链剖分</title>
    <url>/2019/12/25/%E6%80%BB%E7%BB%93-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/</url>
    <content><![CDATA[<p>咕了很久，敲完才体会到什么是“出题人<del>毫无意义地</del>强行把代码增加5KB”</p>
<hr />
<p>首先，树剖是把一棵树划分成多条轻重链，然后用线段树维护这些链</p>
<a id="more"></a>
<p><a href="https://www.luogu.org/problem/P3384">模板题</a></p>
<p>通过基础的树剖，可以做以下操作：</p>
<ul>
<li>将树从x到y最短路径上的权值都加上z</li>
<li>求树从x到y最短路径上的权值和</li>
<li>将以x为根节点的子树内权值都加上z</li>
<li>求将以x为根节点的子树内的权值和</li>
</ul>
<h2 id="具体做法">具体做法:</h2>
<h3 id="dfs1">dfs1</h3>
<p>遍历一遍树，求出每个点的：</p>
<p><span class="math inline">\(fa[x]\)</span>：父亲</p>
<p><span class="math inline">\(deep[x]\)</span>：深度</p>
<p><span class="math inline">\(sz[x]\)</span>：子树大小</p>
<p><span class="math inline">\(son[x]\)</span>：重儿子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">    fa[x] = last;</span><br><span class="line">    deep[x] = deep[last] + <span class="number">1</span>;</span><br><span class="line">    sz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> y, maxson = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != last) &#123;</span><br><span class="line">            y = e[i].to;</span><br><span class="line">            dfs1(y, x);</span><br><span class="line">            sz[x] += sz[y];</span><br><span class="line">            <span class="keyword">if</span> (sz[y] &gt; maxson)</span><br><span class="line">                maxson = sz[y], son[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dfs2">dfs2</h3>
<p>第二遍遍历要划分轻重链，先求出：</p>
<p><span class="math inline">\(id[x]\)</span>：x的<span class="math inline">\(dfs\)</span>序</p>
<p><span class="math inline">\(top[x]\)</span>：x所在链的起始点</p>
<p>注意先走重儿子，再遍历轻儿子，使得重链每个点的<span class="math inline">\(dfs\)</span>序一定是连续的</p>
<p>根据<span class="math inline">\(dfs\)</span>序的性质，x的子树每个点的<span class="math inline">\(dfs\)</span>序也是连续的</p>
<p>因此可以用线段树维护得到的<span class="math inline">\(dfs\)</span>序（记得把权值转移到<span class="math inline">\(dfs\)</span>序上）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> top_)</span> </span>&#123;</span><br><span class="line">    id[x] = ++cnt;</span><br><span class="line">    top[x] = top_;</span><br><span class="line">    segtree.val[id[x]] = val[x];<span class="comment">// 转移权值</span></span><br><span class="line">    <span class="keyword">if</span> (!son[x])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    dfs2(son[x], top_);<span class="comment">// 先重儿子</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != fa[x] &amp;&amp; e[i].to != son[x])</span><br><span class="line">            dfs2(e[i].to, e[i].to);<span class="comment">// 轻儿子新开一条链</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线段树">线段树</h3>
<p>直接在<span class="math inline">\(dfs\)</span>序上建立线段树，套模板即可</p>
<p>这里就不贴code了</p>
<blockquote>
<p>update on 2020.1.21</p>
<p>听学长讲，对于每个链单独开一棵线段树可以减小常数</p>
</blockquote>
<hr />
<p>下面是<del>愉快的</del>各种操作。。。</p>
<h3 id="路径修改查询">路径修改/查询</h3>
<p>对于每个x和y</p>
<p>我们可以不停的让<strong>深度大的</strong>跳到所在链的顶部，在线段树上直接操作一个链</p>
<p>直到x和y在同一个链上，然后还是线段树操作</p>
<p>（注意，让深度小的往上跳，可能会错过最短路径）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change_road</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deep[x] &lt; deep[y])</span><br><span class="line">        swap(x, y);<span class="comment">// 选深度大的</span></span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y]) &#123;<span class="comment">// 不在同一条链时</span></span><br><span class="line">        <span class="keyword">if</span> (deep[top[x]] &lt; deep[top[y]])</span><br><span class="line">            swap(x, y);<span class="comment">//注意深度</span></span><br><span class="line">        segtree.change(<span class="number">1</span>, <span class="number">1</span>, n, id[top[x]], id[x], k);<span class="comment">// 注意顺序，链顶的id一定大于x的id</span></span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (deep[x] &gt; deep[y])</span><br><span class="line">        swap(x, y);<span class="comment">// 注意顺序</span></span><br><span class="line">    segtree.change(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[y], k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>路径查询同理，就不贴了</p>
<blockquote>
<p>话说这里太容易出bug了 QAQ</p>
</blockquote>
<h3 id="子树修改查询">子树修改/查询</h3>
<p>因为以x为根的子树在<span class="math inline">\(dfs\)</span>序上一定是连续的一段</p>
<p>线段树直接操作<span class="math inline">\(id[x]\)</span>到<span class="math inline">\(id[x]+sz[x]-1\)</span>的区间</p>
<p><code>segtree.change(1, 1, n, id[x], id[x]+sz[x]-1, z);</code></p>
<p>查询同理</p>
<hr />
<h3 id="luogup3384-ac代码">LuoguP3384 AC代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BANANA &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; T k = <span class="number">1</span>; <span class="keyword">char</span> in = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(in)) &#123; <span class="keyword">if</span> (in == <span class="string">&#x27;-&#x27;</span>) k = <span class="number">-1</span>; in = getchar(); &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(in)) x = x * <span class="number">10</span> + in - <span class="string">&#x27;0&#x27;</span>, in = getchar();</span><br><span class="line">    x *= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> nxt, to;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segtree</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Leave</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> ls, rs, sum, lazy;</span><br><span class="line">    &#125;;</span><br><span class="line">    Leave tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> mod, cnt;</span><br><span class="line">    <span class="keyword">int</span> val[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> suc)</span> </span>&#123;</span><br><span class="line">        tr[suc].sum = (tr[tr[suc].ls].sum + tr[tr[suc].rs].sum) % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ls = tr[suc].ls, rs = tr[suc].rs, mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        (tr[ls].lazy += tr[suc].lazy) %= mod;</span><br><span class="line">        (tr[ls].sum += (mid - L + <span class="number">1</span>) * tr[suc].lazy) %= mod;</span><br><span class="line">        (tr[rs].lazy += tr[suc].lazy) %= mod;</span><br><span class="line">        (tr[rs].sum += (R - mid) * tr[suc].lazy) %= mod;</span><br><span class="line">        tr[suc].lazy = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        tr[suc].lazy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">            tr[suc].sum = val[L];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        tr[suc].ls = ++cnt, tr[suc].rs = ++cnt;</span><br><span class="line">        build(tr[suc].ls, L, mid), build(tr[suc].rs, mid+<span class="number">1</span>, R);</span><br><span class="line">        push_up(suc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> cl, <span class="keyword">int</span> cr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cl &lt;= L &amp;&amp; R &lt;= cr) &#123;</span><br><span class="line">            (tr[suc].sum += (R - L + <span class="number">1</span>) * k) %= mod;</span><br><span class="line">            (tr[suc].lazy += k) %= mod;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        push_down(suc, L, R);</span><br><span class="line">        <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (cl &lt;= mid)</span><br><span class="line">            change(tr[suc].ls, L, mid, cl, cr, k);</span><br><span class="line">        <span class="keyword">if</span> (cr &gt; mid)</span><br><span class="line">            change(tr[suc].rs, mid+<span class="number">1</span>, R, cl, cr, k);</span><br><span class="line">        push_up(suc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= L &amp;&amp; R &lt;= qr)</span><br><span class="line">            <span class="keyword">return</span> tr[suc].sum;</span><br><span class="line">        push_down(suc, L, R);</span><br><span class="line">        <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (qr &lt;= mid)</span><br><span class="line">            <span class="keyword">return</span> query(tr[suc].ls, L, mid, ql, qr);</span><br><span class="line">        <span class="keyword">if</span> (ql &gt; mid)</span><br><span class="line">            <span class="keyword">return</span> query(tr[suc].rs, mid+<span class="number">1</span>, R, ql, qr);</span><br><span class="line">        <span class="keyword">return</span> (query(tr[suc].ls, L, mid, ql, qr) + query(tr[suc].rs, mid+<span class="number">1</span>, R, ql, qr)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, Q, root, mod, cnt;</span><br><span class="line"><span class="keyword">int</span> head[N], val[N], deep[N], sz[N], fa[N], son[N], top[N], id[N];</span><br><span class="line">Edge e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line">Segtree segtree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[++cnt] = (Edge)&#123;head[u], v&#125;, head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = a;</span><br><span class="line">    a = b, b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">    fa[x] = last;</span><br><span class="line">    deep[x] = deep[last] + <span class="number">1</span>;</span><br><span class="line">    sz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> y, maxson = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != last) &#123;</span><br><span class="line">            y = e[i].to;</span><br><span class="line">            dfs1(y, x);</span><br><span class="line">            sz[x] += sz[y];</span><br><span class="line">            <span class="keyword">if</span> (sz[y] &gt; maxson)</span><br><span class="line">                maxson = sz[y], son[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> top_)</span> </span>&#123;</span><br><span class="line">    id[x] = ++cnt;</span><br><span class="line">    top[x] = top_;</span><br><span class="line">    segtree.val[id[x]] = val[x];</span><br><span class="line">    <span class="keyword">if</span> (!son[x])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    dfs2(son[x], top_);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != fa[x] &amp;&amp; e[i].to != son[x])</span><br><span class="line">            dfs2(e[i].to, e[i].to);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change_road</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deep[x] &lt; deep[y])</span><br><span class="line">        swap(x, y);</span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deep[top[x]] &lt; deep[top[y]])</span><br><span class="line">            swap(x, y);</span><br><span class="line">        segtree.change(<span class="number">1</span>, <span class="number">1</span>, n, id[top[x]], id[x], k);</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (deep[x] &gt; deep[y])</span><br><span class="line">        swap(x, y);</span><br><span class="line">    segtree.change(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[y], k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query_road</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deep[x] &lt; deep[y])</span><br><span class="line">        swap(x, y);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deep[top[x]] &lt; deep[top[y]])</span><br><span class="line">            swap(x, y);</span><br><span class="line">        (res += segtree.query(<span class="number">1</span>, <span class="number">1</span>, n, id[top[x]], id[x])) %= mod;</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (deep[x] &gt; deep[y])</span><br><span class="line">        swap(x, y);</span><br><span class="line">    (res += segtree.query(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[y])) %= mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(Q), read(root), read(mod);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        read(val[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++i)</span><br><span class="line">        read(u), read(v), add(u, v), add(v, u);</span><br><span class="line">    dfs1(root, <span class="number">0</span>);</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    dfs2(root, root);</span><br><span class="line">    segtree.mod = mod, segtree.cnt = <span class="number">1</span>;</span><br><span class="line">    segtree.build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> opt, x, y, z;</span><br><span class="line">    <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">        read(opt);</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                read(x), read(y), read(z);</span><br><span class="line">                change_road(x, y, z);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                read(x), read(y);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, query_road(x, y));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                read(x), read(y);</span><br><span class="line">                segtree.change(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[x]+sz[x]<span class="number">-1</span>, y);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                read(x);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, segtree.query(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[x]+sz[x]<span class="number">-1</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BANANA::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次写的时候太艰辛了，调了半天发现是<span class="math inline">\(swap()\)</span>写错了<span class="math inline">\(qwq\)</span></p>
]]></content>
      <categories>
        <category>总结</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>总结 点分树（动态点分治）</title>
    <url>/2020/12/23/%E6%80%BB%E7%BB%93-%E7%82%B9%E5%88%86%E6%A0%91%EF%BC%88%E5%8A%A8%E6%80%81%E7%82%B9%E5%88%86%E6%B2%BB%EF%BC%89/</url>
    <content><![CDATA[<p>点分治是不支持修改的，所以根据点分治的过程，建出一个新的树形结构，具有许多很好的性质。</p>
<a id="more"></a>
<p>非常棒的讲解：<a href="https://www.luogu.com.cn/blog/ChenXingLing/post-xue-xi-bi-ji-shu-lun-dian-fen-shu-dong-tai-dian-fen-zhi-post">辰星凌 的博客</a>。</p>
<h2 id="基本思想">基本思想</h2>
<p>回忆点分治，每次找重心，划分成若干个连通块递归处理。</p>
<p>如果将每个点为重心时，以上一层的重心为父亲，就能提出一个新树。</p>
<p>根据点分治的复杂度，这棵树<strong>树高明显是 <span class="math inline">\(\log n\)</span> 的</strong>。</p>
<p>并且可以证明，<strong>这棵树所有子树的节点数之和约为 <span class="math inline">\(n\log n\)</span></strong>（每个点最多有 <span class="math inline">\(\log n\)</span> 个祖先）。</p>
<p>其实就是把点分治抽象的过程具体化了，树上的<strong>每个点也就代表以它为根的子树形成的连通块</strong>，所以可以在该点用一些带修数据结构维护这个连通块的信息。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, root, all;</span><br><span class="line"><span class="keyword">int</span> size[N], fa[N], maxs[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_root</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    size[u] = <span class="number">1</span>, maxs[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = G.head[u]; i; i = G.nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = G.to[i];</span><br><span class="line">        <span class="keyword">if</span> (vis[v] || v == pre) <span class="keyword">continue</span>;</span><br><span class="line">        get_root(v, u);</span><br><span class="line">        size[u] += size[v];</span><br><span class="line">        maxs[u] = max(maxs[u], size[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    maxs[u] = max(maxs[u], all - size[u]);</span><br><span class="line">    <span class="keyword">if</span> (!root || maxs[u] &lt; maxs[root]) root = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fat)</span> </span>&#123;</span><br><span class="line">    fa[u] = fat;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> now = all;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = G.head[u]; i; i = G.nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = G.to[i];</span><br><span class="line">        <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        all = size[v] &gt; size[u] ? (now - size[u]) : size[v];</span><br><span class="line">        root = <span class="number">0</span>;</span><br><span class="line">        get_root(v, u);</span><br><span class="line">        build(root, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line">all = n, root = <span class="number">0</span>, get_root(<span class="number">1</span>, <span class="number">0</span>), build(root, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h2 id="例题">例题</h2>
<p><a href="https://www.luogu.com.cn/problem/P6329">P6329 【模板】点分树 | 震波</a></p>
<blockquote>
<p>每次单点修改、询问距离点 <span class="math inline">\(x\)</span> 距离 <span class="math inline">\(\le k\)</span> 的点权值和。</p>
<p><span class="math inline">\(n,m\le 10^5\)</span>。</p>
</blockquote>
<p>设 <span class="math inline">\(dis(u,v)\)</span> 表示在<strong>原树</strong>上 <span class="math inline">\(u,v\)</span> 两点的距离，<span class="math inline">\(fa_u\)</span> 表示<strong>点分树</strong>上 <span class="math inline">\(u\)</span> 的父亲。</p>
<p>类似点分治的<strong>容斥</strong>，点分树上每个点可以维护两棵树状数组：</p>
<p><span class="math inline">\(f_1(u,i)\)</span> 表示在点分树上以 <span class="math inline">\(u\)</span> 根的子树中 <span class="math inline">\(dis(u,v)\le i\)</span> 的点 <span class="math inline">\(v\)</span> 的权值和；</p>
<p><span class="math inline">\(f_2(u,i)\)</span> 表示在点分树上以 <span class="math inline">\(u\)</span> 根的子树中 <span class="math inline">\(dis(fa_u,v)\le i\)</span> 的点 <span class="math inline">\(v\)</span> 的权值和；</p>
<p>这样每次查询点 <span class="math inline">\(x\)</span> 时，在点分树上 <span class="math inline">\(u\)</span> 从 <span class="math inline">\(x\)</span> 往上跳，每层的贡献就是：</p>
<p><span class="math display">\[
f_1(fa_u,k-dis(fa_u,x))-f_2(u,k-dis(fa_u,x))
\]</span></p>
<p>修改同理。</p>
<p>但是每个点开一棵树状数组爆空间？根据重心的性质，大小为 <span class="math inline">\(s\)</span> 的连通块中每个点与重心的距离不超过 <span class="math inline">\(\frac{s}{2}\)</span>，<span class="math inline">\(f_1\)</span> 中 <span class="math inline">\(i\)</span> 的范围 <span class="math inline">\([0,\frac{s}{2}]\)</span>，<span class="math inline">\(f_2\)</span> 中 <span class="math inline">\(i\)</span> 的范围 <span class="math inline">\([1,s]\)</span>，可以每个点用 <code>vector</code>，空间复杂度 <span class="math inline">\(\mathcal O(n\log n)\)</span>。</p>
<p>求 <span class="math inline">\(dis\)</span> 可以用重链剖分在线 <span class="math inline">\(\mathcal O(\log n)\)</span> 求，所以总复杂度 <span class="math inline">\(\mathcal O(n\log^2 n)\)</span>。</p>
<p><a href="https://www.luogu.com.cn/paste/u5q4bmjg">code</a></p>
<h2 id="一些题目">一些题目</h2>
<p>点分树常用容斥的套路，在点分树上，</p>
<p>设 <span class="math inline">\(f_1(x)\)</span> 表示以 <span class="math inline">\(x\)</span> 为根的子树里的点对 <span class="math inline">\(x\)</span> 的贡献；</p>
<p>设 <span class="math inline">\(f_2(x)\)</span> 表示以 <span class="math inline">\(x\)</span> 为根的子树对 <span class="math inline">\(f_1(fa_x)\)</span> 的贡献。</p>
<p>下文可能会省略定义。</p>
<h3 id="p3241-hnoi2015开店">P3241 [HNOI2015]开店</h3>
<p><a href="https://www.luogu.com.cn/problem/P3241">题目</a></p>
<blockquote>
<p>每个点有点权 <span class="math inline">\(A_i\)</span>，每次给出 <span class="math inline">\(x,l,r\)</span>，询问 <span class="math inline">\(\sum_{l\le Ay\le r}dis(x,y)\)</span>。</p>
<p><span class="math inline">\(n\le 1.5\times 10^5\)</span>，<span class="math inline">\(Q\le 2\times 10^5\)</span>。</p>
</blockquote>
<p>答案差分一下，每次询问 <span class="math inline">\(\le k\)</span> 的答案。</p>
<p>设 <span class="math inline">\(s(u,i)\)</span> 表示点分树上以 <span class="math inline">\(u\)</span> 为根的子树中 <span class="math inline">\(A_v\le k\)</span> 的 <span class="math inline">\(v\)</span> 个数。</p>
<p>每一层的答案为 <span class="math inline">\(f_1(fa_u,k)-f_2(u,k)+dis(x,fa_u)\times(s(fa_u,k)-s(u,k))\)</span>。</p>
<p>怎么求 <span class="math inline">\(f_1(fa_u,k)\)</span>？发现 <span class="math inline">\(A_i\)</span> 值域 <span class="math inline">\(10^9\)</span>，但是没有修改，那就每个点维护一个 <code>vector</code>，按 <span class="math inline">\(A_i\)</span> 排序并前缀和，每次二分即可。</p>
<p>时间复杂度 <span class="math inline">\(\mathcal O((n+Q)\log^2n)\)</span>。</p>
<p><a href="https://www.luogu.com.cn/paste/9mdc5xz1">code</a></p>
<h3 id="p3345-zjoi2015幻想乡战略游戏">P3345 [ZJOI2015]幻想乡战略游戏</h3>
<p><a href="https://www.luogu.com.cn/problem/P3345">题目</a></p>
<blockquote>
<p>设 <span class="math inline">\(F(u)=\sum_v dis(u,v)\times val_v\)</span>，每次修改点权后查询 <span class="math inline">\(F\)</span> 值最小的点。</p>
<p><span class="math inline">\(n,Q\le 10^5\)</span>，每个点度数 <span class="math inline">\(\le 20\)</span>。</p>
</blockquote>
<p>设 <span class="math inline">\(S(x)\)</span> 表示以 <span class="math inline">\(x\)</span> 为根的子树点权和。</p>
<p>先设 <span class="math inline">\(x\)</span> 为树根，得到 <span class="math inline">\(F(x)\)</span>，若将根转移到 <span class="math inline">\(x\)</span> 的儿子 <span class="math inline">\(y\)</span>，则 <span class="math display">\[
\begin{aligned}
\Delta F_{x\rightarrow y}&amp;=F(y)-F(x)\\
&amp;=(S(x)-S(y))\times dis(x,y)-S(y)\times dis(x,y)\\
&amp;= (S(x)-2S(y))\times dis(x,y)
\end{aligned}
\]</span> 若让 <span class="math inline">\(\Delta F_{x\rightarrow y}&lt;0\)</span>，则 <span class="math inline">\(2S(y)&gt;S(x)\)</span>，<span class="math inline">\(x\)</span> 的儿子中满足的 <span class="math inline">\(y\)</span> 至多有一个。</p>
<p>暴力思路：在原树上，从根开始，不断跳到到更优的儿子，单次复杂度 <span class="math inline">\(\mathcal O(20\cdot depth)\)</span>，<span class="math inline">\(depth\)</span> 为树高。</p>
<p>不过 <a href="https://www.luogu.com.cn/blog/ChenXingLing/post-xue-xi-bi-ji-shu-lun-dian-fen-shu-dong-tai-dian-fen-zhi-post">辰星凌 的博客</a> 告诉我们，还需要证明若某一步 <span class="math inline">\(y\)</span> 不比 <span class="math inline">\(x\)</span> 优则 <span class="math inline">\(y\)</span> 的子树中也没有比 <span class="math inline">\(x\)</span> 优的节点。</p>
<blockquote>
<p>证明：若 <span class="math inline">\(y\)</span> 再转移到 <span class="math inline">\(y&#39;\)</span> <span class="math display">\[
\Delta F_{y\rightarrow y&#39;}=(S(x)-2S(y&#39;))\times dis(y,y&#39;)
\]</span> 若 <span class="math inline">\(\Delta F_{x\rightarrow y}&gt;0\)</span>，<span class="math inline">\(S(x)&gt; 2S(y)\)</span>，又因为 <span class="math inline">\(S(y)\ge S(y&#39;)\)</span>，所以 <span class="math inline">\(S(x)&gt; 2S(y&#39;)\)</span>，</p>
<p>即 <span class="math inline">\(\Delta F_{y\rightarrow y&#39;}&gt;0,\Delta F_{x\rightarrow y&#39;}&gt;0\)</span>。</p>
</blockquote>
<p>如何控制树高？放到点分树上。</p>
<p>从重心 <span class="math inline">\(x\)</span> 开始，在原树上找到更优的儿子 <span class="math inline">\(y\)</span>，但是要<strong>跳到以 <span class="math inline">\(y\)</span> 为根的子树的重心</strong>上，毕竟答案一定在这棵子树里。</p>
<p>如何计算某个点的 <span class="math inline">\(F\)</span> 值？</p>
<p>还是点分树上跳 <span class="math inline">\(fa\)</span>，每一层的答案是 <span class="math inline">\(f_1(fa_u)-f_2(u)+(s(fa_u)-s(u))\times dis(x,fa_u)\)</span>。</p>
<p>用 ST 表 <span class="math inline">\(\mathcal O(1)\)</span> 找 <span class="math inline">\(\operatorname{LCA}\)</span>，点分树树高为 <span class="math inline">\(\log n\)</span>，计算 <span class="math inline">\(F\)</span> 值 <span class="math inline">\(\mathcal O(\log n)\)</span>，加上 <span class="math inline">\(20\)</span> 的常数，所以单次询问复杂度 <span class="math inline">\(\mathcal O(20\cdot \log^2 n)\)</span>。</p>
<p>修改就正常的在点分树上修改。</p>
<p><a href="https://www.luogu.com.cn/paste/7lg5e1ma">code</a></p>
<h3 id="p3920-wc2014紫荆花之恋">P3920 [WC2014]紫荆花之恋</h3>
<p><a href="https://www.luogu.com.cn/problem/P3920">题目</a></p>
<blockquote>
<p>树上有点权 <span class="math inline">\(r_i\)</span> 和边权 <span class="math inline">\(c_i\)</span>，每次往一棵树里加一个叶子，每次操作之后查询满足 <span class="math inline">\(dis(i,j)\le r_i+r_j\)</span> 的 <span class="math inline">\((i,j)\)</span> 点对数量。</p>
<p><span class="math inline">\(n\le 10^5\)</span>，<span class="math inline">\(r_i\le 2\times 10^9\)</span>，<span class="math inline">\(c_i\le 10^4\)</span>。强制在线。</p>
</blockquote>
<p>由于点权数据范围限制，点分树上每个点信息只能用平衡树维护（我选择替罪羊树）。</p>
<p>设某个子树的根为 <span class="math inline">\(x\)</span>，很显然的得到 <span class="math inline">\(dis(x,j)-r_j\le r_i-dis(x,i)\)</span>，每个点就可以用两棵平衡树维护了。</p>
<p>发现加叶子非常难做，普通的点分树结构都是不变的，如果直接加入点分树会导致不平衡。</p>
<p>这时候类似替罪羊树的思想，把不平衡的子树拍扁重建。</p>
<p>具体的，插入叶子后，往上跳父亲，找到深度最小的点 <span class="math inline">\(x\)</span> 满足：<span class="math inline">\(x\)</span> 最大的儿子的 <span class="math inline">\(size\)</span> <span class="math inline">\(\ge\)</span> <span class="math inline">\(x\)</span> 的 <span class="math inline">\(size\)</span> <span class="math inline">\(\times\)</span> <span class="math inline">\(\alpha\)</span>。把这 <span class="math inline">\(x\)</span> 子树的点全部拿出来重构点分树。</p>
<p>细节很多：</p>
<ul>
<li><span class="math inline">\(\alpha=0.8\)</span> 才能在 UOJ 卡过（Luogu 评测机好快啊）；</li>
<li>重构点分树时要把原来每个点的平衡树删掉；</li>
<li>平衡树的总空间大概是 <span class="math inline">\(\mathcal O(n\log n)\)</span> 级别的，并且要写垃圾回收；</li>
<li>注意不要让 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(1\)</span> 连边；<del>只有我才会犯这种错。</del></li>
<li>为了维护点分树上父子关系，每个点会开一个 <code>vector</code> 来存儿子，但是重构时一定记得修改（重构的子树的根）。</li>
</ul>
<p>其实写的不是太丑的话，不需要特意卡常。</p>
<p>具体看代码。</p>
<p><a href="https://www.luogu.com.cn/paste/hjk0xfrb">code</a></p>
]]></content>
      <categories>
        <category>总结</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>点分树</tag>
      </tags>
  </entry>
  <entry>
    <title>总结 线段树/树状数组</title>
    <url>/2019/12/25/%E6%80%BB%E7%BB%93-%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>虽然是总结，但是真的讲不出点啥，贴个板子就溜</p>
<p>毕竟就我自己看</p>
<a id="more"></a>
<h2 id="树状数组">树状数组</h2>
<p>单点修改，区间查询</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += lowbit(i))</span><br><span class="line">        tr[i] += k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i -= lowbit(i))</span><br><span class="line">        ans += tr[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">update(x, k)</span><br><span class="line"><span class="comment">// 查询l到r区间和</span></span><br><span class="line">query(r) - query(l<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>单点修改，区间查询好像还能CDQ分治</p>
</blockquote>
<p>进阶操作：区间修改，单点查询</p>
<p>用树状数组维护差分序列</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 区间修改</span></span><br><span class="line">update(l, k)</span><br><span class="line">update(r+<span class="number">1</span>, -k)</span><br><span class="line"><span class="comment">// 单点查询</span></span><br><span class="line">query(x)</span><br></pre></td></tr></table></figure>
<p>很多时候需要配合二分，直接套上去是 <span class="math inline">\(\mathcal O(\log^2 n)\)</span> 的。</p>
<p>树状数组虽然是拍扁的线段树，但是仍然保留不少好的性质，其实可以在树状数组上二分的，单次 <span class="math inline">\(\mathcal O(\log n)\)</span>。</p>
<h2 id="线段树">线段树</h2>
<p>区间修改，区间查询</p>
<p>要开4倍空间</p>
<p>每个节点的l，r可以存下来，也可以现算（卡空间的话）</p>
<p>包装起来比较优美</p>
<p>最好动态开点（存<span class="math inline">\(lson\)</span>和<span class="math inline">\(rson\)</span>），当成二叉堆存也行（比较难调，还丑）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segtree</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Leave</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> ls, rs, sum, lazy;</span><br><span class="line">    &#125;;</span><br><span class="line">    Leave tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">int</span> val[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> suc)</span> </span>&#123;</span><br><span class="line">        tr[suc].sum = tr[tr[suc].ls].sum + tr[tr[suc].rs].sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ls = tr[suc].ls, rs = tr[suc].rs, mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        tr[ls].lazy += tr[suc].lazy;</span><br><span class="line">        tr[ls].sum += (mid - L + <span class="number">1</span>) * tr[suc].lazy;</span><br><span class="line">        tr[rs].lazy += tr[suc].lazy;</span><br><span class="line">        tr[rs].sum += (R - mid) * tr[suc].lazy;</span><br><span class="line">        tr[suc].lazy = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        tr[suc].lazy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">            tr[suc].sum = val[L];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        tr[suc].ls = ++cnt, tr[suc].rs = ++cnt;</span><br><span class="line">        build(tr[suc].ls, L, mid), build(tr[suc].rs, mid+<span class="number">1</span>, R);</span><br><span class="line">        push_up(suc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> cl, <span class="keyword">int</span> cr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cl &lt;= L &amp;&amp; R &lt;= cr) &#123;</span><br><span class="line">            tr[suc].sum += (R - L + <span class="number">1</span>) * k;</span><br><span class="line">            tr[suc].lazy += k;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        push_down(suc, L, R);</span><br><span class="line">        <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (cl &lt;= mid)</span><br><span class="line">            change(tr[suc].ls, L, mid, cl, cr, k);</span><br><span class="line">        <span class="keyword">if</span> (cr &gt; mid)</span><br><span class="line">            change(tr[suc].rs, mid+<span class="number">1</span>, R, cl, cr, k);</span><br><span class="line">        push_up(suc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= L &amp;&amp; R &lt;= qr)</span><br><span class="line">            <span class="keyword">return</span> tr[suc].sum;</span><br><span class="line">        push_down(suc, L, R);</span><br><span class="line">        <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (qr &lt;= mid)</span><br><span class="line">            <span class="keyword">return</span> query(tr[suc].ls, L, mid, ql, qr);</span><br><span class="line">        <span class="keyword">if</span> (ql &gt; mid)</span><br><span class="line">            <span class="keyword">return</span> query(tr[suc].rs, mid+<span class="number">1</span>, R, ql, qr);</span><br><span class="line">        <span class="keyword">return</span> query(tr[suc].ls, L, mid, ql, qr) + query(tr[suc].rs, mid+<span class="number">1</span>, R, ql, qr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>线段树基本上都套板子，会魔改的只有<span class="math inline">\(push\_up()\)</span>和<span class="math inline">\(query()\)</span>的合并操作</p>
<h3 id="势能线段树">势能线段树</h3>
<p>没有 lazy tag 的暴力修改。</p>
<h4 id="区间开根">区间开根</h4>
<p><a href="https://www.luogu.org/problem/SP2713">SP2713</a></p>
<p>每个数开方几次就会变成1，暴力修改即可。</p>
<p>打tag记录区间是否都为1。</p>
<h4 id="区间改成约数">区间改成约数</h4>
<p><a href="https://www.luogu.org/problem/CF920F">CF920F</a></p>
<p>同上。</p>
<h3 id="线段树维护序列操作">线段树维护序列操作</h3>
<blockquote>
<p>基本上都是多了维护前缀答案和后缀答案，从而利于合并。</p>
</blockquote>
<h4 id="区间最大子段和">区间最大子段和</h4>
<p><a href="https://www.luogu.org/problem/SP1043">SPOJ1043</a></p>
<p><a href="https://www.luogu.org/problem/SP1716">SPOJ1716</a></p>
<p>记录每个节点的最大子段和，最大前缀，最大后缀，区间和。</p>
<h4 id="区间涂色">区间涂色</h4>
<p><a href="https://www.luogu.org/problem/P2894">P2894</a></p>
<p>维护前缀空房数和后缀空房数，同上。</p>
<h2 id="线段树合并">线段树合并</h2>
<p>合并的是动态开点线段树。</p>
<p>若两棵树重合的点数为 <span class="math inline">\(m\)</span>，单次合并复杂度 <span class="math inline">\(\mathcal O(m\log n)\)</span>，所以适用于插入点数较少的情况。</p>
<p>注意线段树空间复杂度 <span class="math inline">\(\mathcal O(n\log n)\)</span>，<span class="math inline">\(n=10^5\)</span> 的话开到 <span class="math inline">\(5\times 10^6\)</span> 吧。</p>
<p>个人觉得还算好理解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">int</span> sum[NN], ans[NN], ls[NN], rs[NN], rt[N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> suc)</span> </span>&#123;</span><br><span class="line">        sum[suc] = max(sum[ls[suc]], sum[rs[suc]]);</span><br><span class="line">        <span class="keyword">if</span> (sum[ls[suc]] &gt;= sum[rs[suc]]) ans[suc] = ans[ls[suc]];</span><br><span class="line">        <span class="keyword">else</span> ans[suc] = ans[rs[suc]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;suc, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!suc) suc = ++cnt;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            sum[suc] += k;</span><br><span class="line">            ans[suc] = sum[suc] &gt; <span class="number">0</span> ? l : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) update(ls[suc], l, mid, x, k);</span><br><span class="line">        <span class="keyword">else</span> update(rs[suc], mid + <span class="number">1</span>, r, x, k);</span><br><span class="line">        push_up(suc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!u || !v) <span class="keyword">return</span> u + v;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            sum[u] += sum[v];</span><br><span class="line">            ans[u] = sum[u] &gt; <span class="number">0</span> ? l : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> u;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        ls[u] = merge(ls[u], ls[v], l, mid);</span><br><span class="line">        rs[u] = merge(rs[u], rs[v], mid + <span class="number">1</span>, r);</span><br><span class="line">        push_up(u);</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; T;</span><br></pre></td></tr></table></figure>
<h3 id="一些题目">一些题目</h3>
<ul>
<li><p><a href="https://www.luogu.org/problemnew/show/P4556">P4556 雨天的尾巴</a></p></li>
<li><p><a href="https://www.luogu.org/problemnew/show/P3224">P3224 永无乡</a></p></li>
</ul>
]]></content>
      <categories>
        <category>总结</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>总结 莫队</title>
    <url>/2020/12/17/%E6%80%BB%E7%BB%93-%E8%8E%AB%E9%98%9F/</url>
    <content><![CDATA[<p>基于分块优化的暴力。</p>
<p>离线算法，适用于能够快速加减单点的贡献的区间询问。</p>
<a id="more"></a>
<h2 id="普通莫队">普通莫队</h2>
<p>板子题：<a href="https://www.luogu.com.cn/problem/P1494">P1494 「国家集训队」小Z的袜子</a> 或者：<a href="https://www.luogu.com.cn/problem/P2709">P2709 小B的询问</a>。</p>
<blockquote>
<p>给出长为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(a\)</span>，每次询问区间内 <span class="math inline">\(\displaystyle \sum_{i=l}^r a_i^2\)</span>。</p>
</blockquote>
<p>从暴力开始优化：</p>
<p>一个区间询问可以移动左右端点来得到另一个区间询问的答案，从而避免重复计算两个区间重叠的部分，那就设两个指针 <span class="math inline">\(l,r\)</span>，在序列上移动。</p>
<p>但还是会被卡成 <span class="math inline">\(\mathcal O(n^2)\)</span>。</p>
<p>于是将询问 <span class="math inline">\([l,r]\)</span> 离线下来排序，怎么排？</p>
<p>将序列分块，<span class="math inline">\(l\)</span> 所在块相同就按右端点排，不同就按 <span class="math inline">\(l\)</span> 所在块排。</p>
<h3 id="复杂度">复杂度</h3>
<p>对于 <span class="math inline">\(l\)</span>，每个块内有 <span class="math inline">\(k_i\)</span> 个询问，块内最坏 <span class="math inline">\(\mathcal O(k_i\sqrt{n})\)</span>，总共 <span class="math inline">\(\mathcal O(\sum k_i\sqrt{n})=\mathcal O(n\sqrt{n})\)</span>。</p>
<p>对于 <span class="math inline">\(r\)</span>，每个块最坏移动 <span class="math inline">\(n\)</span> 次，总共 <span class="math inline">\(\mathcal O(n\sqrt{n})\)</span>。</p>
<p>不考虑计算答案复杂度，这样莫队的总体复杂度就是 <span class="math inline">\(\mathcal O(n\sqrt{n})\)</span>。</p>
<h3 id="奇偶性优化">奇偶性优化</h3>
<p>为了衔接相邻两个块的 <span class="math inline">\(r\)</span> 指针，<span class="math inline">\(l\)</span> 所在块为奇数就令 <span class="math inline">\(r\)</span> 升序，偶数则降序。</p>
<h2 id="树上莫队">树上莫队</h2>
<p><a href="https://www.luogu.com.cn/problem/SP10707">SP10707 COT2 - Count on a tree II</a></p>
<blockquote>
<p>给定 <span class="math inline">\(n\)</span> 个结点的树，每个结点有一种颜色，<span class="math inline">\(m\)</span> 次询问，每次询问 <span class="math inline">\(u,v\)</span> 之间的路径上的结点的不同颜色数。</p>
<p><span class="math inline">\(1\le n\le 4\times 10^4\)</span>，<span class="math inline">\(1\le m\le 10^5\)</span>。</p>
</blockquote>
<p>把树转化成括号序，就是序列问题了，设 <span class="math inline">\(st_u,ed_u\)</span> 表示欧拉序中 <span class="math inline">\(u\)</span> 的进栈、出栈顺序。</p>
<p><span class="math inline">\(st_u&lt;st_v\)</span> 时：</p>
<ul>
<li><span class="math inline">\(u\)</span> 为 <span class="math inline">\(v\)</span> 的祖先，查询 <span class="math inline">\([st_u,st_v]\)</span> 中所有出现 <span class="math inline">\(1\)</span> 次的点的答案；</li>
<li>否则，查询 <span class="math inline">\([ed_u,st_v]\)</span> 的所有出现 <span class="math inline">\(1\)</span> 次的点的答案，记得单独处理 <span class="math inline">\(\operatorname{LCA}\)</span>。</li>
</ul>
<p>通过重链剖分可以轻松得到 <span class="math inline">\(\operatorname{LCA}\)</span> 和括号序，然后就是普通莫队问题了。</p>
<p><a href="https://www.luogu.com.cn/paste/dqvgjhd2">code</a></p>
<h2 id="带修莫队">带修莫队</h2>
<p><a href="https://www.luogu.com.cn/problem/P1903">P1903 「国家集训队」数颜色 / 维护队列</a></p>
<p>相对于普通莫队多了修改操作。</p>
<p>同样是把左右操作离线，分开询问和修改，并都打上时间戳。</p>
<p>可以想到多设一个指针在 <span class="math inline">\(p\)</span> 在<strong>修改操作的序列</strong>上移动，对于莫队过程中相邻的两个询问的时间戳 <span class="math inline">\(t_x,t_y\)</span>，将 <span class="math inline">\(t_x,t_y\)</span> 之间在当前区间内的修改操作统计到答案里。</p>
<p>发现这样单次会被卡成 <span class="math inline">\(\mathcal O(n)\)</span>，怎么优化？</p>
<h3 id="调整排序方法">调整排序方法</h3>
<ul>
<li>第一关键字：<span class="math inline">\(l\)</span> 所在块；</li>
<li>第二关键字：<span class="math inline">\(r\)</span> 所在块；</li>
<li>第三关键字：时间戳。</li>
</ul>
<p>这样 <span class="math inline">\(l\)</span> 所在块相同并且 <span class="math inline">\(r\)</span> 所在块相同的若干个询问，会按照时间总小到大排序。</p>
<h3 id="调整块的大小">调整块的大小</h3>
<p>设修改操作序列长为 <span class="math inline">\(t\)</span>，将块的大小调整为 <span class="math inline">\(\sqrt[3]{nt}\)</span> 最优，此时总体复杂度 <span class="math inline">\(\mathcal O(\sqrt[3]{n^4t})\)</span>。</p>
<p>证明见 <a href="https://www.luogu.com.cn/blog/KYD/solution-p1903">Minclxc 的博客</a>。</p>
<p><del>懒得话</del>实测 <span class="math inline">\(n^{\frac{2}{3}}\)</span> 跑的更快，毕竟 <span class="math inline">\(n\)</span>，<span class="math inline">\(t\)</span> 同阶。</p>
<p><a href="https://www.luogu.com.cn/paste/n4rt5t4e">code</a></p>
<h2 id="回滚莫队">回滚莫队</h2>
<p><a href="https://www.luogu.com.cn/problem/AT1219">AT1219 歴史の研究</a></p>
<blockquote>
<p>给出长为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(a\)</span>，<span class="math inline">\(c(x)\)</span> 为 <span class="math inline">\([l,r]\)</span> 中 <span class="math inline">\(x\)</span> 出现的次数，每次询问区间内 <span class="math inline">\(\displaystyle \max_{i=l}^r \{a_i\times c(a_i)\}\)</span>。</p>
</blockquote>
<p>发现由于 <span class="math inline">\(\max\)</span> 的性质，莫队无法做到 <span class="math inline">\(\mathcal O(1)\)</span> 减去某个点的贡献。</p>
<p><strong>只能加点不能删点</strong>，这时候回滚莫队就出现了。</p>
<p>还是先套路地分块，像普通莫队一样排序（不加奇偶性优化）。</p>
<p>同一个块里的询问右端点单调递增，满足只加不减。</p>
<p>发现左端点在块里反复横跳，干脆每次都从块的右端向左扩展，这样总复杂度仍然控制在 <span class="math inline">\(\mathcal O(n\sqrt{n})\)</span>。</p>
<p>好了，现在有了完整的思路：</p>
<p>为了方便，将询问按左端点所在块分组，组内排序。</p>
<p>注意要将左右端点在同一块的询问单独处理。</p>
<p>对于每一个块内，设指针 <span class="math inline">\(l,r\)</span>，我们要<strong>保留块的右端点到上一次 <span class="math inline">\(r\)</span> 的答案为 <span class="math inline">\(last\)</span> </strong>；</p>
<p><span class="math inline">\(r\)</span> 从上一次的 <span class="math inline">\(r\)</span> 向右扩展，更新 <span class="math inline">\(last\)</span>；</p>
<p><span class="math inline">\(l\)</span> 从块的右端暴力向左扩展，更新答案后撤销掉贡献的所有 <span class="math inline">\(c(a_i)\)</span>。</p>
<p><a href="https://www.luogu.com.cn/paste/otye22w7">code</a></p>
<h2 id="二次离线莫队">二次离线莫队</h2>
<p><a href="https://www.luogu.com.cn/problem/P4887">P4887 【模板】莫队二次离线（第十四分块(前体)）</a></p>
<blockquote>
<p>给了你一个序列 <span class="math inline">\(a\)</span>，每次查询给一个区间 <span class="math inline">\([l,r]\)</span> 查询 <span class="math inline">\(l \leq i&lt; j \leq r\)</span> 且 <span class="math inline">\(a_i \oplus a_j\)</span> 的二进制表示下有 <span class="math inline">\(k\)</span> 个 <span class="math inline">\(1\)</span> 的二元组 <span class="math inline">\((i,j)\)</span> 的个数。</p>
<p><span class="math inline">\(1 \leq n , m \leq 100000 , 0 \leq a_i , k &lt; 16384\)</span>。</p>
</blockquote>
<p>莫队需要考虑怎么从 <span class="math inline">\([l,r]\)</span> 的答案 <span class="math inline">\(\mathcal O(1)\)</span> 得到 <span class="math inline">\([l-1,r],[l+1,r],[l,r-1],[l,r+1]\)</span> 的答案。</p>
<p>设 <span class="math inline">\(f(x,[l,r])\)</span> 表示 <span class="math inline">\(x\)</span> 对区间 <span class="math inline">\([l,r]\)</span> 的贡献，每次增减的答案就是这个东西，但是很难计算。</p>
<p>考虑<strong>差分</strong>，以从 <span class="math inline">\([l,r]\)</span> 扩展到 <span class="math inline">\([l,r+1]\)</span> 为例： <span class="math display">\[
f(r+1,[l,r]) = f(r+1,[1,r])-f(r+1,[1,l-1])
\]</span> 发现 <span class="math inline">\(f(r+1,[1,r])\)</span> 可以预处理出来，重点是后面的这项，莫队的过程中在线的求很难。</p>
<p>所以就把对 <span class="math inline">\(f(r+1,[1,l-1])\)</span> 的询问<strong>再次离线</strong>下来（这也就是叫做“二次离线”的原因），把 <span class="math inline">\(r+1\)</span> 挂在 <span class="math inline">\(l-1\)</span> 的 <code>vector</code> 上，莫队之后从前到后扫，就类似<strong>扫描线</strong>一样处理。</p>
<p>其它的三种情况类似。</p>
<p>具体的预处理方法，运用异或运算的性质：<span class="math inline">\(a \operatorname{xor} b=c \Leftrightarrow a \operatorname{xor} c=b\)</span>，所以处理 <span class="math inline">\(\binom{14}{k}\)</span> 个可能的结果，开个桶统计即可。</p>
<p>并且每次将 <span class="math inline">\([l,r]\)</span> 扩展到 <span class="math inline">\([l,r&#39;]\)</span> 时，中间需要挂在 <span class="math inline">\(l-1\)</span> 处的点是个区间，可以将空间复杂度由 <span class="math inline">\(\mathcal O(n\sqrt{n})\)</span> 降到 <span class="math inline">\(\mathcal O(n)\)</span>。</p>
<p>这题有个坑点：<span class="math inline">\(k=0\)</span> 时，在差分处理 <span class="math inline">\(f(x,[l,r]),x\le r\)</span> 时，<span class="math inline">\(x\)</span> 在桶中会多算一次，因为 <span class="math inline">\(x\operatorname{xor}x=0\)</span> 但不符合题目要求。</p>
<p><strong>总结</strong>一下，二次离线就是在莫队时，通过扫描线一类的方法，将需要更新的答案再次离线处理。</p>
<p><a href="https://www.luogu.com.cn/paste/gid2fndl">code</a></p>
<h2 id="一些题目">一些题目</h2>
<ul>
<li><p><a href="https://www.luogu.com.cn/problem/P4074">P4074 「WC2013」糖果公园</a></p>
<p>树上莫队 + 带修莫队。</p>
<p>二合一，没啥，就是不太好码。</p>
<p><a href="https://www.luogu.com.cn/paste/5dombdrq">code</a></p></li>
<li><p>咕~</p></li>
</ul>
]]></content>
      <categories>
        <category>总结</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 Pollard-Rho &amp; Miller-Rabin</title>
    <url>/2020/10/24/%E6%9D%BF%E5%AD%90-Pollard-Rho-Miller-Rabin/</url>
    <content><![CDATA[<p>对于大数字的玄学复杂度质因数分解方法 Pollard-Rho，以及快速的素数判定方法 Millar-Rabin。</p>
<a id="more"></a>
<p><a href="https://www.luogu.com.cn/problem/P4718">P4718 【模板】Pollard-Rho算法</a></p>
<h2 id="前置知识">前置知识</h2>
<h3 id="快速乘">快速乘</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">mul</span><span class="params">(LL a, LL b, LL p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a * b - (LL)((<span class="keyword">long</span> <span class="keyword">double</span>)a * b / p) * p + p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>快速幂</p>
<p><del>GCD</del></p>
<p>费马小定理</p>
<h2 id="miller-rabin">Miller-Rabin</h2>
<p>很好的讲解及代码：<a href="https://oi-wiki.org/math/prime/">OI Wiki</a>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Miller_Rabin</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> n == <span class="number">2</span>;</span><br><span class="line">    LL a = n - <span class="number">1</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!(a &amp; <span class="number">1</span>)) a &gt;&gt;= <span class="number">1</span>, b++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j; i &lt;= <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        LL u = rand() % (n - <span class="number">2</span>) + <span class="number">2</span>, v = power(u, a, n);</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="number">1</span> || v == n - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= b; ++j) &#123;</span><br><span class="line">            v = mul(v, v, n);</span><br><span class="line">            <span class="keyword">if</span> (v == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == b + <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pollard-rho">Pollard-Rho</h2>
<p>很好的讲解及代码：<a href="https://oi-wiki.org/math/pollard-rho/">OI Wiki</a>，<a href="https://www.luogu.com.cn/blog/_post/118765">LinearODE's blog</a>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Pollard_Rho</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">    LL s = <span class="number">0</span>, t = <span class="number">0</span>, val = <span class="number">1</span>, c = rand() % (n - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> goal = <span class="number">1</span>; ; goal &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        s = t, val = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> step = <span class="number">1</span>; step &lt;= goal; ++step) &#123;</span><br><span class="line">            t = next_rand(t, c, n);</span><br><span class="line">            val = mul(val, t - s, n);</span><br><span class="line">            <span class="keyword">if</span> (step % <span class="number">127</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                LL d = gcd(val, n);</span><br><span class="line">                <span class="keyword">if</span> (d &gt; <span class="number">1</span>) <span class="keyword">return</span> d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LL d = gcd(val, n);</span><br><span class="line">        <span class="keyword">if</span> (d &gt; <span class="number">1</span>) <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模板题代码">模板题代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> RenaMoe &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TT&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(TT &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">bool</span> f = <span class="literal">false</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) f |= ch == <span class="string">&#x27;-&#x27;</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = getchar();</span><br><span class="line">    x = f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> LD;</span><br><span class="line"></span><br><span class="line">LL T, n, maxans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">mul</span><span class="params">(LL a, LL b, LL p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a * b - (LL)((LD)a * b / p) * p + p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">power</span><span class="params">(LL a, LL b, LL p)</span> </span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = mul(res, a, p);</span><br><span class="line">        a = mul(a, a, p), b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">next_rand</span><span class="params">(LL x, LL c, LL p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (mul(x, x, p) + c) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Miller_Rabin</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> n == <span class="number">2</span>;</span><br><span class="line">    LL a = n - <span class="number">1</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!(a &amp; <span class="number">1</span>)) a &gt;&gt;= <span class="number">1</span>, b++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j; i &lt;= <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        LL u = rand() % (n - <span class="number">2</span>) + <span class="number">2</span>, v = power(u, a, n);</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="number">1</span> || v == n - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= b; ++j) &#123;</span><br><span class="line">            v = mul(v, v, n);</span><br><span class="line">            <span class="keyword">if</span> (v == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == b + <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Pollard_Rho</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">    LL s = <span class="number">0</span>, t = <span class="number">0</span>, val = <span class="number">1</span>, c = rand() % (n - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> goal = <span class="number">1</span>; ; goal &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        s = t, val = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> step = <span class="number">1</span>; step &lt;= goal; ++step) &#123;</span><br><span class="line">            t = next_rand(t, c, n);</span><br><span class="line">            val = mul(val, t - s, n);</span><br><span class="line">            <span class="keyword">if</span> (step % <span class="number">127</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                LL d = gcd(val, n);</span><br><span class="line">                <span class="keyword">if</span> (d &gt; <span class="number">1</span>) <span class="keyword">return</span> d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LL d = gcd(val, n);</span><br><span class="line">        <span class="keyword">if</span> (d &gt; <span class="number">1</span>) <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">fac</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= maxans || n &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (Miller_Rabin(n)) &#123;</span><br><span class="line">        maxans = max(maxans, n);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL p = n;</span><br><span class="line">    <span class="keyword">while</span> (p &gt;= n) p = Pollard_Rho(n);</span><br><span class="line">    <span class="keyword">while</span> (!(n % p)) n /= p;</span><br><span class="line">    fac(n), fac(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    read(T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        read(n);</span><br><span class="line">        maxans = <span class="number">0</span>;</span><br><span class="line">        fac(n);</span><br><span class="line">        <span class="keyword">if</span> (maxans == n) <span class="built_in">puts</span>(<span class="string">&quot;Prime&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, maxans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RenaMoe::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
        <category>Math</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 可持久化线段树 / 主席树</title>
    <url>/2020/01/17/%E6%9D%BF%E5%AD%90-%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91-%E4%B8%BB%E5%B8%AD%E6%A0%91/</url>
    <content><![CDATA[<p>将线段树或者权值线段树可持久化。</p>
<a id="more"></a>
<h2 id="主席树">主席树</h2>
<p>不太严谨的描述，将权值线段树可持久化。可以做区间第 K 大一类问题。</p>
<p><a href="https://www.luogu.com.cn/problem/P3834">luogu P3834</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Seg_Tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> cnt, n;</span><br><span class="line">    <span class="keyword">int</span> rt[N], sum[N&lt;&lt;<span class="number">5</span>], ls[N&lt;&lt;<span class="number">5</span>], rs[N&lt;&lt;<span class="number">5</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> suc)</span> </span>&#123;</span><br><span class="line">        sum[suc] = sum[ls[suc]] + sum[rs[suc]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        sum[suc] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        build(ls[suc] = ++cnt, l, mid), build(rs[suc] = ++cnt, mid+<span class="number">1</span>, r);</span><br><span class="line">        push_up(suc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> pre, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ls[suc] = ls[pre], rs[suc] = rs[pre], sum[suc] = sum[pre] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid)</span><br><span class="line">            update(ls[suc] = ++cnt, ls[pre], l, mid, x);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            update(rs[suc] = ++cnt, rs[pre], mid+<span class="number">1</span>, r, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">int</span> t = sum[ls[v]] - sum[ls[u]], mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= t)</span><br><span class="line">            <span class="keyword">return</span> query(ls[u], ls[v], l, mid, k);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> query(rs[u], rs[v], mid+<span class="number">1</span>, r, k - t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; tr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        read(a[i]), b[i] = a[i];</span><br><span class="line">    sort(b+<span class="number">1</span>, b+n+<span class="number">1</span>);</span><br><span class="line">    tr.n = unique(b+<span class="number">1</span>, b+n+<span class="number">1</span>) - b - <span class="number">1</span>;</span><br><span class="line">    tr.build(tr.rt[<span class="number">0</span>] = ++tr.cnt, <span class="number">1</span>, tr.n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = lower_bound(b+<span class="number">1</span>, b+tr.n+<span class="number">1</span>, a[i]) - b;</span><br><span class="line">        tr.update(tr.rt[i] = ++tr.cnt, tr.rt[i<span class="number">-1</span>], <span class="number">1</span>, tr.n, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l, r, k;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        read(l), read(r), read(k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b[tr.query(tr.rt[l<span class="number">-1</span>], tr.rt[r], <span class="number">1</span>, tr.n, k)]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可持久化线段树">可持久化线段树</h2>
<p><a href="https://www.luogu.com.cn/problem/P3919">P3919 【模板】可持久化线段树 1（可持久化数组）</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NN = <span class="number">2e7</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PersistableSegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">int</span> val[NN], ls[NN], rs[NN], rt[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;suc, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!suc) suc = ++cnt;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            val[suc] = a[l];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        build(ls[suc], l, mid), build(rs[suc], mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;suc, <span class="keyword">int</span> pre, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        suc = ++cnt;</span><br><span class="line">        ls[suc] = ls[pre], rs[suc] = rs[pre];</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            val[suc] = k;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) update(ls[suc], ls[pre], l, mid, x, k);</span><br><span class="line">        <span class="keyword">else</span> update(rs[suc], rs[pre], mid + <span class="number">1</span>, r, x, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> val[suc];</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) <span class="keyword">return</span> query(ls[suc], l, mid, x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query(rs[suc], mid + <span class="number">1</span>, r, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(a[i]);</span><br><span class="line">    T.build(T.rt[<span class="number">0</span>], <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">int</span> base, opt, x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        read(base), read(opt);</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">            read(x), read(y);</span><br><span class="line">            T.update(T.rt[i], T.rt[base], <span class="number">1</span>, n, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            read(x);</span><br><span class="line">            T.rt[i] = T.rt[base];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, T.query(T.rt[i], <span class="number">1</span>, n, x));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title>板子 广义SAM</title>
    <url>/2021/01/08/%E6%9D%BF%E5%AD%90-%E5%B9%BF%E4%B9%89SAM/</url>
    <content><![CDATA[<p>广义后缀自动机，即多串的 SAM。</p>
<a id="more"></a>
<p>推荐 <a href="https://www.cnblogs.com/Xing-Ling/p/12038349.html">辰星凌的博客</a>。</p>
<p>设 trie 树大小 <span class="math inline">\(|T|\)</span>，字符集大小 <span class="math inline">\(|A|\)</span>；</p>
<p>设 <span class="math inline">\(G(T)\)</span> 表示 <span class="math inline">\(T\)</span> 的所有叶子深度之和。</p>
<h2 id="在线做法">在线做法</h2>
<p>每次插入新串时，将 <span class="math inline">\(last\)</span> 重置，并加入特判。</p>
<p>复杂度 <span class="math inline">\(\mathcal O(|T||A|+G(T))\)</span>，常数比离线做法小。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SuffixAutomaton</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    <span class="keyword">int</span> ch[N][<span class="number">26</span>], link[N], len[N], pos[N];</span><br><span class="line">    SuffixAutomaton() : tot(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ch[last][c]) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = last, q = ch[p][c];</span><br><span class="line">            <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>) <span class="keyword">return</span> q;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> nq = ++tot;</span><br><span class="line">                len[nq] = len[p] + <span class="number">1</span>, link[nq] = link[q];</span><br><span class="line">                <span class="built_in">memcpy</span>(ch[nq], ch[q], <span class="keyword">sizeof</span> ch[q]);</span><br><span class="line">                link[q] = nq;</span><br><span class="line">                <span class="keyword">while</span> (p &amp;&amp; ch[p][c] == q) ch[p][c] = nq, p = link[p];</span><br><span class="line">                <span class="keyword">return</span> nq;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p = last, np = ++tot;</span><br><span class="line">        len[np] = len[p] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; !ch[p][c]) ch[p][c] = np, p = link[p];</span><br><span class="line">        <span class="keyword">if</span> (!p) link[np] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> q = ch[p][c];</span><br><span class="line">            <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>) link[np] = q;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> nq = ++tot;</span><br><span class="line">                len[nq] = len[p] + <span class="number">1</span>, link[nq] = link[q];</span><br><span class="line">                <span class="built_in">memcpy</span>(ch[nq], ch[q], <span class="keyword">sizeof</span> ch[q]);</span><br><span class="line">                link[q] = link[np] = nq;</span><br><span class="line">                <span class="keyword">while</span> (p &amp;&amp; ch[p][c] == q) ch[p][c] = nq, p = link[p];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> np;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; A;</span><br></pre></td></tr></table></figure>
<h2 id="离线做法">离线做法</h2>
<p>先将所有串插到 trie 里，再 bfs 构建。</p>
<p>复杂度 <span class="math inline">\(\mathcal O(|T||A|+|T|)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    <span class="keyword">int</span> ch[N][<span class="number">26</span>], fa[N], val[N];</span><br><span class="line">    Trie() : tot(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!ch[p][c]) &#123;</span><br><span class="line">                ch[p][c] = ++tot;</span><br><span class="line">                val[ch[p][c]] = c, fa[ch[p][c]] = p;</span><br><span class="line">            &#125;</span><br><span class="line">            p = ch[p][c];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; T;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SuffixAutomaton</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    <span class="keyword">int</span> ch[N][<span class="number">26</span>], link[N], len[N], pos[N];</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    SuffixAutomaton() : tot(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = last, np = ++tot;</span><br><span class="line">        len[np] = len[p] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; !ch[p][c]) ch[p][c] = np, p = link[p];</span><br><span class="line">        <span class="keyword">if</span> (!p) link[np] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> q = ch[p][c];</span><br><span class="line">            <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>) link[np] = q;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> nq = ++tot;</span><br><span class="line">                len[nq] = len[p] + <span class="number">1</span>, link[nq] = link[q];</span><br><span class="line">                <span class="built_in">memcpy</span>(ch[nq], ch[q], <span class="keyword">sizeof</span> ch[q]);</span><br><span class="line">                link[q] = link[np] = nq;</span><br><span class="line">                <span class="keyword">while</span> (p &amp;&amp; ch[p][c] == q) ch[p][c] = nq, p = link[p];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> np;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">            <span class="keyword">if</span> (T.ch[<span class="number">1</span>][i]) q.push(T.ch[<span class="number">1</span>][i]);</span><br><span class="line">        pos[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            pos[u] = insert(T.val[u], pos[T.fa[u]]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">                <span class="keyword">if</span> (T.ch[u][i]) q.push(T.ch[u][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; A;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title>笔记 min_25筛</title>
    <url>/2021/01/02/%E7%AC%94%E8%AE%B0-min-25%E7%AD%9B/</url>
    <content><![CDATA[<p>在 <span class="math inline">\(\mathcal O(n^{1-\epsilon})\)</span> 复杂度内计算积性函数前缀和的算法，处理大概 <span class="math inline">\(10^{10}\)</span> 级别的数据。</p>
<a id="more"></a>
<p><del>这东西从去年咕到了今年。</del></p>
<p>以下内容默认 <span class="math inline">\(p\in \text{prime}\)</span>。</p>
<p>min_25 筛要求积性函数 <span class="math inline">\(f(p^k)\)</span> 可表示成 <span class="math inline">\(p\)</span> 低阶多项式，例如 <a href="https://www.luogu.com.cn/problem/P5325">模板题 P5325</a> 中 <span class="math inline">\(f(p^k)=p^k(p^k-1)\)</span>。</p>
<h2 id="基本思路">基本思路</h2>
<p>min_25 筛基本思路是把答案拆成<strong>质数和非质数</strong>两部分来分别计算。</p>
<h3 id="第一部分">第一部分</h3>
<p>以 <a href="https://www.luogu.com.cn/problem/P5325">模板题 P5325</a> 为例，拆开 <span class="math inline">\(f(p^k)=p^{2k}-p^k\)</span>，分别计算。</p>
<p>第一部分要余出来的是 <span class="math inline">\(g(n,i),sp(x)\)</span>。</p>
<p>设 <span class="math inline">\(sp(x)\)</span> 为前 <span class="math inline">\(x\)</span> 个质数的函数值之和，可直接预处理。</p>
<p>设 <span class="math inline">\(g(n,i)=\sum_{j=2}^n[j\in \text{prime}\lor \operatorname{minp}(j)&gt;p_i]j^k\)</span>，其中 <span class="math inline">\(\operatorname{minp}(x)\)</span> 表示 <span class="math inline">\(x\)</span> 最小质因子。</p>
<p>可以发现 <span class="math inline">\(g(n,i)\)</span> 是完全积性函数，并且在质数处的取值和 <span class="math inline">\(f(x)\)</span> 一样。</p>
<p>然后递推 <span class="math inline">\(g(n,i)\)</span>： <span class="math display">\[
g(n,i)=g(n,i-1)-p_i^k\Big(g(\lfloor\frac{n}{p_i}\rfloor,i-1)-g(p_{i-1},i-1)\Big)
\]</span> 后面就是提出一个 <span class="math inline">\(p_i^k\)</span> 的质因子，因为是积性函数，所以不用提全。<span class="math inline">\(g(p_{i-1},i-1)\)</span> 其实就是前 <span class="math inline">\(i-1\)</span> 个质数的函数值之和。</p>
<p>这东西状态量多大呢？</p>
<p>从第一维看，根据定理 <span class="math inline">\(\displaystyle \Big\lfloor\frac{\lfloor\frac{n}{a}\rfloor}{b}\Big\rfloor=\lfloor\frac{n}{ab}\rfloor\)</span>，所以只要计算所有 <span class="math inline">\(\lfloor\frac{n}{x}\rfloor\)</span> 的取值，可以除法分块，是 <span class="math inline">\(\mathcal O(\sqrt{n})\)</span> 的；</p>
<p>从第二维看，由于非质数中大于 <span class="math inline">\(\sqrt n\)</span> 的质因数一定不是最小质因子，那么当 <span class="math inline">\(p_i&gt;\sqrt{n}\)</span> 时，<span class="math inline">\(g(n,i)=g(n,i-1)\)</span>，所以我们只需要 <span class="math inline">\(\ge \sqrt{n}\)</span> 的质数，大概 <span class="math inline">\(10^4\)</span> 规模。</p>
<p>这一部分复杂度 <span class="math inline">\(\displaystyle \mathcal O(\frac{n^{\frac{2}{3}}}{\log n})\)</span>，并不会证。</p>
<p>实现有个细节，就是第一维的下标是 <span class="math inline">\(10^{10}\)</span> 级别的存不下（这里用 <code>map/unordered_map</code> 就没什么优势了），但是可以根号分治：<span class="math inline">\(\lfloor\frac{n}{x}\rfloor\le \sqrt{n}\)</span> 的存一个数组，<span class="math inline">\(\lfloor\frac{n}{x}\rfloor&gt; \sqrt{n}\)</span> 的按 <span class="math inline">\(x\)</span> 存另一个数组。</p>
<h3 id="第二部分">第二部分</h3>
<p>该开始统计答案了，设 <span class="math inline">\(S(n,i)=\sum_{j=2}^n[\operatorname{minp}(j)&gt;p_i]f(j)\)</span>，最后要求的就是 <span class="math inline">\(S(n,0)\)</span>。</p>
<p>还是一样的思路，设 <span class="math inline">\(x\)</span> 为最后一个小于等于 <span class="math inline">\(\sqrt{n}\)</span> 的质数的下标。 <span class="math display">\[
S(n,i)=g(n,x)-sp(i)+\sum_{k&gt;i,p_k^c\le n}f(p_k^c)\Big(S(\lfloor\frac{n}{p_k^c}\rfloor,k)+[c\neq 1]\Big)
\]</span> 前面就是质数的贡献；后面是合数，因为不是完全积性了，所以得把质因子提全；另外 <span class="math inline">\([c\neq 1]\)</span> 是把质数的幂算上。</p>
<p>这里不用记忆化，据说复杂度是 <span class="math inline">\(\mathcal O(n^{1-\epsilon})\)</span>，常数很小。</p>
<h2 id="代码实现">代码实现</h2>
<p>P5325 code：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> LL P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> LL inv2 = <span class="number">500000004</span>;</span><br><span class="line"><span class="keyword">const</span> LL inv6 = <span class="number">166666668</span>;</span><br><span class="line"></span><br><span class="line">LL n, sqr, cntp, tot;</span><br><span class="line">LL pri[N], sp1[N], sp2[N], g1[N], g2[N], bas[N], id1[N], id2[N];</span><br><span class="line"><span class="keyword">bool</span> np[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init_min_25</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sqr = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (LL i = <span class="number">2</span>; i &lt;= sqr; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!np[i]) pri[++cntp] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cntp; ++j) &#123;</span><br><span class="line">            LL k = i * pri[j];</span><br><span class="line">            <span class="keyword">if</span> (k &gt; sqr) <span class="keyword">break</span>;</span><br><span class="line">            np[k] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cntp; ++i) &#123;</span><br><span class="line">        sp1[i] = (sp1[i - <span class="number">1</span>] + pri[i]) % P;</span><br><span class="line">        sp2[i] = (sp2[i - <span class="number">1</span>] + pri[i] * pri[i] % P) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (LL l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = n / (n / l);</span><br><span class="line">        bas[++tot] = n / l;</span><br><span class="line">        LL t = bas[tot] % P;</span><br><span class="line">        g1[tot] = (t * (t + <span class="number">1</span>) % P * inv2 % P + P - <span class="number">1</span>) % P;</span><br><span class="line">        g2[tot] = (t * (t + <span class="number">1</span>) % P * (<span class="number">2</span> * t + <span class="number">1</span>) % P * inv6 % P + P - <span class="number">1</span>) % P;</span><br><span class="line">        <span class="keyword">if</span> (bas[tot] &lt;= sqr) id1[bas[tot]] = tot;</span><br><span class="line">        <span class="keyword">else</span> id2[l] = tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cntp; ++j) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot &amp;&amp; pri[j] * pri[j] &lt;= bas[i]; ++i) &#123;</span><br><span class="line">            LL t = bas[i] / pri[j];</span><br><span class="line">            t = (t &lt;= sqr) ? id1[t] : id2[n / t];</span><br><span class="line">            g1[i] = (g1[i] - pri[j] * (g1[t] - sp1[j - <span class="number">1</span>] + P) % P + P) % P;</span><br><span class="line">            g2[i] = (g2[i] - pri[j] * pri[j] % P * (g2[t] - sp2[j - <span class="number">1</span>] + P) % P + P) % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">S</span><span class="params">(LL i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pri[j] &gt;= i) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> id = (i &lt;= sqr) ? id1[i] : id2[n / i];</span><br><span class="line">    LL res = (g2[id] - sp2[j] - (g1[id] - sp1[j]) + P + P) % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt;= cntp &amp;&amp; pri[k] * pri[k] &lt;= i; ++k) &#123;</span><br><span class="line">        LL now = pri[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; now &lt;= i; ++c, now *= pri[k]) &#123;</span><br><span class="line">            LL t = now % P;</span><br><span class="line">            res = (res + t * (t - <span class="number">1</span> + P) % P * (S(i / now, k) + (c != <span class="number">1</span>)) % P) % P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    init_min_25();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (S(n, <span class="number">0</span>) + <span class="number">1</span>) % P);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一些题目">一些题目</h2>
<p>咕。</p>
]]></content>
      <categories>
        <category>总结</category>
        <category>Math</category>
      </categories>
      <tags>
        <tag>min_25筛</tag>
      </tags>
  </entry>
  <entry>
    <title>笔记 一些树上问题</title>
    <url>/2021/01/24/%E7%AC%94%E8%AE%B0-%E4%B8%80%E4%BA%9B%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>单点、链、子树的查询及修改，很多时候可以相互转化；并且放到 dfs 序或者括号序上，从而避免重链剖分或者 LCT。</p>
<p><del>大量口胡警告⚠️</del></p>
<a id="more"></a>
<p>参照博客：</p>
<ul>
<li><a href="https://www.cnblogs.com/zjp-shadow/p/9355538.html">【zjp-shadow】一类树上问题的解决办法</a></li>
<li><a href="https://www.cnblogs.com/weeping/p/6847112.html">【weeping】dfs序七个经典问题</a></li>
</ul>
<h2 id="dfs-序-括号序-欧拉序">dfs 序 &amp; 括号序 &amp; 欧拉序</h2>
<h3 id="dfs-序">dfs 序</h3>
<p>按照 dfs 的入栈顺序转化成一个序列。</p>
<p><strong>性质：</strong></p>
<ul>
<li><p>树上一个子树在 dfs 序中是个连续的区间。</p>
<p>子树修改转化为序列问题。</p></li>
<li><p>树上一点与第一个访问的儿子在 dfs 序上是相邻的。</p>
<p>若优先 dfs 最大的儿子 / 最深的儿子，可用于重链剖分 / 长链剖分。</p></li>
<li><p>毕竟是 dfs 序，有时候可以模拟递归 dfs。</p></li>
</ul>
<h3 id="括号序">括号序</h3>
<p>入栈加入左括号和编号，出栈加入右括号，位置分别记为 <span class="math inline">\(st_u\)</span>，<span class="math inline">\(pos_u\)</span>，<span class="math inline">\(ed_u\)</span>。</p>
<p><strong>性质：</strong></p>
<ul>
<li><p>若 <span class="math inline">\(st_u&lt;st_v\)</span> 且 <span class="math inline">\(ed_u&gt;ed_v\)</span>，则 <span class="math inline">\(u\)</span> 是 <span class="math inline">\(v\)</span> 的祖先。</p></li>
<li><p>括号序上区间 <span class="math inline">\((pos_u,pos_v)\)</span> 中未匹配的括号的个数就是 <span class="math inline">\(u-v\)</span> 的树上距离 / 路径长度。</p></li>
<li><p><strong>若题目满足答案可减性</strong>，那么树上的一条链对应括号序上的一段连续区间，那么可以把路径问题放到括号序上：</p>
<ul>
<li><p>把 <span class="math inline">\(u\)</span> 的答案在 <span class="math inline">\(st_u\)</span> 处存 <span class="math inline">\(+1\)</span> 倍，<span class="math inline">\(ed_u\)</span> 处存 <span class="math inline">\(-1\)</span> 倍，那么 <span class="math inline">\([1,st_u]\)</span> 的和就是根到 <span class="math inline">\(u\)</span> 路径的答案之和。可以树上差分得到链答案。</p></li>
<li><p>另一种是用于树上莫队，括号序记录点的编号，我们只统计区间内出现次数为 <span class="math inline">\(1\)</span> 的点的答案，需要对 <span class="math inline">\(u,v\)</span> 的祖先关系分类讨论一下。</p>
<p>具体应用见 <a href="/2020/12/17/总结-莫队/">题解 SP10707 COT2 - Count on a tree II</a>。</p></li>
</ul></li>
</ul>
<h3 id="欧拉序">欧拉序</h3>
<p>入栈时加入 <span class="math inline">\(u\)</span>，出栈时加入 <span class="math inline">\(fa_u\)</span>。记 <span class="math inline">\(u\)</span> 在欧拉序中第一次出现位置 <span class="math inline">\(fir_u\)</span>。</p>
<p><strong>性质：</strong></p>
<ul>
<li><p>欧拉序 <span class="math inline">\([fir_u,fir_v]\)</span> 中深度最小的点为 <span class="math inline">\(\operatorname{LCA}(u,v)\)</span>。</p>
<p>通过 st 表可以 <span class="math inline">\(\mathcal O(n\log n)\)</span> 预处理、<span class="math inline">\(\mathcal O(1)\)</span> 求 <span class="math inline">\(\operatorname{LCA}\)</span>，看 <a href="/2020/01/17/2020-01-17-板子-LCA/">这里</a>。</p></li>
</ul>
<h2 id="树上差分">树上差分</h2>
<ul>
<li><p><strong>链上修改</strong>，设 <span class="math inline">\(lca\)</span> 为 <span class="math inline">\(，\operatorname{LCA}(u,v)\)</span>对于任意一条树上的链 <span class="math inline">\([u,v]\)</span>，都可以拆成两条“直上直下”的链，即 <span class="math inline">\([u,lca]\)</span> 和 <span class="math inline">\([v,lca)\)</span>。</p>
<p>然后就在 <span class="math inline">\(u,v\)</span> 处标记 <span class="math inline">\(+1\)</span>，在 <span class="math inline">\(lca,fa_{lca}\)</span> 处标记 <span class="math inline">\(-1\)</span>。</p>
<p>用什么东西维护根到某一点的链和，或者像多次修改一次询问的题（<a href="https://www.luogu.com.cn/problem/P3258">松鼠的新家</a>）最后处理。</p></li>
<li><p><strong>链上查询</strong>，拆成两条链后再差分，因为我们往往容易得到根到某节点的路径和。下文默认省略拆链和差分。</p></li>
</ul>
<h2 id="一些转化关系">一些转化关系</h2>
<p>以下均只适用于能够简单加和的答案。</p>
<p>子树查询就是用数据结构维护 dfs 序。</p>
<ul>
<li><p><strong>链上修改，单点查询</strong> <span class="math inline">\(\large\Rightarrow\)</span> <strong>单点修改，子树查询</strong></p>
<p>差分链，一个点 <span class="math inline">\(u\)</span> 为根的子树之和只会统计起点在子树里、终点是 <span class="math inline">\(u\)</span> 的祖先的所有链的答案，而终点也在子树内的会抵消掉。所以转化为单点修改，子树查询。</p>
<p><del>右边到左边也是可以的，就是将单点修改转化为将根到该点的路径都修改了，不过没用。</del></p></li>
<li><p><strong>单点修改，链上查询</strong> <span class="math inline">\(\large\Rightarrow\)</span> <strong>子树修改，单点查询</strong></p>
<p>修改询问倒过来也一样，画个图模拟就懂了。实现也是维护根到该点的路径和，然后链底减去链顶就是链的答案。</p></li>
<li><p><strong>链上修改，子树查询</strong> <span class="math inline">\(\large\Rightarrow\)</span> <strong>单点修改，子树查询</strong></p>
<p>链上修改对于子树的答案是多个，设 <span class="math inline">\(deep_u\)</span> 表示 <span class="math inline">\(u\)</span> 的深度，对于每个点维护修改值 <span class="math inline">\(val_u\)</span> 和 <span class="math inline">\(val_u\times deep_u\)</span>。这样子树查询就是 <span class="math inline">\(\sum val_v\times deep_v-deep_u\times\sum val_v\)</span>（<span class="math inline">\(v\)</span> 为 <span class="math inline">\(u\)</span> 子树里的点）。</p></li>
<li><p><strong>子树修改，链上查询</strong> <span class="math inline">\(\large\Rightarrow\)</span> <strong>子树修改，单点查询</strong></p>
<p>类似地，对 <span class="math inline">\(u\)</span> 的子树修改值为 <span class="math inline">\(val_u\)</span> 和 <span class="math inline">\(val_u\times deep_u\)</span>，单点 <span class="math inline">\(v\)</span> 的答案得到根到 <span class="math inline">\(v\)</span> 的路径和，即 <span class="math inline">\(-\sum val_u\times deep_u+deep_v\times \sum val_u\)</span>（这里 <span class="math inline">\(u\)</span> 为 <span class="math inline">\(v\)</span> 的祖先）。</p></li>
</ul>
<hr />
<p>感觉还有很多要总结的。。。</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
  </entry>
  <entry>
    <title>笔记 微积分基础</title>
    <url>/2020/12/25/%E7%AC%94%E8%AE%B0-%E5%BE%AE%E7%A7%AF%E5%88%86%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>东搬西抄。</p>
<a id="more"></a>
<ul>
<li><p>求导的线性性 <span class="math display">\[
\begin{aligned}
(F(x)+G(x))&#39;&amp;=F&#39;(x)+G&#39;(x)\\
(k\cdot F(x))&#39;&amp;=k\cdot F&#39;(x)
\end{aligned}
\]</span></p></li>
<li><p>单项式求导：<span class="math inline">\((ax^k)&#39;=akx^{k-1}\)</span></p></li>
<li><p><span class="math inline">\((\ln x)&#39;=\frac{1}{x}\)</span></p></li>
<li><p><span class="math inline">\((e^x)&#39;=e^x\)</span></p></li>
<li><p>乘法法则：<span class="math inline">\((F(x)G(x))&#39;=F&#39;(x)G(x)+F(x)G&#39;(x)\)</span></p></li>
<li><p>除法原则：<span class="math inline">\(\displaystyle (\frac{F(x)}{G(x)})&#39;=\frac{F&#39;(x)G(x)-F(x)G&#39;(x)}{G^2(x)}\)</span></p></li>
<li><p>链式法则：<span class="math inline">\(\displaystyle \frac{d}{dx}\frac{dx}{dz}=\frac{d}{dz}\)</span></p></li>
<li><p>复合函数求导：<span class="math inline">\(\frac{d}{dx}G(F(x))=\frac{d}{dF(x)}\frac{dF(x)}{x}G(F(x))=G&#39;(F(x))F&#39;(x)\)</span></p></li>
<li><p>洛必达法则：</p>
<p>若 <span class="math inline">\(\displaystyle \lim_{x\rightarrow a}F(x)=0\)</span> 且 <span class="math inline">\(\displaystyle \lim_{x\rightarrow a}G(x)=0\)</span>，则 <span class="math inline">\(\displaystyle \lim_{x\rightarrow a}\frac{F(x)}{G(x)}=\lim_{x\rightarrow a}\frac{F&#39;(x)}{G&#39;(x)}\)</span>（若极限存在）。</p></li>
<li><p>泰勒展开：</p>
<p>设 <span class="math inline">\(F^{(n)}(x)\)</span> 表示 <span class="math inline">\(F(x)\)</span> 的 <span class="math inline">\(n\)</span> 阶导，则 <span class="math display">\[
F(x)=\sum_{i=0}\frac{F^{(i)}(a)}{i!}(x-a)^i
\]</span></p></li>
<li><p>多项式牛顿迭代：</p>
<p>若 <span class="math display">\[
\begin{aligned}
G(F(x))&amp;\equiv 0\pmod{x^n}\\
G(F_*(x))&amp;\equiv 0\pmod{x^{\frac{n}{2}}}
\end{aligned}
\]</span> 则 <span class="math display">\[
F(x)\equiv F_*(x)-\frac{G(F_*(x))}{G&#39;(F_*(x))}\pmod{x^n}
\]</span></p></li>
</ul>
]]></content>
      <categories>
        <category>总结</category>
        <category>Math</category>
      </categories>
  </entry>
  <entry>
    <title>笔记 杜教筛</title>
    <url>/2020/12/27/%E7%AC%94%E8%AE%B0-%E6%9D%9C%E6%95%99%E7%AD%9B/</url>
    <content><![CDATA[<p>用于求数论函数的前缀和。</p>
<a id="more"></a>
<h2 id="基本的">基本的</h2>
<p>杜教筛就是这么一个柿子： <span class="math display">\[
S(n)=\sum_{i=1}^n(f*g)(i)-\sum_{i=2}^n g(i)S(\lfloor\frac{n}{i}\rfloor)
\]</span> 让我们求一个数论函数 <span class="math inline">\(f\)</span> 的前缀和 <span class="math inline">\(S(n)=\sum_{i=1}^n f(i)\)</span> 时，找一个合适的数论函数 <span class="math inline">\(g\)</span>： <span class="math display">\[
\begin{aligned}
&amp;\quad \sum_{i=1}^n(f*g)(i)\\
&amp;=\sum_{i=1}^n\sum_{d|i}g(d)f(\frac{i}{d})\\
&amp;=\sum_{d=1}^n g(d)\sum_{d|i}f(\frac{i}{d})\\
&amp;=\sum_{d=1}^n g(d)\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}f(i)\\
&amp;=\sum_{d=1}^n g(d)S(\lfloor\frac{n}{d}\rfloor)\\
\end{aligned}
\]</span> <span class="math inline">\(g\)</span> 函数要满足 <span class="math inline">\(f*g\)</span> 的前缀和是很容易得到的，这样求 <span class="math inline">\(g(1)S(n)\)</span> 时， <span class="math display">\[
g(1)S(n)=\sum_{i=1}^n(f*g)(i)-\sum_{i=2}^n g(i)S(\lfloor\frac{n}{i}\rfloor)
\]</span> 所有积性函数都满足 <span class="math inline">\(g(1)=1\)</span>，就可以忽略 <span class="math inline">\(g(1)\)</span>。</p>
<p>最右边那项可以整除分块，<span class="math inline">\(S(\lfloor\frac{n}{i}\rfloor)\)</span> 递归求解。</p>
<p>对于小于 <span class="math inline">\(n^{\frac{2}{3}}\)</span> 的线性预处理，递归的加上 <code>unordered_map / map</code> 记忆化。</p>
<p>这样复杂度为 <span class="math inline">\(\mathcal O(n^{\frac{2}{3}})\)</span>，<del>我<strong>又</strong>不会证</del>。</p>
<h2 id="一些例子">一些例子</h2>
<ul>
<li><p><span class="math inline">\(\varphi\)</span></p>
<p><span class="math display">\[
  \varphi*I=id
  \]</span> <span class="math display">\[
  S_{\varphi}(n)=\sum_{i=1}^n i-\sum_{i=2}^n S_{\varphi}(\lfloor\frac{n}{i}\rfloor)
  \]</span></p></li>
<li><p><span class="math inline">\(\mu\)</span></p>
<p><span class="math display">\[
  \mu*I=\epsilon
  \]</span> <span class="math display">\[
  S_{\mu}(n)=1-\sum_{i=2}^n S_{\mu}(\lfloor\frac{n}{i}\rfloor)
  \]</span></p></li>
<li><p><span class="math inline">\(\sigma_k\)</span></p>
<p>其中 <span class="math inline">\(\sigma_k(n)=\sum_{d|n}d^k\)</span>。 <span class="math display">\[
\sigma_k=id_k*I
\]</span></p>
<p><span class="math display">\[
\sum_{i=1}^n \sigma_k(i)=\sum_{i=1}^ni^k\lfloor\frac{n}{i}\rfloor
\]</span></p>
<blockquote>
<p>常用 <span class="math inline">\(S_{id_k}(n)\)</span> 公式： <span class="math display">\[
\begin{aligned}
S_{id}(n)&amp;=\frac{n(n+1)}{2}\\
S_{id_2}(n)&amp;=\frac{n(n+1)(2n+1)}{6}\\
S_{id_3}(n)&amp;=\Big(\frac{n(n+1)}{2}\Big)^2\\
S_{id_k}(n)&amp;=\frac{1}{k+1}\bigg((n+1)^{t+1}-\sum_{j=0}^{t-1}\binom{t+1}{j}S_{id_j}(n)\bigg)\\
\end{aligned}
\]</span></p>
</blockquote></li>
<li><p><span class="math inline">\(\varphi\cdot id_k\)</span></p>
<p>当 <span class="math inline">\(C\)</span> 是完全积性函数时，<span class="math inline">\((A\cdot C)*(B\cdot C)=(A*B)\cdot C\)</span>。 <span class="math display">\[
  (\varphi\cdot id_k)*(I\cdot id_k)=(\varphi* I)\cdot id_k=id_{k+1}
  \]</span></p>
<p><span class="math display">\[
  S_{\varphi\cdot id_k}(n)=\sum_{i=1}^ni^{k+1}-\sum_{i=2}^ni^kS_{\varphi\cdot id_k}(\lfloor\frac{n}{i}\rfloor)
  \]</span></p></li>
<li><p><span class="math inline">\(\mu\cdot id_k\)</span></p>
<p>同理。 <span class="math display">\[
  (\mu\cdot id_k)*(I\cdot id_k)=(\mu*I)\cdot id_k=\epsilon
  \]</span></p>
<p><span class="math display">\[
  S_{\mu\cdot id_k}(n)=1-\sum_{i=2}^ni^kS_{\mu\cdot id_k}(\lfloor\frac{n}{i}\rfloor)
  \]</span></p></li>
<li><p><span class="math inline">\(\mu^2*(\mu\cdot id)\)</span> <span class="math display">\[
  (\mu^2*(\mu\cdot id))*id=\mu^2*((\mu\cdot id)*(I\cdot id))=\mu^2
  \]</span></p>
<p><span class="math display">\[
  S_{\mu^2*(\mu\cdot id)}(n)=S_{\mu^2}(n)-\sum_{i=2}^n iS_{\mu^2*(\mu\cdot id)}(\lfloor\frac{n}{i}\rfloor)
  \]</span></p>
<p><span class="math inline">\(S_{\mu^2}(n)\)</span> 可以 <span class="math inline">\(\mathcal O(\sqrt{n})\)</span> 求，见 <a href="https://www.luogu.com.cn/problem/P4318">P4318 完全平方数</a>。</p></li>
</ul>
]]></content>
      <categories>
        <category>总结</category>
        <category>Math</category>
      </categories>
      <tags>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title>通过namespace防止命名冲突</title>
    <url>/2019/12/25/%E9%80%9A%E8%BF%87namespace%E9%98%B2%E6%AD%A2%E5%91%BD%E5%90%8D%E5%86%B2%E7%AA%81/</url>
    <content><![CDATA[<p>不止一位学长讲述过一些选手因为"next""pipe"而暴毙的英雄事迹。。。</p>
<p>那么Linux下如何防止命名冲突？</p>
<a id="more"></a>
<p><del>或者仅仅是因为懒得想变量名</del></p>
<p><strong><em>听过学长的指导后，本文全程口糊，有不恰当处还请指出</em></strong></p>
<p>C++中有了<strong>命名空间</strong>这个东西，不同命名空间的元素可以同名</p>
<p>你平时写的<code>using namespace std;</code>就是代替了每次调用时的<code>std::</code>，相当于把std作为此程序的命名空间</p>
<p>我们可以创建自己的命名空间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> NAME &#123;<span class="comment">// NAME可以是你自己取的名字</span></span><br><span class="line">    <span class="comment">// code...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面的程序正常写就行</p>
<p>不过C++的运行端口是::main，所以main函数写在namespace里会找不到端口，无法运行</p>
<p>只把main写在外面？<del>这辈子都不会的</del></p>
<p>为了程序的优美性，可以namespace里写一个main，外面调用即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> BANANA &#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;<span class="comment">// inline是一点优化，自己百度。因为没必要必须返回0，可以是void</span></span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BANANA::main();<span class="comment">// 和std同理，通过BANANA::调用就没有冲突</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话写一大堆函数和全局变量的时候，main函数依然优美</p>
<p><strong>总之自己看着舒服就行</strong></p>
<p>另外，namespace是可以<strong>嵌套</strong>的，并且优先级是<strong>本层namespace &gt; 外层namespace</strong></p>
<p>调用时本层找不到就会从上一层找</p>
<p>于是我们照样写<code>using namespace std</code>，不受影响，<del>太棒了不用写烦人的std</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">namespace</span> BANANA &#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">namespace</span> OI &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;兜售小main包烤绿鸟&quot;</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// cout照样用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 这里的a = 1</span></span><br><span class="line">        OI::sell();<span class="comment">// 调用其他namespace的元素同理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BANANA::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了你还怕什么？</p>
<p>不过学长实测，如果你起linux,unix的变量名，还是会翻车，<del>他们太硬了</del></p>
<p>不过你可以随心所欲地打万能头了。。。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">namespace</span> BANANA &#123;</span><br><span class="line">    <span class="keyword">int</span> x1, x2, y1, y2;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> pipe, next[<span class="number">105</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;小main包烤绿鸟还有人要么！！！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BANANA::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>祝大家敲代码愉快~</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>题解 P3233 [HNOI2014]世界树</title>
    <url>/2020/04/06/%E9%A2%98%E8%A7%A3%20P3233%20HNOI2014%E4%B8%96%E7%95%8C%E6%A0%91/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3233">题目</a></p>
<blockquote>
<p>给一棵树，每条边距离为1，q 次询问，每次选择 k 个关键点，树上每个点由距离最近的关键的管辖（距离相同选择编号最小的），求每个关键的管辖点数</p>
<p><span class="math inline">\(N,q\le3\times10^5,\sum_{i=1}^q{k_i}\le3\times10^5\)</span></p>
</blockquote>
<a id="more"></a>
<h2 id="思路">思路</h2>
<p><strong>树形dp</strong>，看数据范围，需要建<strong>虚树</strong>来优化</p>
<p>考虑每次把关键点建出虚树</p>
<p>dp求出每个点 u 的 <span class="math inline">\(belong_u\)</span>（管辖 u 的关键点），<span class="math inline">\(dis_u\)</span> （u 到 <span class="math inline">\(belong_u\)</span> 的距离）</p>
<p>类似最短路的松弛，注意第一遍dp统计儿子对父亲的贡献，第二遍统计父亲对儿子的贡献</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (dis[u] &gt; dis[v] + E[i].val || (dis[u] == dis[v] + E[i].val &amp;&amp; bl[u] &gt; bl[v]))</span><br><span class="line">    dis[u] = dis[v] + E[i].val, bl[u] = bl[v];</span><br></pre></td></tr></table></figure>
<p>第三遍dp统计答案，设 <span class="math inline">\(f_u\)</span> 表示原树中经过 u 增加 <span class="math inline">\(belong_u\)</span> 贡献的点数</p>
<p>在虚树上有两种情况：</p>
<ul>
<li>以 u 为根的原树的子树中没有关键点，那么这棵子树都由 u 或 <span class="math inline">\(belong_u\)</span> 管辖</li>
<li>虚树上连接 u 和 v 的边（u 为 v 的父亲），代表原树中的一条链，又分两种情况：
<ul>
<li><span class="math inline">\(belong_u=belong_v\)</span>，这一条链除了 v 点其它都是 u 的贡献（v 点及其子树为 v 的贡献）</li>
<li><span class="math inline">\(belong_u\not=belong_v\)</span>，这条链被分成两部分，通过倍增找出分界点，划分 u,v 贡献</li>
</ul></li>
</ul>
<p>把 u 贡献加到 <span class="math inline">\(belong_u\)</span> 的答案上即可</p>
<h3 id="细节">细节</h3>
<p>这题一堆全局变量数组（命名冲突好麻烦），比大数据结构难调</p>
<p>关于链上找分界点（属于 v 范围的最高点）：</p>
<p>先求出 <span class="math inline">\(belong_u\)</span> 和 <span class="math inline">\(belong_v\)</span> 的距离 d，<code>deep[v] - (d / 2 - dis[v])</code> 即中间点的 deep</p>
<p>如果 u，v 中间有奇数个点，必定有一个点 x 到两个关键点的距离相等，要让 d - 1，倍增后中间点为 x 的儿子（对 d 为偶数没有影响），看两个关键点编号大小选择是否往上走</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> d = deep[v] - deep[u] + dis[u] + dis[v] - <span class="number">1</span>, tmp = d / <span class="number">2</span> - dis[v], mid = v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">19</span>; ~j; --j)</span><br><span class="line">    <span class="keyword">if</span> (deep[fa[mid][j]] &gt;= deep[v] - tmp)</span><br><span class="line">        mid = fa[mid][j];</span><br><span class="line"><span class="keyword">if</span> ((d &amp; <span class="number">1</span>) &amp;&amp; tmp &gt;= <span class="number">0</span> &amp;&amp; bl[u] &gt; bl[v]) mid = fa[mid][<span class="number">0</span>];<span class="comment">// tmp 可能为负</span></span><br></pre></td></tr></table></figure>
<p>另外<strong>多测要清空</strong></p>
<h2 id="code">code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TT&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(TT x, <span class="keyword">char</span> end = <span class="string">&#x27;\n&#x27;</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> nxt, to, val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, cnt_e, Q, k, dfu, tot, top;</span><br><span class="line"><span class="keyword">int</span> head[N], Head[N], pu[N], po[N];</span><br><span class="line"><span class="keyword">int</span> deep[N], fa[N][<span class="number">20</span>], size[N], a[N], t[N&lt;&lt;<span class="number">1</span>], stk[N];</span><br><span class="line"><span class="keyword">int</span> dis[N], bl[N], f[N], ans[N];</span><br><span class="line">Edge e[N&lt;&lt;<span class="number">1</span>], E[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> is[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[++cnt_e] = (Edge)&#123;head[u], v, w&#125;, head[u] = cnt_e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    E[++cnt_e] = (Edge)&#123;Head[u], v, w&#125;, Head[u] = cnt_e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">    pu[u] = ++dfu;</span><br><span class="line">    deep[u] = deep[last] + <span class="number">1</span>;</span><br><span class="line">    fa[u][<span class="number">0</span>] = last;</span><br><span class="line">    size[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; <span class="number">1</span> &lt;&lt; i &lt;= deep[u]; ++i)</span><br><span class="line">        fa[u][i] = fa[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span> ((v = e[i].to) != last)</span><br><span class="line">            dfs(v, u), size[u] += size[v];</span><br><span class="line">    po[u] = ++dfu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deep[x] &lt; deep[y]) swap(x, y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> (deep[fa[x][i]] &gt;= deep[y])</span><br><span class="line">            x = fa[x][i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> (fa[x][i] != fa[y][i])</span><br><span class="line">            x = fa[x][i], y = fa[y][i];</span><br><span class="line">    <span class="keyword">return</span> x == y ? x : fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; <span class="number">0</span> ? pu[x] : po[-x]) &lt; (y &gt; <span class="number">0</span> ? pu[y] : po[-y]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build_tree</span><span class="params">(<span class="keyword">int</span> kk)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> vis[N];</span><br><span class="line">    tot = top = cnt_e = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= kk; ++i)</span><br><span class="line">        t[++tot] = a[i], vis[t[tot]] = <span class="literal">true</span>;</span><br><span class="line">    sort(t+<span class="number">1</span>, t+tot+<span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, lca; i &lt; kk; ++i) &#123;</span><br><span class="line">        lca = LCA(t[i], t[i+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (!vis[lca]) t[++tot] = lca, vis[lca] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!vis[<span class="number">1</span>]) t[++tot] = <span class="number">1</span>;</span><br><span class="line">    kk = tot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= kk; ++i)</span><br><span class="line">        t[++tot] = -t[i];</span><br><span class="line">    sort(t+<span class="number">1</span>, t+tot+<span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= tot; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t[i] &gt; <span class="number">0</span>) stk[++top] = t[i];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            v = stk[top--], u = stk[top];</span><br><span class="line">            Add_edge(u, v, deep[v] - deep[u]), Add_edge(v, u, deep[v] - deep[u]);</span><br><span class="line">            vis[v] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is[u]) dis[u] = <span class="number">0</span>, bl[u] = u;</span><br><span class="line">    <span class="keyword">else</span> dis[u] = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Head[u], v; i; i = E[i].nxt)</span><br><span class="line">        <span class="keyword">if</span> ((v = E[i].to) != last) &#123;</span><br><span class="line">            dp1(v, u);</span><br><span class="line">            <span class="keyword">if</span> (dis[u] &gt; dis[v] + E[i].val || (dis[u] == dis[v] + E[i].val &amp;&amp; bl[u] &gt; bl[v]))</span><br><span class="line">                dis[u] = dis[v] + E[i].val, bl[u] = bl[v];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我把第二三遍dp合在一块了</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">    f[u] = size[u];<span class="comment">// 初值为子树size</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Head[u], v; i; i = E[i].nxt)</span><br><span class="line">        <span class="keyword">if</span> ((v = E[i].to) != last) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[v] &gt; dis[u] + E[i].val || (dis[v] == dis[u] + E[i].val &amp;&amp; bl[v] &gt; bl[u]))</span><br><span class="line">                dis[v] = dis[u] + E[i].val, bl[v] = bl[u];</span><br><span class="line">            dp2(v, u);</span><br><span class="line">            <span class="keyword">if</span> (bl[u] == bl[v])</span><br><span class="line">                f[u] -= size[v];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> d = deep[v] - deep[u] + dis[u] + dis[v] - <span class="number">1</span>, tmp = d / <span class="number">2</span> - dis[v], mid = v;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">19</span>; ~j; --j)</span><br><span class="line">                    <span class="keyword">if</span> (deep[fa[mid][j]] &gt;= deep[v] - tmp)</span><br><span class="line">                        mid = fa[mid][j];</span><br><span class="line">                <span class="keyword">if</span> ((d &amp; <span class="number">1</span>) &amp;&amp; tmp &gt;= <span class="number">0</span> &amp;&amp; bl[u] &gt; bl[v]) mid = fa[mid][<span class="number">0</span>];<span class="comment">// tmp可能为负数</span></span><br><span class="line">                f[u] -= size[mid];</span><br><span class="line">                f[v] += size[mid] - size[v];</span><br><span class="line">            &#125;</span><br><span class="line">            ans[bl[v]] += f[v];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (u == <span class="number">1</span>) ans[bl[<span class="number">1</span>]] += f[<span class="number">1</span>];<span class="comment">// 别落下根节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++i)	</span><br><span class="line">        read(u), read(v), add_edge(u, v, <span class="number">0</span>), add_edge(v, u, <span class="number">0</span>);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    read(Q);</span><br><span class="line">    <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">        read(k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">            read(a[i]), is[a[i]] = <span class="literal">true</span>;</span><br><span class="line">        build_tree(k);</span><br><span class="line">        dp1(<span class="number">1</span>, <span class="number">0</span>), dp2(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">            print(ans[a[i]], <span class="string">&#x27; &#x27;</span>), is[a[i]] = ans[a[i]] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// 清空，用memset会TLE</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i)</span><br><span class="line">            <span class="keyword">if</span> (t[i] &gt; <span class="number">0</span>)</span><br><span class="line">                Head[t[i]] = dis[t[i]] = bl[t[i]] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>倍增</tag>
        <tag>树形DP</tag>
        <tag>虚树</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 CF571D Campus</title>
    <url>/2020/11/26/%E9%A2%98%E8%A7%A3-CF571D-Campus/</url>
    <content><![CDATA[<p>转化成树上问题 + 树状数组上二分技巧。</p>
<a id="more"></a>
<h2 id="题意">题意</h2>
<p><a href="https://www.luogu.com.cn/problem/CF571D">题目</a></p>
<blockquote>
<p>维护两类集合 <span class="math inline">\(A,B\)</span>，初始 <span class="math inline">\(A_x=B_x=x\)</span>，序列全为 0，有五个操作：</p>
<ul>
<li>将 <span class="math inline">\(A_y\)</span> 合并到 <span class="math inline">\(A_x\)</span>；</li>
<li>将 <span class="math inline">\(B_y\)</span> 合并到 <span class="math inline">\(B_x\)</span>；</li>
<li>将集合 <span class="math inline">\(A_x\)</span> 中元素所在序列的值加上 <span class="math inline">\(|A_x|\)</span>；</li>
<li>将集合 <span class="math inline">\(B_x\)</span> 中元素所在序列的值都设为 <span class="math inline">\(0\)</span>；</li>
<li>求序列下标 <span class="math inline">\(x\)</span> 的值。</li>
</ul>
<p><span class="math inline">\(n,m\le 10^5\)</span>。</p>
</blockquote>
<h2 id="思路">思路</h2>
<p>每次把两个集合合并时新建一个虚点作为两者的父亲，操作 <span class="math inline">\(3\)</span> 就是二叉树上的子树加。</p>
<p>查询单点时就在树上 dfs，用树状数组在时间上维护权值和。</p>
<p>问题在于操作 <span class="math inline">\(2,4\)</span>，我们需要知道单点询问时，该点最晚的清零操作的时间。</p>
<p>我们用同样的合并方法在第二棵树上处理操作 <span class="math inline">\(2,4\)</span>，在这棵树上 dfs，用树状数组在时间上维护清零操作。</p>
<p>如果该点有询问操作，那就在树状数组里二分最晚的清零操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回s[i]小于s[x]的最大的i</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">bound</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    LL s = query(x);</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> &lt;&lt; <span class="number">19</span>; i; i &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x + i &lt; N &amp;&amp; sum[x + i] &lt; s) &#123;</span><br><span class="line">            x += i;</span><br><span class="line">            s -= sum[x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>这样就可以避免像辣鸡的 RenaMoe 一样在外面套一次二分了，又多个 <span class="math inline">\(\log\)</span>。</del></p>
<p>梳理一下，就是先建出两棵树，第二棵树上处理出每个询问点最晚的清零操作，然后在第一棵树上对每个询问点区间查和，复杂度 <span class="math inline">\(\mathcal O(n\log n)\)</span>。</p>
<h2 id="代码">代码</h2>
<p>这里的第一棵树和第二棵树是反着的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ask</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> opt;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BitTree</span> &#123;</span></span><br><span class="line">    LL sum[N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, LL k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt; N; i += i &amp; -i) sum[i] += k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        LL res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i -= i &amp; -i) res += sum[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">bound</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        LL s = query(x);</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> &lt;&lt; <span class="number">19</span>; i; i &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x + i &lt; N &amp;&amp; sum[x + i] &lt; s) &#123;</span><br><span class="line">                x += i;</span><br><span class="line">                s -= sum[x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; T;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    <span class="keyword">int</span> ls[N], rs[N], fa[N], size[N], id[N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        tot = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; ++i) size[i] = <span class="number">1</span>, id[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        ++tot;</span><br><span class="line">        fa[id[x]] = fa[id[y]] = tot;</span><br><span class="line">        ls[tot] = id[x], rs[tot] = id[y];</span><br><span class="line">        size[tot] = size[id[x]] + size[id[y]];</span><br><span class="line">        id[x] = tot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; G1, G2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">LL ans[N];</span><br><span class="line">Ask q[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; add[N], clr[N], qry[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clr[u].size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = clr[u][i];</span><br><span class="line">        T.update(j, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qry[u].size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = qry[u][i];</span><br><span class="line">            q[j].y = T.bound(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> dfs1(G1.ls[u]), dfs1(G1.rs[u]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clr[u].size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = clr[u][i];</span><br><span class="line">        T.update(j, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; add[u].size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = add[u][i];</span><br><span class="line">        T.update(j, G2.size[u]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qry[u].size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = qry[u][i];</span><br><span class="line">            ans[j] = T.query(j) - T.query(q[j].y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> dfs2(G2.ls[u]), dfs2(G2.rs[u]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; add[u].size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = add[u][i];</span><br><span class="line">        T.update(j, -G2.size[u]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(m);</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">        q[i].opt = str[<span class="number">0</span>];</span><br><span class="line">        read(q[i].x);</span><br><span class="line">        <span class="keyword">if</span> (q[i].opt == <span class="string">&#x27;U&#x27;</span> || q[i].opt == <span class="string">&#x27;M&#x27;</span>) read(q[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    G1.init(n), G2.init(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[i].opt == <span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">            G1.link(q[i].x, q[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q[i].opt == <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = G1.id[q[i].x];</span><br><span class="line">            clr[x].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q[i].opt == <span class="string">&#x27;U&#x27;</span>) &#123;</span><br><span class="line">            G2.link(q[i].x, q[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q[i].opt == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = G2.id[q[i].x];</span><br><span class="line">            add[x].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q[i].opt == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            qry[q[i].x].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= G1.tot; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!G1.fa[i]) dfs1(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= G2.tot; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!G2.fa[i]) dfs2(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[i].opt == <span class="string">&#x27;Q&#x27;</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 GYM102331B Bitwise Xor</title>
    <url>/2020/11/27/%E9%A2%98%E8%A7%A3-GYM102331B-Bitwise-Xor/</url>
    <content><![CDATA[<p>jiangly contest T3。</p>
<p>用 01-trie 优化 DP。</p>
<a id="more"></a>
<h2 id="题意">题意</h2>
<p><a href="https://codeforces.com/gym/102331/problem/B">题目</a></p>
<blockquote>
<p>给出长为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(x\)</span>，若一个 <span class="math inline">\(a\)</span> 的长为 <span class="math inline">\(k\)</span> 的子序列 <span class="math inline">\(b\)</span> 满足对于 <span class="math inline">\(b_i \operatorname{xor} b_j \ge x(1\le i &lt; j\le k)\)</span>，则是合法的序列，求 <span class="math inline">\(a\)</span> 的合法序列方案数。</p>
<p><span class="math inline">\(1\le n\le 3\times 10^5,0\le a_i\le 2^{60}-1\)</span>。</p>
</blockquote>
<h2 id="思路">思路</h2>
<p><span class="math inline">\(b\)</span> 的条件要求 <span class="math inline">\(b_i \operatorname{xor} b_j\)</span> 的最小值大于等于 <span class="math inline">\(x\)</span>，条件很严苛。</p>
<p>但是将 <span class="math inline">\(b\)</span> 排序后，这个最小值只能出现在相邻两项的异或值。</p>
<figure>
<img src="https://s3.ax1x.com/2020/11/27/DrNPN4.png" alt="证明 by jiangly" /><figcaption aria-hidden="true">证明 by jiangly</figcaption>
</figure>
<p>于是我们只要保证相邻两项异或值大于等于 <span class="math inline">\(x\)</span>。（考场上看错题的）</p>
<p>可以轻松的到 <span class="math inline">\(\mathcal O(n^2)\)</span> 的 DP 转移方程： <span class="math display">\[
f_i\leftarrow 1+\sum_{1\le j&lt; i}[a_i \operatorname{xor} a_j\ge x]f_j
\]</span> 考虑从异或入手，可以想到 01-trie。</p>
<p>在 01-trie 上节点存子树权值和，每次查询符合条件的 <span class="math inline">\(\sum f_j\)</span> 并插入 <span class="math inline">\(a_i\)</span> 权值为 <span class="math inline">\(f_i\)</span>。</p>
<p>如何查询？</p>
<p>我们令 <span class="math inline">\(a_i \operatorname{xor} a_j=x\)</span>，在 trie 上 <span class="math inline">\(a_j\)</span> 的这条路径上，对于从高到低每一位，设这一位 <span class="math inline">\(a_j\)</span> 为 <span class="math inline">\(a\)</span>，<span class="math inline">\(a_j\)</span> 为 <span class="math inline">\(b\)</span>，<span class="math inline">\(x\)</span> 为 <span class="math inline">\(c\)</span>。</p>
<p>如果 <span class="math inline">\(c\)</span> 为 <span class="math inline">\(0\)</span>，那么这一位可以为 <span class="math inline">\(1\)</span>，加上 <span class="math inline">\(a \operatorname{xor} 1\)</span> 的子树。</p>
<p>复杂度 <span class="math inline">\(\mathcal O(n\log a)\)</span>。</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n, tot;</span><br><span class="line">LL k, ans;</span><br><span class="line">LL a[N], sum[N*<span class="number">60</span>], ch[N*<span class="number">60</span>][<span class="number">2</span>], f[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(LL x, LL val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">61</span>; ~i; --i) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!ch[p][c]) ch[p][c] = ++tot;</span><br><span class="line">        p = ch[p][c];</span><br><span class="line">        (sum[p] += val) %= P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">query</span><span class="params">(LL x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">61</span>; ~i; --i) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = (x &gt;&gt; i) &amp; <span class="number">1</span>, d = (k &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!d) (res += sum[ch[p][c ^ <span class="number">1</span>]]) %= P;</span><br><span class="line">        p = ch[p][c ^ d];</span><br><span class="line">        <span class="keyword">if</span> (!p) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    (res += sum[p]) %= P;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(a[i]);</span><br><span class="line">    sort(a+<span class="number">1</span>, a+n+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    tot = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        f[i] = (query(a[i]) + <span class="number">1</span>) % P;</span><br><span class="line">        insert(a[i], f[i]);</span><br><span class="line">        (ans += f[i]) %= P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>01-trie</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P1322 logo语言</title>
    <url>/2019/12/24/%E9%A2%98%E8%A7%A3-P1322-logo%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p><strong>这里是栈的做法</strong></p>
<p>递归快写吐了，决心用栈，结果调了半天。。。</p>
<a id="more"></a>
<p>应该都能想到，FD就加，BF就减，REPEAT就压栈，']'就弹栈</p>
<p>手写栈比较舒服，<del>用STL的stack有点丑</del></p>
<p><strong>细节太重要了</strong></p>
<p>敲的时候应该注意：读入是否从有效字符开始（用char[]的注意）、']'的读入、用过的那层栈要清空。。。</p>
<p><del>都是废话，自己写写就知道了</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BANANA &#123;<span class="comment">//防止命名冲突</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;<span class="comment">// 快读</span></span><br><span class="line">    <span class="keyword">int</span> re = <span class="number">0</span>, k = <span class="number">1</span>; <span class="keyword">char</span> in = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(in)) &#123; <span class="keyword">if</span> (in == <span class="string">&#x27;-&#x27;</span>) k = <span class="number">-1</span>; in = getchar(); &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(in)) re = re * <span class="number">10</span> + in - <span class="string">&#x27;0&#x27;</span>, in = getchar();</span><br><span class="line">    <span class="keyword">return</span> re * k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[<span class="number">305</span>], k[<span class="number">305</span>];<span class="comment">// stack：栈，k：这一层栈repeat的次数</span></span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">num</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;<span class="comment">// 把s串开头的数字提出来</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; <span class="built_in">isdigit</span>(s[i]); i++)</span><br><span class="line">        ans = ans * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s) &#123;<span class="comment">// ctrl+z结束</span></span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">            <span class="built_in">stack</span>[top] += num(s);</span><br><span class="line">            <span class="keyword">int</span> len = s.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (s[len] == <span class="string">&#x27;]&#x27;</span>)<span class="comment">// 结尾有&#x27;]&#x27;要退栈</span></span><br><span class="line">                <span class="built_in">stack</span>[top<span class="number">-1</span>] += k[top<span class="number">-1</span>] * <span class="built_in">stack</span>[top], top--, len--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">            <span class="built_in">stack</span>[top] -= num(s);</span><br><span class="line">            <span class="keyword">int</span> len = s.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (s[len] == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">                <span class="built_in">stack</span>[top<span class="number">-1</span>] += k[top<span class="number">-1</span>] * <span class="built_in">stack</span>[top], top--, len--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">            k[top] = read();</span><br><span class="line">            top++;</span><br><span class="line">            <span class="built_in">stack</span>[top] = <span class="number">0</span>;<span class="comment">// 用之前清空（之前因为这个WA了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 特判&quot;[]&quot;里什么都没有的</span></span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">// 前面已经读入了&#x27;[&#x27;，所以从0开始</span></span><br><span class="line">            <span class="keyword">while</span> (s[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; i &lt; s.size())</span><br><span class="line">                <span class="built_in">stack</span>[top<span class="number">-1</span>] += k[top<span class="number">-1</span>] * <span class="built_in">stack</span>[top], top--, i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">abs</span>(<span class="built_in">stack</span>[<span class="number">1</span>]));<span class="comment">// 注意是距离（绝对值）</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BANANA::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2054 [AHOI2005]洗牌</title>
    <url>/2019/12/25/%E9%A2%98%E8%A7%A3-P2054-AHOI2005%E6%B4%97%E7%89%8C/</url>
    <content><![CDATA[<p>洗牌???</p>
<p><del>吐槽一下题目的图片，差点误导了我</del></p>
<p>这么麻烦的题面当然先模拟啦。。。</p>
<a id="more"></a>
<p>打表发现每次洗牌后第 <span class="math inline">\(i\)</span> 张牌会转移到第 <span class="math inline">\(2*i \%(n+1)\)</span> 的位置上</p>
<p>即在<span class="math inline">\(\mod{n+1}\)</span>意义下，<span class="math inline">\(i\)</span> 和 <span class="math inline">\(2i\)</span> 是同余的</p>
<p>so，可以列出一个同余方程：</p>
<p><span class="math inline">\(i * 2^{m} \equiv l\pmod {n+1}\)</span></p>
<p>再转化为</p>
<p><span class="math display">\[2 ^ {m} * i + (n+1) * k = l\]</span></p>
<p><span class="math display">\[2^{m} * \frac{i}{l} + (n+1) * \frac{k}{l} = 1\]</span></p>
<p>此时利用<span class="math inline">\(exgcd\)</span>完美地算出<span class="math inline">\(\frac{i}{l}\)</span>，乘上<span class="math inline">\(l\)</span>即可</p>
<p><strong>注意：</strong>范围1e10，如果直接乘会gg，要用快速乘，和快速幂差不多</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;<span class="comment">// 快读</span></span><br><span class="line">    x = <span class="number">0</span>; T k = <span class="number">1</span>; <span class="keyword">char</span> in = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(in)) &#123; <span class="keyword">if</span> (in == <span class="string">&#x27;-&#x27;</span>) k = <span class="number">-1</span>; in = getchar(); &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(in)) x = x * <span class="number">10</span> + in - <span class="string">&#x27;0&#x27;</span>, in = getchar();</span><br><span class="line">    x *= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;<span class="comment">// 开long long</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速乘</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">mul</span><span class="params">(ll a, ll b, ll p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将乘法变为加法，二进制优化，边加边模</span></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            ans = (ans + a) % p;</span><br><span class="line">        a = (a + a) % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速幂，其实只要写针对2的整次幂就行，这里犯懒。。。</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">q_pow</span><span class="params">(ll a, ll b, ll p)</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            ans = mul(ans, a, p) % p;</span><br><span class="line">        a = mul(a, a, p) % p, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标配扩欧</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y, ll &amp;g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>, g = a;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        exgcd(b, a%b, y, x, g);</span><br><span class="line">        y -= a / b * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n, m, l, x, y, g, t;</span><br><span class="line">    read(n), read(m), read(l);</span><br><span class="line">    t = q_pow(<span class="number">2</span>, m, n+<span class="number">1</span>);<span class="comment">// 2的m次幂</span></span><br><span class="line">    exgcd(t, n+<span class="number">1</span>, x, y, g);</span><br><span class="line">    x = (x % (n+<span class="number">1</span>) + n+<span class="number">1</span>) % (n+<span class="number">1</span>);<span class="comment">// 注意exgcd后解可能为负</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, mul(x, l, n+<span class="number">1</span>));<span class="comment">// 乘上l</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Math</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2704 [NOI2001]炮兵阵地</title>
    <url>/2019/12/25/%E9%A2%98%E8%A7%A3-P2704-NOI2001%E7%82%AE%E5%85%B5%E9%98%B5%E5%9C%B0/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P2704">题目</a></p>
<p><del>珍爱头发，远离状压</del></p>
<p>首先如果没做过状压的话，出门<a href="https://www.luogu.org/problem/P1879">右转</a></p>
<a id="more"></a>
<h2 id="思路">思路</h2>
<p>这道题。。。数据范围很状压</p>
<p><del>显然</del>，把每一行的地图（有山为1，否则为0）压到一个数里</p>
<p>把枚举的状态压成有炮为1，否则为0</p>
<p><strong>把有解的情况存下来</strong>，便于枚举，并预处理每种情况的炮兵个数</p>
<p>现在<strong>用<span class="math inline">\(f_{i,j,k}\)</span>表示第<span class="math inline">\(i\)</span>行是状态<span class="math inline">\(j\)</span>，是由状态<span class="math inline">\(k\)</span>转移来的，最大的炮兵个数</strong></p>
<p>单独处理第一行和第二行</p>
<p>后面<span class="math inline">\(dp\)</span>的时候注意:</p>
<p>如何使一列中的每三行只有一个炮兵？</p>
<p>保证<span class="math inline">\(k1\)</span> &amp; <span class="math inline">\(k2\)</span>, <span class="math inline">\(k2\)</span> &amp; <span class="math inline">\(k3\)</span>, <span class="math inline">\(k1\)</span> &amp; <span class="math inline">\(k3\)</span>都为0即可（显然）</p>
<p>另外，空间有点。。。建议<strong>滚动数组</strong></p>
<hr />
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; T k = <span class="number">1</span>; <span class="keyword">char</span> in = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(in)) &#123; <span class="keyword">if</span> (in == <span class="string">&#x27;-&#x27;</span>) k = <span class="number">-1</span>; in = getchar(); &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(in)) x = x * <span class="number">10</span> + in - <span class="string">&#x27;0&#x27;</span>, in = getchar();</span><br><span class="line">    x *= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1</span>&lt;&lt;<span class="number">11</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">105</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, maxn, ans;</span><br><span class="line"><span class="keyword">int</span> mp[N], f[<span class="number">3</span>][M][M];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; d, v;<span class="comment">// 可行状态的对应的炮兵个数</span></span><br><span class="line"><span class="keyword">char</span> in[<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算每种情况的炮兵个数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> re = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">30</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (x &amp; (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">            re++;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(m);</span><br><span class="line">    maxn = (<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, in);</span><br><span class="line">        <span class="comment">//处理地图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">            <span class="keyword">if</span> (in[j] == <span class="string">&#x27;H&#x27;</span>)</span><br><span class="line">                mp[i] |= <span class="number">1</span> &lt;&lt; j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 预处理可行状态</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxn; ++i)</span><br><span class="line">        <span class="keyword">if</span> ((i &amp; (i &gt;&gt; <span class="number">1</span>)) == <span class="number">0</span> &amp;&amp; (i &amp; (i &gt;&gt; <span class="number">2</span>)) == <span class="number">0</span>)</span><br><span class="line">            d.push_back(i), v.push_back(count(i));</span><br><span class="line">    <span class="comment">// 单独处理一二行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.size(); ++i)</span><br><span class="line">        <span class="keyword">if</span> ((d[i] &amp; mp[<span class="number">0</span>]) == <span class="number">0</span>)<span class="comment">// 一贯的保证可行</span></span><br><span class="line">            f[<span class="number">0</span>][d[i]][<span class="number">0</span>] = v[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.size(); ++i)</span><br><span class="line">        <span class="keyword">if</span> ((d[i] &amp; mp[<span class="number">1</span>]) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; d.size(); ++j)</span><br><span class="line">                <span class="keyword">if</span> ((d[j] &amp; d[i]) == <span class="number">0</span>)</span><br><span class="line">                    f[<span class="number">1</span>][d[i]][d[j]] = max(f[<span class="number">1</span>][d[i]][d[j]], f[<span class="number">0</span>][d[j]][<span class="number">0</span>] + v[i]);</span><br><span class="line">    <span class="comment">// 愉快的dp</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i)<span class="comment">// 行数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; d.size(); ++j)<span class="comment">// 该行</span></span><br><span class="line">            <span class="keyword">if</span> ((d[j] &amp; mp[i]) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; d.size(); ++k)<span class="comment">// 上一行</span></span><br><span class="line">                    <span class="keyword">if</span> ((d[k] &amp; d[j]) == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; d.size(); ++l)<span class="comment">// 上二行</span></span><br><span class="line">                            <span class="keyword">if</span> ((d[l] &amp; d[k]) == <span class="number">0</span> &amp;&amp; (d[l] &amp; d[j]) == <span class="number">0</span>)</span><br><span class="line">                                f[i%<span class="number">3</span>][d[j]][d[k]] = max(f[i%<span class="number">3</span>][d[j]][d[k]], f[(i<span class="number">-1</span>)%<span class="number">3</span>][d[k]][d[l]] + v[j]);<span class="comment">// 重点</span></span><br><span class="line">    <span class="comment">// 统计最后一行的最大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.size(); ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; d.size(); ++j)</span><br><span class="line">            ans = max(ans, f[(n<span class="number">-1</span>)%<span class="number">3</span>][d[i]][d[j]]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P3538 [POI2012]OKR-A Horrible Poem</title>
    <url>/2019/12/25/%E9%A2%98%E8%A7%A3-P3538-POI2012-OKR-A-Horrible-Poem/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/problem/P3538">题面</a></p>
<a id="more"></a>
<h2 id="思路">思路</h2>
<p>判断字符串循环节最方便的是<span class="math inline">\(hash\)</span></p>
<p>不会的请<a href="https://www.luogu.org/problem/P3370">出门左转P3370</a></p>
<p>我们先把字符串<span class="math inline">\(hash\)</span>一遍</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/olzrdhcj.png" /></p>
<p>如图，如果设循环节长度为<span class="math inline">\(3\)</span>时，<span class="math inline">\(s1\)</span>和<span class="math inline">\(s2\)</span>的<span class="math inline">\(hash\)</span>值是相等的</p>
<p>所以只需要找最小的<span class="math inline">\(len\)</span>使得<span class="math inline">\(hash(l+len,r)=hash(l,r-len)\)</span></p>
<hr />
<p>另外，<strong>循环节的长度的循环次数都一定是总长的约数</strong></p>
<p>我的做法是把<strong>总长除掉循环次数</strong></p>
<p>先把<span class="math inline">\(len\)</span>分解质因数</p>
<p>（线性筛质数，并记录下每个数的最小质因子加速分解，<del>这已经是常规操作了</del>）</p>
<p>因为最小循环节的倍数也是循环节</p>
<p>所以从<span class="math inline">\(len\)</span>开始试除每个质因子并判断（你可以理解为<span class="math inline">\(len\)</span>的因子分为循环节的因子和循环次数的因子，要把循环次数的因子除掉）</p>
<p>具体的看代码吧。。。</p>
<hr />
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; T k = <span class="number">1</span>; <span class="keyword">char</span> in = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(in)) &#123; <span class="keyword">if</span> (in == <span class="string">&#x27;-&#x27;</span>) k = <span class="number">-1</span>; in = getchar(); &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(in)) x = x * <span class="number">10</span> + in - <span class="string">&#x27;0&#x27;</span>, in = getchar();</span><br><span class="line">    x *= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ll g[N], hash[N], <span class="built_in">pow</span>[N];<span class="comment">// g记录最小质因子，pow存进制的整数次幂</span></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; pri;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线性筛</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">euler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            pri.push_back(i), g[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pri.size() &amp;&amp; pri[j] * i &lt;= n; ++j) &#123;</span><br><span class="line">            vis[pri[j]*i] = <span class="literal">true</span>, g[pri[j]*i] = pri[j];</span><br><span class="line">            <span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取hash值</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((hash[r] - hash[l<span class="number">-1</span>] * <span class="built_in">pow</span>[r-l+<span class="number">1</span>]) % MOD + MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    euler();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// hash</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        hash[i] = (hash[i<span class="number">-1</span>] * <span class="number">29</span> + s[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>) % MOD;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 预处理整数次幂</span></span><br><span class="line">    <span class="built_in">pow</span>[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">pow</span>[i] = (<span class="built_in">pow</span>[i<span class="number">-1</span>] * <span class="number">29</span>) % MOD;</span><br><span class="line"></span><br><span class="line">    read(m);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r, len, ans;</span><br><span class="line">        read(l), read(r), ans = len = r - l + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 一点点常数优化</span></span><br><span class="line">        <span class="keyword">if</span> (calc(l+<span class="number">1</span>, r) == calc(l, r<span class="number">-1</span>)) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重点</span></span><br><span class="line">        <span class="keyword">while</span> (len &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (calc(l+ans/g[len], r) == calc(l, r-ans/g[len]))<span class="comment">// 判断</span></span><br><span class="line">                ans /= g[len];<span class="comment">// 除掉循环次数的因子</span></span><br><span class="line">            len /= g[len];<span class="comment">//分解</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>字符串</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P4167 [Violet]樱花</title>
    <url>/2019/12/25/%E9%A2%98%E8%A7%A3-P4167-Violet-%E6%A8%B1%E8%8A%B1/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.luogu.org/problem/P4167">题目</a></p>
<p>求不定方程</p>
<p><span class="math display">\[\frac{1}{x} + \frac{1}{y} = \frac{1}{n!}\]</span></p>
<p>的正整数解(x,y)的数目。</p>
</blockquote>
<a id="more"></a>
<hr />
<p>先开始<del>万恶的</del>推式子。。。</p>
<p>原式：</p>
<p><span class="math display">\[\frac{1}{x} + \frac{1}{y} = \frac{1}{n!}\]</span></p>
<p>通个分：</p>
<p><span class="math display">\[xy - n!x - n!y= 0\]</span></p>
<p>补点东西：</p>
<p><span class="math display">\[xy - n!x - n!y + (n!)^2= (n!)^2\]</span></p>
<p><span class="math display">\[(n! - x)(n! - y) = (n!)^2\]</span></p>
<p>此时答案就是<span class="math inline">\((n!)^2\)</span>的约数个数</p>
<hr />
<p>统计<span class="math inline">\(n!\)</span>的约数个数：</p>
<p>把1~n质因数分解，统计各质因子的幂数和即可</p>
<p>再用唯一分解定理统计</p>
<p>注意线性筛素数时记录每一个数的最小质因子，分解就具体看代码</p>
<h2 id="代码">代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; T k = <span class="number">1</span>; <span class="keyword">char</span> in = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(in)) &#123; <span class="keyword">if</span> (in == <span class="string">&#x27;-&#x27;</span>) k = <span class="number">-1</span>; in = getchar(); &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(in)) x = x * <span class="number">10</span> + in - <span class="string">&#x27;0&#x27;</span>, in = getchar();</span><br><span class="line">    x *= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll n, ans;</span><br><span class="line"><span class="keyword">int</span> cnt[N], g[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pri;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">make_prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            pri.push_back(i), g[i] = pri.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pri.size() &amp;&amp; i * pri[j] &lt;= n; ++j) &#123;</span><br><span class="line">            vis[i*pri[j]] = <span class="literal">true</span>;</span><br><span class="line">            g[i*pri[j]] = j;</span><br><span class="line">            <span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    make_prime();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = i;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">1</span>)</span><br><span class="line">            cnt[g[x]]++, x /= pri[g[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= pri.size(); ++i)</span><br><span class="line">        <span class="keyword">if</span> (cnt[i])</span><br><span class="line">            ans = (ans * (cnt[i] * <span class="number">2</span> + <span class="number">1</span>)) % MOD;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Math</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P4218 [CTSC2010]珠宝商</title>
    <url>/2021/01/14/%E9%A2%98%E8%A7%A3-P4218-CTSC2010-%E7%8F%A0%E5%AE%9D%E5%95%86/</url>
    <content><![CDATA[<p>SAM + 点分治 + 根号分治。</p>
<p>很综合的一道题。</p>
<a id="more"></a>
<p><a href="https://www.luogu.com.cn/problem/P4218">题目</a></p>
<blockquote>
<p>给出 <span class="math inline">\(n\)</span> 个点的树，每个点有一个字符，一条路径 <span class="math inline">\((u,v)\)</span> 代表一个字符串，<span class="math inline">\(str(u,v)\neq str(v,u)\)</span>。再给出一个串 <span class="math inline">\(S\)</span>。</p>
<p>设 <span class="math inline">\(count(T)\)</span> 表示 <span class="math inline">\(T\)</span> 在 <span class="math inline">\(S\)</span> 中出现次数，求 <span class="math inline">\(\sum_{u,v} count(str(u,v))\)</span>。</p>
<p><span class="math inline">\(n,m\le 5\times 10^4\)</span>。</p>
</blockquote>
<h2 id="思路">思路</h2>
<h3 id="暴力">暴力</h3>
<p>我们先想一个 <span class="math inline">\(\mathcal O(n^2)\)</span> 的暴力。</p>
<p>把 <span class="math inline">\(S\)</span> 串建立 SAM，考虑把每个点 <span class="math inline">\(u\)</span> 作为根，一边 dfs 一边在 SAM 上匹配，可以统计所有一端为 <span class="math inline">\(u\)</span> 的路径的答案。</p>
<h3 id="点分治">点分治</h3>
<p>树上路径计数问题，可以想到点分治。</p>
<p>点分治就需要考虑链的合并，可以对于 <span class="math inline">\(S\)</span> 和反串 <span class="math inline">\(S^r\)</span> 分别建立 SAM，记为 <span class="math inline">\(A_0,A_1\)</span>。</p>
<p>每次分治，设重心 <span class="math inline">\(u\)</span>，将每一条以 <span class="math inline">\(u\)</span> 开头的链 <span class="math inline">\(str(u,v)\)</span> 在 <span class="math inline">\(A_0,A_1\)</span> 分别标记。</p>
<p>然后在 <span class="math inline">\(A_0,A_1\)</span> 的 parent 树上下放所有标记，那么自动机上每一个点就记录了该点代表的子串包含的所有链作为后缀的个数。</p>
<p>统计答案就是在 <span class="math inline">\(S\)</span> 串上枚举拼接点 <span class="math inline">\(i\)</span>，以 <span class="math inline">\(i\)</span> 结尾的后缀和 <span class="math inline">\(i\)</span> 开头的前缀都可以计入答案。</p>
<p>点分治一定要考虑容斥，实现的过程中，发现既要往一个子串后面插入（走 <span class="math inline">\(trans\)</span>），又要往前面插入（走后缀树 <span class="math inline">\(ch\)</span>），所以需要用 SAM 建出后缀树。</p>
<p>这样每次复杂度 <span class="math inline">\(\mathcal O(size+m)\)</span>，<span class="math inline">\(size\)</span> 是每次分治连通块大小。</p>
<p>总复杂度 <span class="math inline">\(\mathcal O(n\log n+nm)\)</span>，不行啊。</p>
<h3 id="根号分治">根号分治</h3>
<p>发现瓶颈在于，对于很小的连通块，我们都需要 <span class="math inline">\(\mathcal O(m)\)</span> 遍历整个 SAM。</p>
<p>想起暴力做法复杂度与 <span class="math inline">\(m\)</span> 无关，那么根号分治一下，小于 <span class="math inline">\(\sqrt{n}\)</span> 的部分就暴力统计。</p>
<p>最后总复杂度好像是 <span class="math inline">\(\mathcal O((n+m)\sqrt{n})\)</span>。</p>
<h2 id="代码">代码</h2>
<p>细节很多啊，调了三天。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, root, all, block;</span><br><span class="line">LL ans;</span><br><span class="line"><span class="keyword">int</span> val[N], size[N], maxs[N], fat[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">int</span> head[N], nxt[N], to[N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        ++cnt, nxt[cnt] = head[u], to[cnt] = v, head[u] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; G;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SuffixAutomaton</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    <span class="comment">// trans:自动机, ch:后缀树</span></span><br><span class="line">    <span class="keyword">int</span> trans[N][<span class="number">26</span>], ch[N][<span class="number">26</span>], link[N], len[N], size[N], id[N], pos[N], tag[N], str[N];</span><br><span class="line">    Graph T;</span><br><span class="line"></span><br><span class="line">    SuffixAutomaton(): tot(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> last, <span class="keyword">int</span> ps)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = last, np = ++tot;</span><br><span class="line">        len[np] = len[p] + <span class="number">1</span>, ++size[np], pos[np] = ps;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; !trans[p][c]) trans[p][c] = np, p = link[p];</span><br><span class="line">        <span class="keyword">if</span> (!p) link[np] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span>	q = trans[p][c];</span><br><span class="line">            <span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>) link[np] = q;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> nq = ++tot;</span><br><span class="line">                len[nq] = len[p] + <span class="number">1</span>, link[nq] = link[q], pos[nq] = pos[q];</span><br><span class="line">                <span class="built_in">memcpy</span>(trans[nq], trans[q], <span class="keyword">sizeof</span> trans[q]);</span><br><span class="line">                link[q] = link[np] = nq;</span><br><span class="line">                <span class="keyword">while</span> (p &amp;&amp; trans[p][c] == q) trans[p][c] = nq, p = link[p];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> np;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = T.head[u]; i; i = T.nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = T.to[i];</span><br><span class="line">            dfs(v);</span><br><span class="line">            size[u] += size[v];</span><br><span class="line">            ch[u][str[pos[v] - len[u]]] = v;</span><br><span class="line">            pos[u] = max(pos[u], pos[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, last = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            id[i] = last = insert(str[i], last, i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= tot; ++i) T.add(link[i], i);</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">nxt</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= len[p]) <span class="keyword">return</span> str[pos[p] - l + <span class="number">1</span>] == c ? p : <span class="number">0</span>; <span class="comment">// bug</span></span><br><span class="line">        <span class="keyword">return</span> ch[p][c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> p, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p) <span class="keyword">return</span>;</span><br><span class="line">        ++tag[p];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = G.head[u]; i; i = G.nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G.to[i];</span><br><span class="line">            <span class="keyword">if</span> (vis[v] || v == fa) <span class="keyword">continue</span>;</span><br><span class="line">            mark(v, u, nxt(p, l + <span class="number">1</span>, val[v]), l + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = ch[u][i];</span><br><span class="line">            <span class="keyword">if</span> (!v) <span class="keyword">continue</span>;</span><br><span class="line">            tag[v] += tag[u];</span><br><span class="line">            push_down(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) tag[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; A0, A1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    size[u] = <span class="number">1</span>, maxs[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = G.head[u]; i; i = G.nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = G.to[i];</span><br><span class="line">        <span class="keyword">if</span> (vis[v] || v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        find_root(v, u);</span><br><span class="line">        size[u] += size[v];</span><br><span class="line">        maxs[u] = max(maxs[u], size[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    maxs[u] = max(maxs[u], all - size[u]);</span><br><span class="line">    <span class="keyword">if</span> (!root || maxs[u] &lt; maxs[root]) root = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">force_dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    vec.push_back(u);</span><br><span class="line">    fat[u] = fa;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = G.head[u]; i; i = G.nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = G.to[i];</span><br><span class="line">        <span class="keyword">if</span> (vis[v] || v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        force_dfs1(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">force_dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> p, <span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span>;</span><br><span class="line">    ans += (LL)A0.size[p] * op;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = G.head[u]; i; i = G.nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = G.to[i];</span><br><span class="line">        <span class="keyword">if</span> (vis[v] || v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        force_dfs2(v, u, A0.trans[p][val[v]], op);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">force_add</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    vec.clear();</span><br><span class="line">    force_dfs1(u, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)vec.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = vec[i];</span><br><span class="line">        force_dfs2(x, <span class="number">0</span>, A0.trans[<span class="number">1</span>][val[x]], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">force_del</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    vec.clear();</span><br><span class="line">    force_dfs1(u, fa);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)vec.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = vec[i], p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != fa) p = A0.trans[p][val[x]], x = fat[x];</span><br><span class="line">        p = A0.trans[p][val[fa]];</span><br><span class="line">        force_dfs2(u, <span class="number">0</span>, A0.trans[p][val[u]], <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">        A0.mark(u, <span class="number">0</span>, A0.trans[<span class="number">1</span>][val[u]], <span class="number">1</span>);</span><br><span class="line">        A1.mark(u, <span class="number">0</span>, A1.trans[<span class="number">1</span>][val[u]], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        A0.mark(u, fa, A0.nxt(A0.trans[<span class="number">1</span>][val[fa]], <span class="number">2</span>, val[u]), <span class="number">2</span>);</span><br><span class="line">        A1.mark(u, fa, A1.nxt(A1.trans[<span class="number">1</span>][val[fa]], <span class="number">2</span>, val[u]), <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    A0.push_down(<span class="number">1</span>), A1.push_down(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        ans += (LL)op * A0.tag[A0.id[i]] * A1.tag[A1.id[m - i + <span class="number">1</span>]]; <span class="comment">// bug</span></span><br><span class="line">    A0.clear(), A1.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (all &lt;= block) <span class="keyword">return</span> force_add(u);</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    calc(u, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> now = all;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = G.head[u]; i; i = G.nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = G.to[i];</span><br><span class="line">        <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        all = size[v] &gt; size[u] ? (now - size[u]) : size[v];</span><br><span class="line">        <span class="keyword">if</span> (all &lt;= block) force_del(v, u);</span><br><span class="line">        <span class="keyword">else</span> calc(v, u, <span class="number">-1</span>);</span><br><span class="line">        root = <span class="number">0</span>, find_root(v, u);</span><br><span class="line">        solve(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    block = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        G.add(u, v), G.add(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; (str + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) val[i] = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; (str + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        A0.str[i] = A1.str[m - i + <span class="number">1</span>] = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    A0.init(), A1.init();</span><br><span class="line"></span><br><span class="line">    all = n, root = <span class="number">0</span>;</span><br><span class="line">    find_root(<span class="number">1</span>, <span class="number">0</span>), solve(root);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>字符串</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>点分治</tag>
        <tag>SAM</tag>
        <tag>根号分治</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P5492 [PKUWC2018]随机算法</title>
    <url>/2020/07/24/%E9%A2%98%E8%A7%A3-P5492-PKUWC2018%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P5492">题目</a></p>
<p>数据范围 <span class="math inline">\(n\le20\)</span>，集合/图上问题，考虑状压 DP</p>
<a id="more"></a>
<h2 id="思路">思路</h2>
<p>对于集合的最大独立集 <span class="math inline">\(S\)</span> 的各个点，有 <span class="math inline">\(|S|!\)</span> 种放进独立集的顺序</p>
<blockquote>
<p><strong>生成点集</strong>：<span class="math inline">\(S\)</span> 一个最大的点集 <span class="math inline">\(T\)</span>，满足 <span class="math inline">\(S\subseteq T\)</span> 且不存在 <span class="math inline">\(T\)</span> 的一个独立子集 <span class="math inline">\(U\)</span> 满足<span class="math inline">\(S\subsetneq U\)</span></p>
<p>我的理解：最大独立集为 <span class="math inline">\(S\)</span> 的最大的集合 <span class="math inline">\(T\)</span>，是 <span class="math inline">\(S\)</span> 的生成点集</p>
</blockquote>
<p>对于每一个最大独立集的顺序 <span class="math inline">\(u_1, u_2,...u_{|S|}\)</span></p>
<p><span class="math inline">\(u_1\)</span> 必须第一个加入独立集，接下来所有 <span class="math inline">\(u_1\)</span> 的邻点 <span class="math inline">\(to_{u_1}\)</span> 安排的位置就随便了</p>
<p><span class="math inline">\(\{u_1\}\)</span> 的生成点集 <span class="math inline">\(gs(\{ u_1\} )\)</span>（即 <span class="math inline">\(u_1\)</span> 及其邻点）便处理完了</p>
<p>在剩余的点中，<span class="math inline">\(u_2\)</span> 也必须第一个加入独立集</p>
<p>以此类推</p>
<p>形成独立集顺序为 <span class="math inline">\(u_1, u_2,...u_{|S|}\)</span> 的概率为： <span class="math display">\[
\prod_i^{|S|} \frac{1}{n-|gs(S_{i-1})|}
\]</span> 接下来可以 DP 了</p>
<p>设 <span class="math inline">\(f_S\)</span> 表示集合 <span class="math inline">\(S\)</span> 用该算法形成最大独立集的概率 <span class="math display">\[
\large f_S=\sum_{i\in S}\frac{f_{S-\{ i\} }}{n-|gs(S-\{ i\} )|}
\]</span> 初值 <span class="math inline">\(f_{\varnothing}=1\)</span></p>
<h2 id="code">code</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = (<span class="number">1</span> &lt;&lt; <span class="number">20</span>) + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, maxn, maxis, ans;</span><br><span class="line"><span class="keyword">int</span> to[N], <span class="built_in">map</span>[M], size[M], gs[M], f[M], inv[N];</span><br><span class="line"><span class="comment">// to邻点，map见下，size集合大小，gs生成点集</span></span><br><span class="line"><span class="keyword">bool</span> is[M];<span class="comment">// 是否是独立集</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(m);</span><br><span class="line">    maxn = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; ++i)</span><br><span class="line">        read(u), read(v), to[u] |= <span class="number">1</span>&lt;&lt;(v<span class="number">-1</span>), to[v] |= <span class="number">1</span>&lt;&lt;(u<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">map</span>[<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>)] = i;</span><br><span class="line">    is[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; maxn; ++s) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = s &amp; -s, t = s ^ x;</span><br><span class="line">        x = <span class="built_in">map</span>[x], gs[s] = size[s] = size[t] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (is[t] &amp;&amp; !(t &amp; to[x]))</span><br><span class="line">            is[s] = <span class="literal">true</span>, maxis = max(maxis, size[s]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (s &amp; to[i])</span><br><span class="line">                gs[s]++;</span><br><span class="line">    &#125;</span><br><span class="line">    inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        inv[i] = <span class="number">1l</span>l * (MOD - MOD / i) * inv[MOD%i] % MOD;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; maxn; ++s)</span><br><span class="line">        <span class="keyword">if</span> (is[s]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, t; i &lt; maxn; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> (s &amp; i) &#123;</span><br><span class="line">                    t = s ^ i;</span><br><span class="line">                    f[s] = (<span class="number">1l</span>l * f[t] * inv[n - gs[t]] % MOD + f[s]) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span> (size[s] == maxis)</span><br><span class="line">                ans = (ans + f[s]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>状压DP</tag>
        <tag>最大独立集</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P6564 「POI2007」堆积木KLO</title>
    <url>/2020/11/03/%E9%A2%98%E8%A7%A3-P6564-%E3%80%8CPOI2007%E3%80%8D%E5%A0%86%E7%A7%AF%E6%9C%A8KLO/</url>
    <content><![CDATA[<blockquote>
<p>给出长为 n 的序列 a，求一个 a 的子序列 b，最大化 <span class="math inline">\(\sum_{i}^{k}[b_i=i]\)</span>。</p>
</blockquote>
<a id="more"></a>
<h2 id="思路">思路</h2>
<p>DP 时，如果点 <span class="math inline">\(i\)</span> 能从点 <span class="math inline">\(j\)</span> 转移过来，满足条件： <span class="math display">\[
\begin{align}
i&amp;&gt;j\\
a_i&amp;&gt; a_j\\
a_i-a_j&amp;\le i-j
\end{align}
\]</span> 满足后两个条件时一定满足第一个条件。</p>
<p>转化为 <span class="math inline">\(a_i&gt;a_j,i-a_i\ge j-a_j\)</span>，二维偏序直接上 CDQ。</p>
<p>懒得归并，复杂度 <span class="math inline">\(O(n\log^2n)\)</span>。</p>
<p>因为一个 <span class="math inline">\(&gt;\)</span> 一个 <span class="math inline">\(\ge\)</span>，所以 <span class="math inline">\(i-a_i\)</span> 属性要作第一维。</p>
<h2 id="代码">代码</h2>
<p>记得加个 0 点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">Data a[N];</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpx</span><span class="params">(<span class="keyword">const</span> Data &amp;x, <span class="keyword">const</span> Data &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x.x == y.x) <span class="keyword">return</span> x.y &lt; y.y;</span><br><span class="line">    <span class="keyword">return</span> x.x &lt; y.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpy</span><span class="params">(<span class="keyword">const</span> Data &amp;x, <span class="keyword">const</span> Data &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x.y == y.y) <span class="keyword">return</span> x.x &lt; y.x;</span><br><span class="line">    <span class="keyword">return</span> x.y &lt; y.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">CDQ</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    sort(a+l, a+mid+<span class="number">1</span>, cmpy);</span><br><span class="line">    CDQ(l, mid);</span><br><span class="line">    sort(a+l, a+mid+<span class="number">1</span>, cmpx), sort(a+mid+<span class="number">1</span>, a+r+<span class="number">1</span>, cmpx);</span><br><span class="line">    <span class="keyword">int</span> pl = l, pr = mid + <span class="number">1</span>, ma = -INF;</span><br><span class="line">    <span class="keyword">while</span> (pr &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">while</span> (pl &lt;= mid &amp;&amp; a[pl].x &lt; a[pr].x)</span><br><span class="line">            ma = max(ma, f[a[pl].id]), pl++;</span><br><span class="line">        <span class="comment">// 当 i - a[i] &lt; 0 时，该点一定不满足</span></span><br><span class="line">        <span class="keyword">if</span> (a[pr].y &gt;= <span class="number">0</span>) f[a[pr].id] = max(f[a[pr].id], ma + <span class="number">1</span>);</span><br><span class="line">        pr++;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+mid+<span class="number">1</span>, a+r+<span class="number">1</span>, cmpy);</span><br><span class="line">    CDQ(mid+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        read(a[i].x), a[i].y = i - a[i].x, a[i].id = i;</span><br><span class="line">    a[++n] = (Data)&#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    sort(a+<span class="number">1</span>, a+n+<span class="number">1</span>, cmpy);</span><br><span class="line">    CDQ(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        ans = max(ans, f[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
  </entry>
  <entry>
    <title>题解 P7078 贪吃蛇</title>
    <url>/2020/11/17/%E9%A2%98%E8%A7%A3-P7078-%E8%B4%AA%E5%90%83%E8%9B%87/</url>
    <content><![CDATA[<blockquote>
<p>给出 n 条蛇，最大的蛇可以选择吃或不吃最小蛇，若某一轮中只剩一条蛇或者最大蛇不吃时停止，每条蛇都想活着并吃最多的蛇，求最后剩下的条数。</p>
<p><span class="math inline">\(n\le 10^6,T\le 10\)</span>。</p>
</blockquote>
<p>博弈论+单调性优化。</p>
<a id="more"></a>
<p>CSP2020 T4，考场上压根没看。</p>
<h2 id="思路">思路</h2>
<p>这题有 20 分白给，即 3 条蛇的情况，如果最大蛇吃完之后不是最小蛇肯定要吃。（博主这个煞笔 20 分都没有。）</p>
<p>推广到 n 条蛇，也是同样的道理，这样吃一直下去，直到最大蛇吃完后会变为最小蛇：</p>
<p>这种情况下，最大蛇吃了是有风险的，变成最小蛇时能不能活着要看下一条最大蛇，这种有风险的情况可能会递归下去。</p>
<p>于是现在有三种情况：</p>
<ul>
<li>Case 1：最大蛇吃完之后不是最小蛇；</li>
<li>Case 2：最大蛇吃完之后是最小蛇；</li>
<li>Case 3：只剩 2 条蛇。</li>
</ul>
<p>模拟整个过程：</p>
<p>第一个阶段是 Case 1，最大蛇会放心的吃；</p>
<p>第二个阶段是 Case 2，最大蛇吃后<strong>有风险</strong>，那么就先假定她吃，<strong>递归</strong>下去，会有两个边界：遇到 Case 1 或者 Case 3，这两种情况中最大蛇都肯定会吃，那么上一轮的最大蛇（此时为最小蛇）也就挂了，上一轮的最大蛇也就不会选择吃。</p>
<p>再往回退一层，上上轮的最大蛇知道会在下一轮停止，那么她也就会放心去吃。</p>
<p>可以发现 Case 2 吃不吃取决于递归层数的<strong>奇偶性</strong>。</p>
<p>如果没有经过 Case 2 就到了第三个阶段，最后就会只剩 1 条。</p>
<h2 id="分实现">70 分实现</h2>
<p>我们可以直接模拟，用 set 维护蛇，注意记录进入第二个阶段时的条数，这样 <span class="math inline">\(\mathcal O(Tn\log n)\)</span> 可以拿到 70 分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Snake</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val, id;</span><br><span class="line">    Snake() &#123;&#125;</span><br><span class="line">    Snake(<span class="keyword">int</span> _val, <span class="keyword">int</span> _id) : val(_val), id(_id) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Snake &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> val == t.val ? id &gt; t.id : val &gt; t.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, k;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="built_in">set</span>&lt;Snake&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt;= T; ++c) &#123;</span><br><span class="line">        s.clear();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">1</span>) &#123;</span><br><span class="line">            read(n);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; ++i)</span><br><span class="line">                read(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            read(k);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= k; ++i)</span><br><span class="line">                read(x), read(y), a[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            s.insert(Snake(a[i], i));</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.size() == <span class="number">2</span>) &#123;</span><br><span class="line">                s.erase(--s.end());</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((flag - s.size()) % <span class="number">2</span>) ans = flag + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> ans = flag;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> ans = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">set</span>&lt;Snake&gt;::iterator ma = s.begin(), mi = --s.end();</span><br><span class="line">            <span class="keyword">int</span> val = ma -&gt; val - mi -&gt; val, id = ma -&gt; id;</span><br><span class="line">            s.erase(ma), s.erase(mi);</span><br><span class="line">            s.insert(Snake(val, id));</span><br><span class="line">            <span class="keyword">if</span> ((--s.end()) -&gt; id == id) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!flag) flag = s.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((flag - s.size()) % <span class="number">2</span>) ans = flag + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> ans = flag;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优化">优化</h2>
<p>怎么搞到 <span class="math inline">\(\mathcal O(n)\)</span> 啊，还能吃出个单调性？</p>
<p>联系到往届 NOIP 真题 <a href="https://www.luogu.com.cn/problem/P2827">蚯蚓</a>，并观察发现，新加入的蛇是单调不升的。</p>
<p>因为后一轮的最大蛇比前一轮最大蛇小，后一轮最小蛇比前一轮最小蛇大。</p>
<p>那么 set 就不必了，开两个双端队列即可，一个维护原来的蛇，一个维护新加入的蛇。</p>
<h2 id="分实现-1">100 分实现</h2>
<p>复杂度 <span class="math inline">\(\mathcal O(Tn)\)</span>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Snake</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val, id;</span><br><span class="line">    Snake() &#123;&#125;</span><br><span class="line">    Snake(<span class="keyword">int</span> _val, <span class="keyword">int</span> _id) : val(_val), id(_id) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Snake &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> val == t.val ? id &lt; t.id : val &lt; t.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, k;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="built_in">deque</span>&lt;Snake&gt; q1, q2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Snake <span class="title">get_max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Snake res;</span><br><span class="line">    <span class="keyword">if</span> (q1.empty()) res = q2.back(), q2.pop_back();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (q2.empty()) res = q1.back(), q1.pop_back();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (q1.back() &lt; q2.back()) res = q2.back(), q2.pop_back();</span><br><span class="line">        <span class="keyword">else</span> res = q1.back(), q1.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Snake <span class="title">get_min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Snake res;</span><br><span class="line">    <span class="keyword">if</span> (q1.empty()) res = q2.front(), q2.pop_front();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (q2.empty()) res = q1.front(), q1.pop_front();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (q1.front() &lt; q2.front()) res = q1.front(), q1.pop_front();</span><br><span class="line">        <span class="keyword">else</span> res = q2.front(), q2.pop_front();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt;= T; ++c) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">1</span>) &#123;</span><br><span class="line">            read(n);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; ++i)</span><br><span class="line">                read(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            read(k);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= k; ++i)</span><br><span class="line">                read(x), read(y), a[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">        q1.clear(), q2.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            q1.push_back(Snake(a[i], i));</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q1.size() + q2.size() == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((flag - <span class="number">1</span>) % <span class="number">2</span>) ans = flag + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> ans = flag;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> ans = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Snake ma = get_max(), mi = get_min(), u(ma.val - mi.val, ma.id);</span><br><span class="line">            <span class="keyword">if</span> ((q1.empty() || u &lt; q1.front()) &amp;&amp; (q2.empty() || u &lt; q2.front())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!flag) flag = q1.size() + q2.size() + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((flag - (q1.size() + q2.size() + <span class="number">1</span>)) % <span class="number">2</span>) ans = flag + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> ans = flag;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            q2.push_front(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>单调性优化</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>20年11月 刷题记录</title>
    <url>/2020/11/14/20%E5%B9%B411%E6%9C%88%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>做题好慢啊。</p>
<a id="more"></a>
<h1 id="日">2日</h1>
<h2 id="p3354-ioi2005riv-河流">P3354 [IOI2005]Riv 河流</h2>
<p><a href="https://www.luogu.com.cn/problem/P3354">题目</a></p>
<p>树形背包 DP。</p>
<p>设 <span class="math inline">\(f_{u,f,k},g_{u,f,k}\)</span> 表示 u 为根的子树以 f 为关键点、强制 / 不强制 u 为关键点、使用了 k 个关键点的最小花费。</p>
<p><span class="math display">\[\begin{aligned} f_{u,f,k}&amp;\leftarrow f_{v,f,l}+f{u,f,k-l}\\g_{u,f,k}&amp;\leftarrow f_{v,u,l}+g_{u,f,k-l} \end{aligned}\]</span></p>
<p>复杂度 <span class="math inline">\(\mathcal O(n^4)\)</span>。</p>
<h1 id="日-1">3日</h1>
<h2 id="acwing277-饼干">AcWing277 饼干</h2>
<p><a href="https://www.acwing.com/problem/content/description/279">题目</a></p>
<p>简单 DP。</p>
<p>先贪心地让怨气值大的在前，则分配饼干个数单调不增，设 <span class="math inline">\(f_{i,j}\)</span> 表示前 i 个人分 j 个饼干最优答案。</p>
<p>简化状态，强制让最后一个人只得到 1 个，其他状态 <span class="math inline">\(f_{i,j}\Leftarrow f_{i,j-i}\)</span>。</p>
<p>接下来只要考虑最后有多少个人同样分到 1 个就行。</p>
<p>复杂度 <span class="math inline">\(\mathcal O(n^2m)\)</span>。</p>
<h2 id="p6564-poi2007-堆积木klo">P6564 [POI2007] 堆积木KLO</h2>
<p><a href="https://www.luogu.com.cn/problem/P6564">题目</a></p>
<p>CDQ，BIT，LIS 等均可。</p>
<p><span class="math display">\[\begin{aligned} i&amp;&gt;j,\\ a_i&amp;&gt; a_j,\\ a_i-a_j&amp;\le i-j \end{aligned}\]</span></p>
<p>满足后两个条件时一定满足第一个条件，转化为二维偏序直接上 CDQ。</p>
<p>因为一个 <span class="math inline">\(&gt;\)</span> 一个 <span class="math inline">\(\ge\)</span>，所以 <span class="math inline">\(i-a_i\)</span> 属性要作第一维。</p>
<h2 id="p2175-小z的游戏分队">P2175 小Z的游戏分队</h2>
<p><a href="https://www.luogu.com.cn/problem/P2175">题目</a></p>
<p>每个人向不信任的人连边，形成若干个二分图。</p>
<p>以每个二分图两边人数差为权值，背包 DP 某个答案是否能出现。</p>
<h1 id="日-2">4日</h1>
<h2 id="p1800-software">P1800 software</h2>
<p><a href="https://www.luogu.com.cn/problem/P1800">题目</a></p>
<p>二分 + 背包 DP。</p>
<p>明显答案是单调的，考虑怎么判定合法。</p>
<p>在时间限制内，每个人固定了任务一的量，就能确定任务二的量，于是将一个人拆成 m 个物品。</p>
<p>背包 DP 出 n 个人完成任务一时最多能够完成的任务二的量即可。</p>
<h2 id="u139384-异或和">U139384 异或和</h2>
<p><a href="https://www.luogu.com.cn/problem/U139384">题目</a></p>
<p>FWT。</p>
<p>设 <span class="math inline">\(f^i(x)\)</span> 表示选 <span class="math inline">\(i\)</span> 个数，异或和能否为 <span class="math inline">\(x\)</span>，容易得到 <span class="math inline">\(f^1(x)\)</span>，通过 FWT 自卷即可转移。</p>
<p>将选取最多的，转化为删去最少的使得异或和为零（前者）。</p>
<p>设所有数异或和为 <span class="math inline">\(s\)</span>，异或和能够为 <span class="math inline">\(s\)</span> 的个数只有 <span class="math inline">\(\log_2n\)</span> 级别（线性基）。</p>
<p>那么只要处理前 <span class="math inline">\(\log_2n\)</span> 的 <span class="math inline">\(f^i(x)\)</span> 即可，每次暴力 FWT 和 iFWT 可以做到 <span class="math inline">\(\mathcal O(n\log^2n)\)</span>。</p>
<p>丧心病狂的出题人 <a href="https://www.luogu.com.cn/user/96912">AzusaCat</a> 竟然卡掉两个 log 的做法！！！</p>
<p>考虑优化 iFWT，因为每次只需要 <span class="math inline">\(f^i(s)\)</span> 的值，单点的话从 FWT 的原理逆推：</p>
<p><span class="math display">\[\begin{aligned} \hat{F}*S&amp;=\sum*{T\subseteq U}(-1)^{|S\cap T|}F_T \\ F_S&amp;=\frac{1}{2^n}\sum_{T\subseteq U}(-1)^{|S\cap T|}\hat F_T \end{aligned}\]</span></p>
<p>每次只要 <span class="math inline">\(\mathcal O(n)\)</span> 即可得到单点的值，总复杂度降至 <span class="math inline">\(\mathcal O(n\log n)\)</span>。</p>
<h2 id="p3047-usaco12febnearby-cows-g">P3047 [USACO12FEB]Nearby Cows G</h2>
<p><a href="https://www.luogu.com.cn/problem/P3047">题目</a></p>
<p>换根 DP。</p>
<p>先处理出 <span class="math inline">\(f_{u,i}\)</span> 表示以 u 为根的子树深度为 i 的点权和，<span class="math inline">\(\mathcal O(k)\)</span> 转移。此时 1 的 DP 值为答案。</p>
<p>换根，每次将 u 的一个子树 v 贡献减去，分成两个独立的树，再由 u 转移到 v 即可。</p>
<blockquote>
<p>换根 DP 的特点是能够快速地将子树分离、改变父子关系后合并</p>
</blockquote>
<h1 id="日-3">5日</h1>
<h2 id="p4161-scoi2009游戏">P4161 [SCOI2009]游戏</h2>
<p><a href="https://www.luogu.com.cn/problem/P4161">题目</a></p>
<p>数论，背包 DP。</p>
<p>容易发现一个排列可以看成几个环，而变换回来的步数是这些环的 <span class="math inline">\(\operatorname{lcm}\)</span>。</p>
<p>问题转化成：n 拆成若干个数的和，这些数的 <span class="math inline">\(\operatorname{lcm}\)</span> 的种数。</p>
<p>将 <span class="math inline">\(\operatorname{lcm}\)</span> 唯一分解，每个质因子的指数为所有数该质因子的最大指数。</p>
<p>那么 DP 每个质数不同质数的情况下的方案数，转化成完全背包。</p>
<p>设 <span class="math inline">\(f_{i,j}\)</span> 表示到第 i 个质数，将 j 拆开的 <span class="math inline">\(\operatorname{lcm}\)</span> 种数，则 <span class="math inline">\(f_{i,j}\leftarrow f_{i-1,j}+f_{i-1,j-p_i^k}\)</span>。</p>
<p>因为无法处理 1，而 1 不影响 <span class="math inline">\(\operatorname{lcm}\)</span>，所以拆开的数的和不一定为 n，剩下的用 1 填满，最后答案为 <span class="math inline">\(\sum_{i=0}^n f_{cnt_p,i}\)</span>。</p>
<h2 id="p6280-usaco20openexercise-g">P6280 [USACO20OPEN]Exercise G</h2>
<p><a href="https://www.luogu.com.cn/problem/P6280">题目</a></p>
<p>和上题一样，只不过是求 <span class="math inline">\(\operatorname{lcm}\)</span> 的和。</p>
<p>每次 DP 时是一个新的素数，所以直接乘以上一个状态，<span class="math inline">\(f_{i,j}\leftarrow f_{i-1,j}+f_{i-1,j-p_i^k}\times p_i^k\)</span>。</p>
<h2 id="p4342-ioi1998polygon">P4342 [IOI1998]Polygon</h2>
<p><a href="https://www.luogu.com.cn/problem/P4342">题目</a></p>
<p>区间 DP。</p>
<p>题目唬人，但是容易看出来每次断成链后是个区间 DP，枚举断点后直接做，<span class="math inline">\(\mathcal O(n^4)\)</span> 可过。</p>
<p>然后就 80 分 qwq。因为有乘法，而每个数可能为负，负负得正。</p>
<p>于是同时维护最大值和最小值。</p>
<h2 id="p4158-scoi2009粉刷匠">P4158 [SCOI2009]粉刷匠</h2>
<p><a href="https://www.luogu.com.cn/problem/P4158">题目</a></p>
<p>简单 DP + 背包 DP。</p>
<p>问题在于如何分配粉刷次数，先对于每一行单独处理，将不同粉刷次数的答案化为物品。</p>
<p>设 <span class="math inline">\(f_{i,k}\)</span> 表示前 <span class="math inline">\(i\)</span> 位粉刷 <span class="math inline">\(k\)</span> 次最多正确个数，<span class="math inline">\(f_{i,k}\leftarrow f_{j,k-1}+\max\{s_0(j+1,i),s_1(j+1,i)\}\)</span>。</p>
<p>然后对于 <span class="math inline">\(n\times m\)</span> 个物品进行背包即可。</p>
<h2 id="p1092-虫食算">P1092 虫食算</h2>
<p><a href="https://www.luogu.com.cn/problem/P1092">题目</a></p>
<p>搜索。</p>
<p>正解好像是高斯消元，不会。</p>
<p>从低位到高位开始搜，当三位中有两个确定时就可以推出第三个。</p>
<p>还有一个剪枝，每确定一列，就扫一遍后面没搜的列，看在进不进位的情况下是否都矛盾。</p>
<h2 id="p3951-小凯的疑惑">P3951 小凯的疑惑</h2>
<p><a href="https://www.luogu.com.cn/problem/P3951">题目</a></p>
<p>数论。</p>
<p>打表，发现 <span class="math inline">\(a&lt;b\)</span> 时答案是 <span class="math inline">\((a-1)\times b - a\)</span>。</p>
<p>证明：设无法表示出来的为 x。</p>
<p><span class="math display">\[\begin{aligned} x&amp;\equiv ma\pmod b \quad&amp;(1&lt;m&lt;b)\\ x&amp;=ma+nb\quad&amp;(1&lt;m&lt;b,n&lt;0) \end{aligned}\]</span></p>
<p>当 x 最大时，<span class="math inline">\(m=b-1,n=-1\)</span>，证毕。</p>
<h2 id="p5092-usaco04opencube-stacking">P5092 [USACO04OPEN]Cube Stacking</h2>
<p><a href="https://www.luogu.com.cn/record/41327125">题目</a></p>
<p>并查集。</p>
<p>在 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(fa\)</span> 的边之间维护压缩的边数，路径压缩优化，再维护每个并查集的 size。</p>
<h2 id="p2894-usaco08febhotel-g">P2894 [USACO08FEB]Hotel G</h2>
<p><a href="https://www.luogu.com.cn/problem/P2894">题目</a></p>
<p>线段树。</p>
<p>维护每个区间的最长连续区间和左端开头、右端开头的最长连续区间。</p>
<p>二分最早的 r 使得 <span class="math inline">\([1,r]\)</span> 的最长连续区间长度大于 x，<span class="math inline">\(\mathcal O(n\log^2n)\)</span>。</p>
<p>query 时直接左区间优先即可，<span class="math inline">\(\mathcal O(n\log n)\)</span>。</p>
<h1 id="日-4">11日</h1>
<h2 id="p7076-动物园">P7076 动物园</h2>
<p><a href="https://www.luogu.com.cn/problem/P7076">题目</a></p>
<p>贪心（？），CSP2020 T2。</p>
<p>将所有动物或起来，对于每一位，没有饲料或者有饲料并且已经购买，该位可以选或不选；有饲料且未购买，只能不选。</p>
<p>把每一位的答案乘一下，坑点是开了 unsigned long long 也见祖宗，需要特判 <span class="math inline">\(2^{64}\)</span> 的情况。</p>
<h1 id="日-5">12日</h1>
<h2 id="p7077-函数调用">P7077 函数调用</h2>
<p><a href="https://www.luogu.com.cn/problem/P7077">题目</a></p>
<p>拓扑 DP，CSP2020 T3。</p>
<p>考场上写的线段树暴力，<del>好歹也是个不小的数据结构啊怎么才给 30 分！</del>其实是不错的题。</p>
<p>可以发现单点加值，整体乘值，所有操作形成若干个 DAG，只要求最终序列，于是方向转向图论。</p>
<p>设所有乘法之积为 <span class="math inline">\(mul\)</span>，每个点初始值的贡献一定是 <span class="math inline">\(a_i\times mul\)</span>。</p>
<p>接下来考虑单点加和其之后的变化。每个单点加的贡献是后面所有乘法之积。</p>
<p>那么先预处理每个点的及后面乘法的积 <span class="math inline">\(m_i\)</span>，然后按照操作序列倒着 DP 每个DAG 的贡献次数。</p>
<p>再在 DAG 里倒着 DP，<span class="math inline">\(f_v\leftarrow f_v + f_u, f_u\leftarrow f_u\times m_v\)</span>，对于单点加的贡献就有 <span class="math inline">\(f_u\times val_u\)</span>。</p>
<h1 id="日-6">17日</h1>
<h2 id="p7078-贪吃蛇">P7078 贪吃蛇</h2>
<p><a href="https://www.luogu.com.cn/problem/P7078">题目</a></p>
<p>博弈论+单调性优化，CSP2020 T4。</p>
<p>见<a href="https://renamoe.github.io/2020/11/17/题解-P7078-贪吃蛇">博客题解</a>。</p>
<h1 id="日-7">20日</h1>
<h2 id="cf455d-serega-and-fun">CF455D Serega and Fun</h2>
<p><a href="https://www.luogu.com.cn/problem/CF455D">题目</a></p>
<p>平衡树或者分块。</p>
<p>对于第一个操作可以用一棵 splay 轻松维护，称其为序列树。</p>
<p>因为值域 <span class="math inline">\(\mathcal O(n)\)</span>，第二个操作考虑每个值维护一棵 splay，节点存其对应的序列树的编号。</p>
<p>每次询问一个区间要求在某一棵 splay 里寻找区间内最靠左和最靠右的点，可以通过在序列树上查 rank 来二分，单次 <span class="math inline">\(\mathcal O(\log^2n)\)</span>。</p>
<h2 id="s2oj41-新斯诺克">S2OJ#41 新斯诺克</h2>
<p><a href="http://sjzezoj.com:9280/problem/41">题目</a></p>
<p>归并排序就够了。</p>
<p>可以让所有数减去 m，然后做前缀和，满足 <span class="math inline">\(j&lt;i, s_j&lt;s_i\)</span> 的一对点构成一个合法区间。</p>
<p>二维偏序，可以做到 <span class="math inline">\(\mathcal O(n\log n)\)</span>。这个煞笔又写了个比别多个 <span class="math inline">\(\log\)</span> 的 CDQ 分治。</p>
<h1 id="日-8">21日</h1>
<h2 id="s2oj42-方舟连接">S2OJ#42 方舟连接</h2>
<p><a href="http://sjzezoj.com:9280/problem/59">题目</a></p>
<p>区间 DP + 四边形不等式优化。</p>
<p>把路径看成一棵树，然后发现这是两两相邻子树合并，转化成一个序列就是区间 DP。</p>
<p><span class="math inline">\(\mathcal O(n^3)\)</span> 过不去，简单证明一下 DP 为凸，套上经典的四边形不等式优化，降到 <span class="math inline">\(\mathcal O(n^2)\)</span>。</p>
<h2 id="s2oj60-a-simple-math-problem-vi">S2OJ#60 A Simple Math Problem VI</h2>
<p><a href="http://sjzezoj.com:9280/problem/60">题目</a></p>
<p>小数据裸完全背包。大数据特殊性质 <span class="math inline">\(a_i=1\)</span>，组合数问题 <a href="https://oi-wiki.org/math/combination/#1">见 OI wiki</a>。</p>
<h1 id="日-9">22日</h1>
<h2 id="p4093-heoi2016tjoi2016序列">P4093 [HEOI2016/TJOI2016]序列</h2>
<p><a href="https://www.luogu.com.cn/problem/P4093">题目</a></p>
<p>CDQ 分治。</p>
<p>设 <span class="math inline">\(mi_i=\min\{val_i,w_i\},ma_i=\max\{val_i,w_i\}\)</span>，求 LIS 的时候转移的条件为：</p>
<p><span class="math inline">\(\begin{aligned} j&amp;&lt;i\\ val_j&amp;\le mi_i\\ ma_j&amp;\le val_i \end{aligned}\)</span></p>
<p>CDQ 分治，左右分别按上边对应的属性排序；优先递归处理左区间。复杂度 <span class="math inline">\(\mathcal O(n\log^2 n)\)</span>。</p>
<h1 id="日-10">26日</h1>
<h2 id="cf571d-campus">CF571D Campus</h2>
<p><a href="https://www.luogu.com.cn/problem/CF571D">题目</a></p>
<p>转化成树上问题 + 树状数组上二分技巧。</p>
<p><a href="http://localhost:4000/2020/11/26/题解-CF571D-Campus/">见博客</a></p>
<h1 id="日-11">27日</h1>
<h2 id="gym102331b-bitwise-xor">GYM102331B Bitwise Xor</h2>
<p><a href="https://codeforces.com/gym/102331/problem/B">题目</a></p>
<p>简单 DP + 01-trie。</p>
<p><a href="https://renamoe.github.io/2020/11/27/题解-GYM102331B-Bitwise-Xor/">见博客</a></p>
<h1 id="日-12">2日</h1>
<h2 id="p3354-ioi2005riv-河流-1">P3354 [IOI2005]Riv 河流</h2>
<p><a href="https://www.luogu.com.cn/problem/P3354">题目</a></p>
<p>树形背包 DP。</p>
<p>设 <span class="math inline">\(f_{u,f,k},g_{u,f,k}\)</span> 表示 u 为根的子树以 f 为关键点、强制 / 不强制 u 为关键点、使用了 k 个关键点的最小花费。</p>
<p><span class="math display">\[\begin{aligned} f_{u,f,k}&amp;\leftarrow f_{v,f,l}+f{u,f,k-l}\\g_{u,f,k}&amp;\leftarrow f_{v,u,l}+g_{u,f,k-l} \end{aligned}\]</span></p>
<p>复杂度 <span class="math inline">\(\mathcal O(n^4)\)</span>。</p>
<h1 id="日-13">3日</h1>
<h2 id="acwing277-饼干-1">AcWing277 饼干</h2>
<p><a href="https://www.acwing.com/problem/content/description/279">题目</a></p>
<p>简单 DP。</p>
<p>先贪心地让怨气值大的在前，则分配饼干个数单调不增，设 <span class="math inline">\(f_{i,j}\)</span> 表示前 i 个人分 j 个饼干最优答案。</p>
<p>简化状态，强制让最后一个人只得到 1 个，其他状态 <span class="math inline">\(f_{i,j}\Leftarrow f_{i,j-i}\)</span>。</p>
<p>接下来只要考虑最后有多少个人同样分到 1 个就行。</p>
<p>复杂度 <span class="math inline">\(\mathcal O(n^2m)\)</span>。</p>
<h2 id="p6564-poi2007-堆积木klo-1">P6564 [POI2007] 堆积木KLO</h2>
<p><a href="https://www.luogu.com.cn/problem/P6564">题目</a></p>
<p>CDQ，BIT，LIS 等均可。</p>
<p><span class="math display">\[\begin{aligned} i&amp;&gt;j,\\ a_i&amp;&gt; a_j,\\ a_i-a_j&amp;\le i-j \end{aligned}\]</span></p>
<p>满足后两个条件时一定满足第一个条件，转化为二维偏序直接上 CDQ。</p>
<p>因为一个 <span class="math inline">\(&gt;\)</span> 一个 <span class="math inline">\(\ge\)</span>，所以 <span class="math inline">\(i-a_i\)</span> 属性要作第一维。</p>
<h2 id="p2175-小z的游戏分队-1">P2175 小Z的游戏分队</h2>
<p><a href="https://www.luogu.com.cn/problem/P2175">题目</a></p>
<p>每个人向不信任的人连边，形成若干个二分图。</p>
<p>以每个二分图两边人数差为权值，背包 DP 某个答案是否能出现。</p>
<h1 id="日-14">4日</h1>
<h2 id="p1800-software-1">P1800 software</h2>
<p><a href="https://www.luogu.com.cn/problem/P1800">题目</a></p>
<p>二分 + 背包 DP。</p>
<p>明显答案是单调的，考虑怎么判定合法。</p>
<p>在时间限制内，每个人固定了任务一的量，就能确定任务二的量，于是将一个人拆成 m 个物品。</p>
<p>背包 DP 出 n 个人完成任务一时最多能够完成的任务二的量即可。</p>
<h2 id="u139384-异或和-1">U139384 异或和</h2>
<p><a href="https://www.luogu.com.cn/problem/U139384">题目</a></p>
<p>FWT。</p>
<p>设 <span class="math inline">\(f^i(x)\)</span> 表示选 <span class="math inline">\(i\)</span> 个数，异或和能否为 <span class="math inline">\(x\)</span>，容易得到 <span class="math inline">\(f^1(x)\)</span>，通过 FWT 自卷即可转移。</p>
<p>将选取最多的，转化为删去最少的使得异或和为零（前者）。</p>
<p>设所有数异或和为 <span class="math inline">\(s\)</span>，异或和能够为 <span class="math inline">\(s\)</span> 的个数只有 <span class="math inline">\(\log_2n\)</span> 级别（线性基）。</p>
<p>那么只要处理前 <span class="math inline">\(\log_2n\)</span> 的 <span class="math inline">\(f^i(x)\)</span> 即可，每次暴力 FWT 和 iFWT 可以做到 <span class="math inline">\(\mathcal O(n\log^2n)\)</span>。</p>
<p>丧心病狂的出题人 <span class="math inline">\(\rm \color{black}{A}\color{red}{zusaCat}\)</span> 竟然卡掉两个 log 的做法！！！</p>
<p>考虑优化 iFWT，因为每次只需要 <span class="math inline">\(f^i(s)\)</span> 的值，单点的话从 FWT 的原理逆推：</p>
<p><span class="math display">\[\begin{aligned} \hat{F}*S&amp;=\sum*{T\subseteq U}(-1)^{|S\cap T|}F_T \\ F_S&amp;=\frac{1}{2^n}\sum_{T\subseteq U}(-1)^{|S\cap T|}\hat F_T \end{aligned}\]</span></p>
<p>每次只要 <span class="math inline">\(\mathcal O(n)\)</span> 即可得到单点的值，总复杂度降至 <span class="math inline">\(\mathcal O(n\log n)\)</span>。</p>
<h2 id="p3047-usaco12febnearby-cows-g-1">P3047 [USACO12FEB]Nearby Cows G</h2>
<p><a href="https://www.luogu.com.cn/problem/P3047">题目</a></p>
<p>换根 DP。</p>
<p>先处理出 <span class="math inline">\(f_{u,i}\)</span> 表示以 u 为根的子树深度为 i 的点权和，<span class="math inline">\(\mathcal O(k)\)</span> 转移。此时 1 的 DP 值为答案。</p>
<p>换根，每次将 u 的一个子树 v 贡献减去，分成两个独立的树，再由 u 转移到 v 即可。</p>
<blockquote>
<p>换根 DP 的特点是能够快速地将子树分离、改变父子关系后合并</p>
</blockquote>
<h1 id="日-15">5日</h1>
<h2 id="p4161-scoi2009游戏-1">P4161 [SCOI2009]游戏</h2>
<p><a href="https://www.luogu.com.cn/problem/P4161">题目</a></p>
<p>数论，背包 DP。</p>
<p>容易发现一个排列可以看成几个环，而变换回来的步数是这些环的 <span class="math inline">\(\operatorname{lcm}\)</span>。</p>
<p>问题转化成：n 拆成若干个数的和，这些数的 <span class="math inline">\(\operatorname{lcm}\)</span> 的种数。</p>
<p>将 <span class="math inline">\(\operatorname{lcm}\)</span> 唯一分解，每个质因子的指数为所有数该质因子的最大指数。</p>
<p>那么 DP 每个质数不同质数的情况下的方案数，转化成完全背包。</p>
<p>设 <span class="math inline">\(f_{i,j}\)</span> 表示到第 i 个质数，将 j 拆开的 <span class="math inline">\(\operatorname{lcm}\)</span> 种数，则 <span class="math inline">\(f_{i,j}\leftarrow f_{i-1,j}+f_{i-1,j-p_i^k}\)</span>。</p>
<p>因为无法处理 1，而 1 不影响 <span class="math inline">\(\operatorname{lcm}\)</span>，所以拆开的数的和不一定为 n，剩下的用 1 填满，最后答案为 <span class="math inline">\(\sum_{i=0}^n f_{cnt_p,i}\)</span>。</p>
<h2 id="p6280-usaco20openexercise-g-1">P6280 [USACO20OPEN]Exercise G</h2>
<p><a href="https://www.luogu.com.cn/problem/P6280">题目</a></p>
<p>和上题一样，只不过是求 <span class="math inline">\(\operatorname{lcm}\)</span> 的和。</p>
<p>每次 DP 时是一个新的素数，所以直接乘以上一个状态，<span class="math inline">\(f_{i,j}\leftarrow f_{i-1,j}+f_{i-1,j-p_i^k}\times p_i^k\)</span>。</p>
<h2 id="p4342-ioi1998polygon-1">P4342 [IOI1998]Polygon</h2>
<p><a href="https://www.luogu.com.cn/problem/P4342">题目</a></p>
<p>区间 DP。</p>
<p>题目唬人，但是容易看出来每次断成链后是个区间 DP，枚举断点后直接做，<span class="math inline">\(\mathcal O(n^4)\)</span> 可过。</p>
<p>然后就 80 分 qwq。因为有乘法，而每个数可能为负，负负得正。</p>
<p>于是同时维护最大值和最小值。</p>
<h2 id="p4158-scoi2009粉刷匠-1">P4158 [SCOI2009]粉刷匠</h2>
<p><a href="https://www.luogu.com.cn/problem/P4158">题目</a></p>
<p>简单 DP + 背包 DP。</p>
<p>问题在于如何分配粉刷次数，先对于每一行单独处理，将不同粉刷次数的答案化为物品。</p>
<p>设 <span class="math inline">\(f_{i,k}\)</span> 表示前 <span class="math inline">\(i\)</span> 位粉刷 <span class="math inline">\(k\)</span> 次最多正确个数，<span class="math inline">\(f_{i,k}\leftarrow f_{j,k-1}+\max\{s_0(j+1,i),s_1(j+1,i)\}\)</span>。</p>
<p>然后对于 <span class="math inline">\(n\times m\)</span> 个物品进行背包即可。</p>
<h2 id="p1092-虫食算-1">P1092 虫食算</h2>
<p><a href="https://www.luogu.com.cn/problem/P1092">题目</a></p>
<p>搜索。</p>
<p>正解好像是高斯消元，不会。</p>
<p>从低位到高位开始搜，当三位中有两个确定时就可以推出第三个。</p>
<p>还有一个剪枝，每确定一列，就扫一遍后面没搜的列，看在进不进位的情况下是否都矛盾。</p>
<h2 id="p3951-小凯的疑惑-1">P3951 小凯的疑惑</h2>
<p><a href="https://www.luogu.com.cn/problem/P3951">题目</a></p>
<p>数论。</p>
<p>打表，发现 <span class="math inline">\(a&lt;b\)</span> 时答案是 <span class="math inline">\((a-1)\times b - a\)</span>。</p>
<p>证明：设无法表示出来的为 x。</p>
<p><span class="math display">\[\begin{aligned} x&amp;\equiv ma\pmod b \quad&amp;(1&lt;m&lt;b)\\ x&amp;=ma+nb\quad&amp;(1&lt;m&lt;b,n&lt;0) \end{aligned}\]</span></p>
<p>当 x 最大时，<span class="math inline">\(m=b-1,n=-1\)</span>，证毕。</p>
<h2 id="p5092-usaco04opencube-stacking-1">P5092 [USACO04OPEN]Cube Stacking</h2>
<p><a href="https://www.luogu.com.cn/record/41327125">题目</a></p>
<p>并查集。</p>
<p>在 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(fa\)</span> 的边之间维护压缩的边数，路径压缩优化，再维护每个并查集的 size。</p>
<h2 id="p2894-usaco08febhotel-g-1">P2894 [USACO08FEB]Hotel G</h2>
<p><a href="https://www.luogu.com.cn/problem/P2894">题目</a></p>
<p>线段树。</p>
<p>维护每个区间的最长连续区间和左端开头、右端开头的最长连续区间。</p>
<p>二分最早的 r 使得 <span class="math inline">\([1,r]\)</span> 的最长连续区间长度大于 x，<span class="math inline">\(\mathcal O(n\log^2n)\)</span>。</p>
<p>query 时直接左区间优先即可，<span class="math inline">\(\mathcal O(n\log n)\)</span>。</p>
<h1 id="日-16">11日</h1>
<h2 id="p7076-动物园-1">P7076 动物园</h2>
<p><a href="https://www.luogu.com.cn/problem/P7076">题目</a></p>
<p>贪心（？），CSP2020 T2。</p>
<p>将所有动物或起来，对于每一位，没有饲料或者有饲料并且已经购买，该位可以选或不选；有饲料且未购买，只能不选。</p>
<p>把每一位的答案乘一下，坑点是开了 unsigned long long 也见祖宗，需要特判 <span class="math inline">\(2^{64}\)</span> 的情况。</p>
<h1 id="日-17">12日</h1>
<h2 id="p7077-函数调用-1">P7077 函数调用</h2>
<p><a href="https://www.luogu.com.cn/problem/P7077">题目</a></p>
<p>拓扑 DP，CSP2020 T3。</p>
<p>考场上写的线段树暴力，<del>好歹也是个不小的数据结构啊怎么才给 30 分！</del>其实是不错的题。</p>
<p>可以发现单点加值，整体乘值，所有操作形成若干个 DAG，只要求最终序列，于是方向转向图论。</p>
<p>设所有乘法之积为 <span class="math inline">\(mul\)</span>，每个点初始值的贡献一定是 <span class="math inline">\(a_i\times mul\)</span>。</p>
<p>接下来考虑单点加和其之后的变化。每个单点加的贡献是后面所有乘法之积。</p>
<p>那么先预处理每个点的及后面乘法的积 <span class="math inline">\(m_i\)</span>，然后按照操作序列倒着 DP 每个DAG 的贡献次数。</p>
<p>再在 DAG 里倒着 DP，<span class="math inline">\(f_v\leftarrow f_v + f_u, f_u\leftarrow f_u\times m_v\)</span>，对于单点加的贡献就有 <span class="math inline">\(f_u\times val_u\)</span>。</p>
<h1 id="日-18">17日</h1>
<h2 id="p7078-贪吃蛇-1">P7078 贪吃蛇</h2>
<p><a href="https://www.luogu.com.cn/problem/P7078">题目</a></p>
<p>博弈论+单调性优化，CSP2020 T4。</p>
<p>见<a href="https://renamoe.github.io/2020/11/17/题解-P7078-贪吃蛇">博客题解</a>。</p>
<h1 id="日-19">20日</h1>
<h2 id="cf455d-serega-and-fun-1">CF455D Serega and Fun</h2>
<p><a href="https://www.luogu.com.cn/problem/CF455D">题目</a></p>
<p>平衡树或者分块。</p>
<p>对于第一个操作可以用一棵 splay 轻松维护，称其为序列树。</p>
<p>因为值域 <span class="math inline">\(\mathcal O(n)\)</span>，第二个操作考虑每个值维护一棵 splay，节点存其对应的序列树的编号。</p>
<p>每次询问一个区间要求在某一棵 splay 里寻找区间内最靠左和最靠右的点，可以通过在序列树上查 rank 来二分，单次 <span class="math inline">\(\mathcal O(\log^2n)\)</span>。</p>
<h2 id="s2oj41-新斯诺克-1">S2OJ#41 新斯诺克</h2>
<p><a href="http://sjzezoj.com:9280/problem/41">题目</a></p>
<p>归并排序就够了。</p>
<p>可以让所有数减去 m，然后做前缀和，满足 <span class="math inline">\(j&lt;i, s_j&lt;s_i\)</span> 的一对点构成一个合法区间。</p>
<p>二维偏序，可以做到 <span class="math inline">\(\mathcal O(n\log n)\)</span>。这个煞笔又写了个比别多个 <span class="math inline">\(\log\)</span> 的 CDQ 分治。</p>
<h1 id="日-20">21日</h1>
<h2 id="s2oj42-方舟连接-1">S2OJ#42 方舟连接</h2>
<p><a href="http://sjzezoj.com:9280/problem/59">题目</a></p>
<p>区间 DP + 四边形不等式优化。</p>
<p>把路径看成一棵树，然后发现这是两两相邻子树合并，转化成一个序列就是区间 DP。</p>
<p><span class="math inline">\(\mathcal O(n^3)\)</span> 过不去，简单证明一下 DP 为凸，套上经典的四边形不等式优化，降到 <span class="math inline">\(\mathcal O(n^2)\)</span>。</p>
<h2 id="s2oj60-a-simple-math-problem-vi-1">S2OJ#60 A Simple Math Problem VI</h2>
<p><a href="http://sjzezoj.com:9280/problem/60">题目</a></p>
<p>小数据裸完全背包。大数据特殊性质 <span class="math inline">\(a_i=1\)</span>，组合数问题 <a href="https://oi-wiki.org/math/combination/#1">见 OI wiki</a>。</p>
<h1 id="日-21">22日</h1>
<h2 id="p4093-heoi2016tjoi2016序列-1">P4093 [HEOI2016/TJOI2016]序列</h2>
<p><a href="https://www.luogu.com.cn/problem/P4093">题目</a></p>
<p>CDQ 分治。</p>
<p>设 <span class="math inline">\(mi_i=\min\{val_i,w_i\},ma_i=\max\{val_i,w_i\}\)</span>，求 LIS 的时候转移的条件为：</p>
<p><span class="math inline">\(\begin{aligned} j&amp;&lt;i\\ val_j&amp;\le mi_i\\ ma_j&amp;\le val_i \end{aligned}\)</span></p>
<p>CDQ 分治，左右分别按上边对应的属性排序；优先递归处理左区间。复杂度 <span class="math inline">\(\mathcal O(n\log^2 n)\)</span>。</p>
<h1 id="日-22">26日</h1>
<h2 id="cf571d-campus-1">CF571D Campus</h2>
<p><a href="https://www.luogu.com.cn/problem/CF571D">题目</a></p>
<p>转化成树上问题 + 树状数组上二分技巧。</p>
<p><a href="http://localhost:4000/2020/11/26/题解-CF571D-Campus/">见博客</a></p>
<h1 id="日-23">27日</h1>
<h2 id="gym102331b-bitwise-xor-1">GYM102331B Bitwise Xor</h2>
<p><a href="https://codeforces.com/gym/102331/problem/B">题目</a></p>
<p>简单 DP + 01-trie。</p>
<p><a href="https://renamoe.github.io/2020/11/27/题解-GYM102331B-Bitwise-Xor/">见博客</a></p>
<h1 id="日-24">28日</h1>
<h2 id="s2oj61-连续段的期望">S2OJ#61 连续段的期望</h2>
<p><a href="https://sjzezoj.com/problem/61">题目</a></p>
<p>二进制优化。</p>
<p><span class="math inline">\(\operatorname{xor,or,and}\)</span> 操作每一位互不影响，可以把每一位分开做（常规套路），其实也是其中 <span class="math inline">\(30\)</span> 分部分分的意义。</p>
<p>对于一个 01 串：</p>
<ul>
<li><span class="math inline">\(\operatorname{xor}\)</span>，每个和为奇数的区间贡献为 <span class="math inline">\(1\)</span>，通过类似差分的技巧扫一遍即可；</li>
<li><span class="math inline">\(\operatorname{and}\)</span>，区间内全为 <span class="math inline">\(1\)</span> 贡献为 <span class="math inline">\(1\)</span>，所有每个连续为 <span class="math inline">\(1\)</span> 的段贡献为 <span class="math inline">\(len^2\)</span>；</li>
<li><span class="math inline">\(\operatorname{or}\)</span>，反过来想，区间全为 <span class="math inline">\(0\)</span> 的没有贡献。</li>
</ul>
<p>记得每一位的答案乘上 <span class="math inline">\(2^i\)</span>。</p>
<h1 id="日-25">29日</h1>
<h2 id="s2oj52-练习曲">S2OJ#52 练习曲</h2>
<p><a href="https://sjzezoj.com/problem/52">题目</a></p>
<p>简单 DP。</p>
<p>不修改的话 DP 方程： <span class="math display">\[
\begin{aligned}
f_i&amp;=\min_{i-L\le j&lt;i}\{f_j\}+w(j+1,i)\\
w(j,i)&amp;=\max\{\max_{j\le k&lt;i}\{a_k\},\ a_i-1\} + 1
\end{aligned}
\]</span></p>
<p>修改的话，发现一个点只影响 <span class="math inline">\(2L\)</span> 个 DP 值，那么预处理正着和倒着分别 DP 一遍，处理影响的一段后拼接得到答案。</p>
<p>可以发现 <span class="math inline">\(f_i\)</span> 是单调不降的。从 <span class="math inline">\((x-L,x]\)</span> 中固定一个起点，当 <span class="math inline">\(x\)</span> 所在段权值一定时，这一段越长越好。</p>
<p>所以每次只要 <span class="math inline">\(\mathcal O(L)\)</span> 处理即可，复杂度 <span class="math inline">\(\mathcal O((n+q)L)\)</span>。其实觉得过不了的。</p>
<h1 id="日-26">30日</h1>
<h2 id="cf1175e-minimal-segment-cover">CF1175E Minimal Segment Cover</h2>
<p><a href="https://www.luogu.com.cn/problem/CF1175E">题目</a></p>
<p>倍增。</p>
<p>设 <span class="math inline">\(f_{i,j}\)</span> 表示从 <span class="math inline">\(i\)</span> 点走 <span class="math inline">\(j\)</span> 条线段能够到达最远的点，每次询问 <span class="math inline">\(\mathcal O(\log n)\)</span> 跳到最远的不超过区间右端，再跳一条线段就是答案。</p>
]]></content>
      <categories>
        <category>刷题记录</category>
      </categories>
  </entry>
  <entry>
    <title>21年2月 刷题记录</title>
    <url>/2021/02/02/21%E5%B9%B42%E6%9C%88-%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>拖着疲惫打开新的一月，也要加油啊。</p>
<a id="more"></a>
<h1 id="日">1日</h1>
<h2 id="p4220-wc2018通道">P4220 [WC2018]通道</h2>
<p><a href="https://www.luogu.com.cn/problem/P4220">题目</a></p>
<p>边分治 + 虚树 + 树形 DP。</p>
<p>三棵树 <span class="math inline">\(T_1,T_2,T_3\)</span>，最大化 <span class="math inline">\(dis_1(u,v)+dis_2(u,v)+dis_3(u,v)\)</span>。</p>
<p>那么 <span class="math inline">\(T_1\)</span> 先边分治，设每次重心边端点为 <span class="math inline">\(eu,ev\)</span> 那么答案就是 <span class="math display">\[
dis_1(eu,u)+dis_1(ev,v)+deep_2(u)+deep_2(v)-2deep_2(\operatorname{LCA}_2(u,v))+dis_3(u,v)
\]</span> 我们得到分治的连通块，将重心边两边的子树分别染成黑色和白色，然后在 <span class="math inline">\(T_2\)</span> 对这些点建立虚树。在虚树上 dfs，那么 <span class="math inline">\(\operatorname{LCA}_2(u,v)\)</span> 就固定了，只要统计属于不同子树且颜色不同的 <span class="math inline">\(u,v\)</span> 的最大答案。</p>
<p>然后设 <span class="math inline">\(w(u)=dis_1(eu)+deep_2(u)\)</span>，把 <span class="math inline">\(w(u),w(v)\)</span> 加到 <span class="math inline">\(T_3\)</span> 中 <span class="math inline">\(u,v\)</span> 的路径长度上，最大化这个新的 <span class="math inline">\(dis_3&#39;(u,v)\)</span> 即可。</p>
<p>现在就是虚树上答案的统计问题了，合并两个 <span class="math inline">\(T_2\)</span> 的子树其实就是合并 <span class="math inline">\(T_3\)</span> 上的两个点集。这里有个结论：点集 <span class="math inline">\(A,B\)</span> 最长路径的端点分别为 <span class="math inline">\(u_A,v_A,u_B,v_B\)</span>，那么 <span class="math inline">\(A\cup B\)</span> 的最长路径的端点一定是 <span class="math inline">\(\{u_A,v_A,u_B,v_B\}\)</span> 中的两个。答案也同时类似的更新一下。</p>
<p><span class="math inline">\(\operatorname{LCA}\)</span> 使用 st 表 <span class="math inline">\(\mathcal O(1)\)</span> 查询。总复杂度 <span class="math inline">\(\mathcal O(n\log^2 n)\)</span>。</p>
]]></content>
      <categories>
        <category>刷题记录</category>
      </categories>
  </entry>
</search>
